-- Configuring done
-- Generating done
-- Build files have been written to: /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build
/usr/bin/cmake -S/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass -B/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build --check-build-system CMakeFiles/Makefile.cmake 0
/usr/bin/cmake -E cmake_progress_start /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build/CMakeFiles /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build/CMakeFiles/progress.marks
make -f CMakeFiles/Makefile2 all
make[1]: Entering directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
make -f CMakeFiles/ALC.dir/build.make CMakeFiles/ALC.dir/depend
make[2]: Entering directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
cd /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build && /usr/bin/cmake -E cmake_depends "Unix Makefiles" /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build/CMakeFiles/ALC.dir/DependInfo.cmake --color=
make[2]: Leaving directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
make -f CMakeFiles/ALC.dir/build.make CMakeFiles/ALC.dir/build
make[2]: Entering directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
make[2]: Nothing to be done for 'CMakeFiles/ALC.dir/build'.
make[2]: Leaving directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
[100%] Built target ALC
make[1]: Leaving directory '/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build'
/usr/bin/cmake -E cmake_progress_start /home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/Analysis-Pass/build/CMakeFiles 0
LAA: Found a loop in s000: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652e962a00, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e965970, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s111: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e969ee0, 2] may alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e965bb0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !110 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !110
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !110
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,8}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,8}<nuw><%for.body5>(Induction step: 2)
LAA: Distance for   %1 = load float, ptr %arrayidx, align 4, !dbg !110, !tbaa !111 to   store float %add, ptr %arrayidx9, align 4, !dbg !118, !tbaa !111: 4
LAA: Strided accesses are independent
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1111: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652e972380, 1] must alias, No access Pointers: (ptr %arrayidx26, unknown before-or-after)
  AliasSet[0x55652e978150, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e97f4f0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e97c130, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !122
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !107
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s112: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e97bef0, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9814e0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(127996 + @a),+,-4}<nw><%for.body5>Sink Scev: {(127992 + @a),+,-4}<nw><%for.body5>(Induction step: -1)
LAA: Distance for   store float %add, ptr %arrayidx10, align 4, !dbg !118, !tbaa !110 to   %0 = load float, ptr %arrayidx, align 4, !dbg !107, !tbaa !110: -4
LAA: Distance 4 that could cause a store-load forwarding conflict
LAA: Forward but may prevent st->ld forwarding
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s1112: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652e985590, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e9827d0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s113: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652e984360, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e98ea90, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1113: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e98d490, 2] may alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after), (ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000), unknown before-or-after)
  AliasSet[0x55652e988640, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000) (read-only)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000)
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
LAA: Found a runtime check ptr:ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000)
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Bad stride - Not an AddRecExpr pointer ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000) SCEV: (64000 + @a)
LAA: Src Scev: (64000 + @a)Sink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 0)
LAA: Distance for   %0 = load float, ptr getelementptr inbounds ([32000 x float], ptr @a, i64 0, i64 16000), align 64, !dbg !107, !tbaa !110 to   store float %add, ptr %arrayidx7, align 4, !dbg !117, !tbaa !110: {-64000,+,4}<nsw><%for.body5>
Pointer access with non-constant stride
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s114: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e99d870, 2] may alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after), (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652e9a3dd0, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !127 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv46, !dbg !119 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !127
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv46, !dbg !119
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !125
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: Found a runtime check ptr:  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !127
LAA: Found a runtime check ptr:  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv46, !dbg !119
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{@aa,+,4}<nw><%for.cond6.preheader>,+,1024}<nuw><%for.body9>Sink Scev: {{@aa,+,1024}<nw><%for.cond6.preheader>,+,4}<nuw><%for.body9>(Induction step: 256)
LAA: Distance for   %0 = load float, ptr %arrayidx11, align 4, !dbg !119, !tbaa !121 to   store float %add, ptr %arrayidx19, align 4, !dbg !128, !tbaa !121: {{0,+,1020}<%for.cond6.preheader>,+,-1020}<%for.body9>
Pointer access with non-constant stride
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s115: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e9a5db0, 2] may alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after), (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652e9aa7b0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv38, !dbg !126 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv41, i64 %indvars.iv38, !dbg !119 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv41 (read-only)
	  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv38, !dbg !126 (read)
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv38, !dbg !126
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv38, !dbg !126
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv41
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv41, i64 %indvars.iv38, !dbg !119
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
LAA: Found a runtime check ptr:  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv38, !dbg !126
LAA: Found a runtime check ptr:  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv41
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Bad stride - Not striding over innermost loop   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv41 SCEV: {@a,+,4}<nw><%for.body5>
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {{(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>,+,4}<nuw><%for.body9>(Induction step: 0)
LAA: Distance for   %1 = load float, ptr %arrayidx13, align 4, !dbg !125, !tbaa !121 to   store float %3, ptr %arrayidx15, align 4, !dbg !127, !tbaa !121: {4,+,4}<nw><%for.body9>
Pointer access with non-constant stride
LAA: Src Scev: {{(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>,+,4}<nuw><%for.body9>Sink Scev: {{(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>,+,4}<nuw><%for.body9>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx15, align 4, !dbg !127, !tbaa !121 to   store float %3, ptr %arrayidx15, align 4, !dbg !127, !tbaa !121: 0
Total Dependences: 2
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s1115: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652e9a7120, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652e9ad0f0, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)
  AliasSet[0x55652e9b0cc0, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !117 (read)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv49, !dbg !124 (read-only)
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !117
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !117
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv49, !dbg !124
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv49, i64 %indvars.iv, !dbg !125
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s116: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 6 pointer values.
  AliasSet[0x55652e9af070, 6] may alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after), (ptr %arrayidx22, unknown before-or-after), (ptr %arrayidx32, unknown before-or-after), (ptr %arrayidx42, unknown before-or-after)

LAA:   Accesses(10):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !95 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %1, !dbg !115 (write)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !119 (write)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !123 (write)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !127 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %1, !dbg !115 (read)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !119 (read)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !123 (read)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !127 (read)
	  %arrayidx42 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !131 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !95
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %1, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %1, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !123
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !123
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx42 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !131
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !95
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %1, !dbg !115
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !123
LAA: Found a runtime check ptr:  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %7, !dbg !127
LAA: Found a runtime check ptr:  %arrayidx42 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !131
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(20 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %9 = load float, ptr %arrayidx42, align 4, !dbg !131, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: -4
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(20 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98 to   %9 = load float, ptr %arrayidx42, align 4, !dbg !131, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(20 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98 to   %9 = load float, ptr %arrayidx42, align 4, !dbg !131, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(20 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   %9 = load float, ptr %arrayidx42, align 4, !dbg !131, !tbaa !98: 16
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(20 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   %9 = load float, ptr %arrayidx42, align 4, !dbg !131, !tbaa !98: 20
LAA: Failure because of positive distance 20
LAA: Src Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %8 = load float, ptr %arrayidx32, align 4, !dbg !127, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 0
LAA: Src Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %8 = load float, ptr %arrayidx32, align 4, !dbg !127, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: -4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98 to   %8 = load float, ptr %arrayidx32, align 4, !dbg !127, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   %8 = load float, ptr %arrayidx32, align 4, !dbg !127, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   %8 = load float, ptr %arrayidx32, align 4, !dbg !127, !tbaa !98: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx22, align 4, !dbg !123, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   store float %mul46, ptr %arrayidx32, align 4, !dbg !133, !tbaa !98: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx22, align 4, !dbg !123, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 0
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx22, align 4, !dbg !123, !tbaa !98 to   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98: -4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   %6 = load float, ptr %arrayidx22, align 4, !dbg !123, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   %6 = load float, ptr %arrayidx22, align 4, !dbg !123, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   store float %mul36, ptr %arrayidx22, align 4, !dbg !129, !tbaa !98: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98 to   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98: 0
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98 to   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98: -4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   %4 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !98 to   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98 to   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   store float %mul26, ptr %arrayidx12, align 4, !dbg !125, !tbaa !98: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !98 to   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98: 0
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {@a,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !98 to   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98: -4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !117, !tbaa !98 to   store float %mul16, ptr %arrayidx, align 4, !dbg !121, !tbaa !98: 4
LAA: Strided accesses are independent
Total Dependences: 5
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s118: for.body9
LAA: Found a read-only loop!
LAA: Found a loop in s119: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e9c2b80, 2] may alias, No access Pointers: (ptr %arrayidx20, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652e9c1ae0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx20 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !127 (write)
	  %arrayidx12 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %1, !dbg !120 (read-only)
	  %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !127
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %1, !dbg !120
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !125
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: Found a runtime check ptr:  %arrayidx20 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !127
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %1, !dbg !120
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{@aa,+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>Sink Scev: {{(1028 + @aa),+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx12, align 4, !dbg !120, !tbaa !121 to   store float %add, ptr %arrayidx20, align 4, !dbg !128, !tbaa !121: 1028
LAA: Positive distance 1028 with max VF = 8
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1119: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e9bf620, 2] may alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after), (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652e9c7c30, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv43, i64 %indvars.iv, !dbg !126 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv43, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv43, i64 %indvars.iv, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !117
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv43, i64 %indvars.iv, !dbg !124
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: Found a runtime check ptr:  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv43, i64 %indvars.iv, !dbg !126
LAA: Found a runtime check ptr:  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !117
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{@aa,+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>Sink Scev: {{(1024 + @aa),+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx11, align 4, !dbg !117, !tbaa !120 to   store float %add, ptr %arrayidx19, align 4, !dbg !127, !tbaa !120: 1024
LAA: Positive distance 1024 with max VF = 256
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.

Function:  s000

Loop at line number: 57
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s111

Loop at line number: 78
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1111

Loop at line number: 98
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s112

Loop at line number: 120
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1112

Loop at line number: 140
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s113

Loop at line number: 162
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1113

Loop at line number: 182
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s114

Loop at line number: 206
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s115

Loop at line number: 230
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1115

Loop at line number: 252
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s116

Loop at line number: 274
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s118

Loop at line number: 301
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s119

Loop at line number: 325
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1119

Loop aLAA: Found a loop in s121: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e9c79d0, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9c6720, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %0 = load float, ptr %arrayidx, align 4, !dbg !111, !tbaa !112 to   store float %add8, ptr %arrayidx10, align 4, !dbg !119, !tbaa !112: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s122: for.body
LAA: Found a loop in s122: for.body5.us
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s123: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 6 pointer values.
  AliasSet[0x55652e9d89c0, 2] may alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after), (ptr %arrayidx23, unknown before-or-after)
  AliasSet[0x55652e9d67c0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9d3e60, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e9e24c0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652e9e1220, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom10, !dbg !119 (write)
	  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom22, !dbg !128 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom10, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom22, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !117
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !121
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Can't find bounds for ptr:  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom10, !dbg !119
LAA: Can't find bounds for ptr:  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom22, !dbg !128
LAA: We need to do 0 pointer comparisons.
LAA: We can't vectorize because we can't find the array bounds.
LAA: Found a loop in s124: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652e9dd880, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652e9e3680, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9e6fc0, 1] must alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after)
  AliasSet[0x55652e9e5820, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652e9e3b70, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom13, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom13, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !117
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s125: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652e9db880, 1] must alias, No access Pointers: (ptr %arrayidx21, unknown before-or-after)
  AliasSet[0x55652e9ee0a0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652e9ecf30, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)
  AliasSet[0x55652e9ebcf0, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx21 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv.next49, !dbg !129 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !126 (read-only)
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !127 (read-only)
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv.next49, !dbg !129
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !121
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !126
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv53, i64 %indvars.iv, !dbg !127
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s126: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652e9ea4d0, 1] must alias, No access Pointers: (ptr %arrayidx22, unknown before-or-after)
  AliasSet[0x55652e9f4b60, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652e9f4330, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv58, !dbg !130 (write)
	  %arrayidx14 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %4, !dbg !127 (read-only)
	  %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv58, !dbg !128 (read-only)
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv58, !dbg !130
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %4, !dbg !127
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv58, !dbg !128
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s127: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 6 pointer values.
  AliasSet[0x55652e9f0bf0, 2] may alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after), (ptr %arrayidx20, unknown before-or-after)
  AliasSet[0x55652e9f4ef0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9f88e0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e9f6570, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652e9f9450, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !119 (write)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next44, !dbg !124 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next44, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !122
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Found a runtime check ptr:  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next44, !dbg !124
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,8}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,8}<nuw><%for.body5>(Induction step: 2)
LAA: Distance for   store float %4, ptr %arrayidx11, align 4, !dbg !120, !tbaa !112 to   store float %6, ptr %arrayidx20, align 4, !dbg !125, !tbaa !112: 4
LAA: Strided accesses are independent
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s128: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652e9f62d0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652e9fa9f0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9fca80, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e9fdbc0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !112 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !112 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %0, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !112
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !112
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %0, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s131: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652e9f3080, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9fadd0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !111
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %0 = load float, ptr %arrayidx, align 4, !dbg !111, !tbaa !112 to   store float %add8, ptr %arrayidx10, align 4, !dbg !119, !tbaa !112: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s132: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea02100, 2] may alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ea0a550, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx13 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx7 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 1, i64 %1, !dbg !117 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !120
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 1, i64 %1, !dbg !117
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !118
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx13 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 1, i64 %1, !dbg !117
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(1024 + @aa),+,4}<nuw><%for.body5>Sink Scev: {(4 + @aa)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !97 to   store float %4, ptr %arrayidx13, align 4, !dbg !121, !tbaa !97: -1020
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s141: for.body13
LAA: Bad stride - Not an AddRecExpr pointer   %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128 SCEV: ((4 * (zext i32 {(({0,+,2,+,2}<%for.body13.lr.ph> /u 2) + {0,+,1}<%for.body13.lr.ph>),+,{1,+,1}<%for.body13.lr.ph>,+,1}<%for.body13> to i64))<nuw><nsw> + @flat_2d_array)<nuw>
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ea0c850, 1] must alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after)
  AliasSet[0x55652ea127b0, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128 (write)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv48, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128 (read-only)
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv48, i64 %indvars.iv, !dbg !121
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Bad stride - Not an AddRecExpr pointer   %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128 SCEV: ((4 * (zext i32 {(({0,+,2,+,2}<%for.body13.lr.ph> /u 2) + {0,+,1}<%for.body13.lr.ph>),+,{1,+,1}<%for.body13.lr.ph>,+,1}<%for.body13> to i64))<nuw><nsw> + @flat_2d_array)<nuw>
LAA: Bad stride - Not an AddRecExpr pointer   %arrayidx17 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom16, !dbg !128 SCEV: ((4 * (zext i32 {(({0,+,2,+,2}<%for.body13.lr.ph> /u 2) + {0,+,1}<%for.body13.lr.ph>),+,{1,+,1}<%for.body13.lr.ph>,+,1}<%for.body13> to i64))<nuw><nsw> + @flat_2d_array)<nuw>
LAA: Src Scev: ((4 * (zext i32 {(({0,+,2,+,2}<%for.body13.lr.ph> /u 2) + {0,+,1}<%for.body13.lr.ph>),+,{1,+,1}<%for.body13.lr.ph>,+,1}<%for.body13> to i64))<nuw><nsw> + @flat_2d_array)<nuw>Sink Scev: ((4 * (zext i32 {(({0,+,2,+,2}<%for.body13.lr.ph> /u 2) + {0,+,1}<%for.body13.lr.ph>),+,{1,+,1}<%for.body13.lr.ph>,+,1}<%for.body13> to i64))<nuw><nsw> + @flat_2d_array)<nuw>(Induction step: 0)
LAA: Distance for   %4 = load float, ptr %arrayidx17, align 4, !dbg !129, !tbaa !124 to   store float %add18, ptr %arrayidx17, align 4, !dbg !129, !tbaa !124: 0
Pointer access with non-constant stride
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s151s: for.body
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652ea13df0, 3] may alias, No access Pointers: (ptr %arrayidx5, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx2, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv, !dbg !85 (write)
	  %arrayidx = getelementptr inbounds float, ptr %a, i64 %1, !dbg !78 (read-only)
	  %arrayidx2 = getelementptr inbounds float, ptr %b, i64 %indvars.iv, !dbg !83 (read-only)
Underlying objects for pointer   %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv, !dbg !85
  ptr %a
Underlying objects for pointer   %arrayidx = getelementptr inbounds float, ptr %a, i64 %1, !dbg !78
  ptr %a
Underlying objects for pointer   %arrayidx2 = getelementptr inbounds float, ptr %b, i64 %indvars.iv, !dbg !83
  ptr %b
LAA: Found a runtime check ptr:  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv, !dbg !85
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %a, i64 %1, !dbg !78
LAA: Found a runtime check ptr:  %arrayidx2 = getelementptr inbounds float, ptr %b, i64 %indvars.iv, !dbg !83
LAA: We need to do 1 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {((4 * (sext i32 %m to i64))<nsw> + %a),+,4}<nw><%for.body>Sink Scev: {%a,+,4}<nuw><%for.body>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !78, !tbaa !79 to   store float %add3, ptr %arrayidx5, align 4, !dbg !86, !tbaa !79: (-4 * (sext i32 %m to i64))<nsw>
LAA: Dependence because of non-constant distance
Total Dependences: 1
LAA: Retrying with memory checks
LAA: Found a runtime check ptr:  %arrayidx5 = getelementptr inbounds float, ptr %a, i64 %indvars.iv, !dbg !85
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %a, i64 %1, !dbg !78
LAA: Found a runtime check ptr:  %arrayidx2 = getelementptr inbounds float, ptr %b, i64 %indvars.iv, !dbg !83
LAA: We need to do 2 pointer comparisons.
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
t line number: 347
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s121

Loop at line number: 371
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s122

Loop at line number: 405
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s122

Loop at line number: 402
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s123

Loop at line number: 428
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s124

Loop at line number: 457
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s125

Loop at line number: 487
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s126

Loop at line number: 513
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s127

Loop at line number: 540
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s128

Loop at line number: 568
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s131

Loop at line number: 593
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s132

Loop at line number: 617
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s141

Loop at line number: 643
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s151s

Loop at line number: 659
Loop doesn't contain function call
LLAA: Found a loop in s151: for.body.i
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea1f260, 2] may alias, No access Pointers: (ptr %arrayidx5.i, unknown before-or-after), (ptr %arrayidx.i, unknown before-or-after)
  AliasSet[0x55652ea1a8c0, 1] must alias, No access Pointers: (ptr %arrayidx2.i, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx5.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv.i, !dbg !118 (write)
	  %arrayidx.i = getelementptr inbounds float, ptr @a, i64 %0, !dbg !111 (read-only)
	  %arrayidx2.i = getelementptr inbounds float, ptr @b, i64 %indvars.iv.i, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx5.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv.i, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx.i = getelementptr inbounds float, ptr @a, i64 %0, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx2.i = getelementptr inbounds float, ptr @b, i64 %indvars.iv.i, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx5.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv.i, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx.i = getelementptr inbounds float, ptr @a, i64 %0, !dbg !111
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body.i>Sink Scev: {@a,+,4}<nuw><%for.body.i>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx.i, align 4, !dbg !111, !tbaa !112 to   store float %add3.i, ptr %arrayidx5.i, align 4, !dbg !119, !tbaa !112: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s152: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ea25a70, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ea29e70, 1] must alias, No access Pointers: (ptr %arrayidx4.i, unknown before-or-after)
  AliasSet[0x55652ea2ff70, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea2f130, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ea2bd60, 1] must alias, No access Pointers: (ptr %arrayidx2.i, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx4.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv, !dbg !129 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx2.i = getelementptr inbounds float, ptr @c, i64 %indvars.iv, !dbg !128 (read-only)
	  %arrayidx4.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv, !dbg !129 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx4.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv, !dbg !129
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx4.i = getelementptr inbounds float, ptr @a, i64 %indvars.iv, !dbg !129
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx2.i = getelementptr inbounds float, ptr @c, i64 %indvars.iv, !dbg !128
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s161: for.body5
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s1161: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 6 pointer values.
  AliasSet[0x55652ea264e0, 2] may alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after), (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652ea3c4f0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea3b1c0, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ea3d9a0, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr %a.sink, i64 0, i64 %indvars.iv, !dbg !128 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !111 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr %a.sink, i64 0, i64 %indvars.iv, !dbg !128
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !111
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !119
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !125
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Can't find bounds for ptr:  %arrayidx14 = getelementptr inbounds [32000 x float], ptr %a.sink, i64 0, i64 %indvars.iv, !dbg !128
LAA: Found a runtime check ptr:  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
LAA: We need to do 0 pointer comparisons.
LAA: We can't vectorize because we can't find the array bounds.
LAA: Found a loop in s162: for.body
LAA: Found a loop in s162: for.body6.us
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 4 pointer values.
  AliasSet[0x55652ea3cc90, 2] may alias, No access Pointers: (ptr %arrayidx12.us, unknown before-or-after), (ptr %arrayidx.us, unknown before-or-after)
  AliasSet[0x55652ea443e0, 1] must alias, No access Pointers: (ptr %arrayidx8.us, unknown before-or-after)
  AliasSet[0x55652ea42a80, 1] must alias, No access Pointers: (ptr %arrayidx10.us, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx12.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !114 (read-only)
	  %arrayidx8.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx10.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx12.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx8.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx10.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !118
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Found a runtime check ptr:  %arrayidx12.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !114
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {((4 * (zext i32 %1 to i64))<nuw><nsw> + @a),+,4}<nuw><%for.body6.us>Sink Scev: {@a,+,4}<nuw><%for.body6.us>(Induction step: 1)
LAA: Distance for   %4 = load float, ptr %arrayidx.us, align 4, !dbg !114, !tbaa !115 to   store float %7, ptr %arrayidx12.us, align 4, !dbg !121, !tbaa !115: (-4 * (zext i32 %1 to i64))<nsw>
LAA: Dependence because of non-constant distance
Total Dependences: 1
LAA: Retrying with memory checks
LAA: Found a runtime check ptr:  %arrayidx12.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %3, !dbg !114
LAA: We need to do 1 pointer comparisons.
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s171: for.body5
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125 Stride:   %2 = sext i32 %1 to i64, !dbg !105
LAA: Found a strided access that we can version.
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125 Stride:   %2 = sext i32 %1 to i64, !dbg !105
LAA: Found a strided access that we can version.
LAA: Replacing SCEV: {@a,+,(4 * (sext i32 %1 to i64))<nsw>}<nw><%for.body5> by: {@a,+,4}<nw><%for.body5>
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ea35350, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ea45d40, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !125
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s172: for.body
LAA: Found a loop in s172: for.body5.us
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s173: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea587c0, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea55520, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %2, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(64000 + @a),+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %0 = load float, ptr %arrayidx, align 4, !dbg !108, !tbaa !111 to   store float %add, ptr %arrayidx10, align 4, !dbg !119, !tbaa !111: 64000
LAA: Positive distance 64000 with max VF = 16000
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s174: for.cond2.preheader
LAA: Found a loop in s174: for.body5.us
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea5a790, 2] may alias, No access Pointers: (ptr %arrayidx10.us, unknown before-or-after), (ptr %arrayidx.us, unknown before-or-after)
  AliasSet[0x55652ea5d810, 1] must alias, No access Pointers: (ptr %arrayidx7.us, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !116 (write)
	  %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx7.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
Underlying objects for pointer   %arrayidx10.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx10.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %5, !dbg !116
LAA: Found a runtime check ptr:  %arrayidx.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5.us>Sink Scev: {((4 * (zext i32 %1 to i64))<nuw><nsw> + @a),+,4}<nuw><%for.body5.us>(Induction step: 1)
LAA: Distance for   %3 = load float, ptr %arrayidx.us, align 4, !dbg !108, !tbaa !111 to   store float %add.us, ptr %arrayidx10.us, align 4, !dbg !117, !tbaa !111: (4 * (zext i32 %1 to i64))<nuw><nsw>
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s175: for.body5
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122 Stride:   %2 = sext i32 %1 to i64, !dbg !105
LAA: Found a strided access that we can version.
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !125 Stride:   %2 = sext i32 %1 to i64, !dbg !105
LAA: Found a strided access that we can version.
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127 Stride:   %2 = sext i32 %1 to i64, !dbg !105
LAA: Found a strided access that we can version.
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea5d580, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea5b640, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !125
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Replacing SCEV: {@a,+,(4 * (sext i32 %1 to i64))<nsw>}<nw><%for.body5> by: {@a,+,4}<nw><%for.body5>
LAA: Replacing SCEV: {@a,+,4}<nw><%for.body5> by: {@a,+,4}<nw><%for.body5>
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127
LAA: Replacing SCEV: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5> by: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>
LAA: Replacing SCEV: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5> by: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Replacing SCEV: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5> by: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>
LAA: Replacing SCEV: {@a,+,4}<nw><%for.body5> by: {@a,+,4}<nw><%for.body5>
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %3 = load float, ptr %arrayidx, align 4, !dbg !122, !tbaa !123 to   store float %add8, ptr %arrayidx10, align 4, !dbg !128, !tbaa !123: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
oop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s151

Loop at line number: 659
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s152

Loop at line number: 699
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s161

Loop at line number: 723
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1161

Loop at line number: 752
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s162

Loop at line number: 788
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s162

Loop at line number: 785
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s171

Loop at line number: 811
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s172

Loop at line number: 839
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s172

Loop at line number: 837
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s173

Loop at line number: 859
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s174

Loop at line number: 886
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s174

Loop at line number: 884
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s175

Loop at line number: 909
Loop doesn't contain function call
Loop doesn't contain memory dependency
LLAA: Found a loop in s176: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ea69e60, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652ea6c410, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !126 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %2, !dbg !125 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !126 (read)
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !126
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !126
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %2, !dbg !125
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s211: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 6 pointer values.
  AliasSet[0x55652ea6d530, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ea70d20, 2] may alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after), (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652ea77190, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ea769b0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ea72b30, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !123 (write)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv.next, !dbg !120 (read-only)
	  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !123
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv.next, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !121
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Found a runtime check ptr:  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !123
LAA: Found a runtime check ptr:  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv.next, !dbg !120
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(8 + @b)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {(4 + @b)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %4 = load float, ptr %arrayidx13, align 4, !dbg !120, !tbaa !98 to   store float %6, ptr %arrayidx19, align 4, !dbg !124, !tbaa !98: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s212: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652ea7a970, 2] may alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after), (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ea849f0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652ea8cb40, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea899f0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117 (read-only)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !118
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %mul, ptr %arrayidx7, align 4, !dbg !95, !tbaa !98 to   %2 = load float, ptr %arrayidx9, align 4, !dbg !117, !tbaa !98: 4
LAA: Failure because of positive distance 4
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s1213: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652ea8cd80, 2] may alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652ea8f3e0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652ea977b0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ea945e0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !119 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !120
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !119
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %add, ptr %arrayidx9, align 4, !dbg !117, !tbaa !98 to   %2 = load float, ptr %arrayidx12, align 4, !dbg !119, !tbaa !98: 4
LAA: Failure because of positive distance 4
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s221: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652ea956f0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ea981b0, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652eaa1970, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea9dbf0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1221: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ea9ac80, 2] may alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ea9f1d0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !110 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !110
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %0, !dbg !110
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@b,+,4}<nuw><%for.body5>Sink Scev: {(16 + @b)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx, align 4, !dbg !110, !tbaa !111 to   store float %add, ptr %arrayidx9, align 4, !dbg !118, !tbaa !111: 16
LAA: Positive distance 16 with max VF = 4
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s222: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652eaa45b0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652eaa98b0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eab0c60, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eab34c0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (read)
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s231: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652eaaf330, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652eabfa40, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !126 (write)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !124
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s232: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652eabb890, 1] must alias, No access Pointers: (ptr %arrayidx24, unknown before-or-after)
  AliasSet[0x55652eaca9d0, 1] must alias, No access Pointers: (ptr %arrayidx20, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx24 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv56, i64 %indvars.iv, !dbg !126 (write)
	  %arrayidx20 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv56, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv56, i64 %indvars.iv, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv56, i64 %indvars.iv, !dbg !124
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1232: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652eac27a0, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652eac7d90, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ead0f20, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !126 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !117
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv45, i64 %indvars.iv, !dbg !124
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s233: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652eac9360, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652ead9480, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !126 (write)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !124
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s233: for.body24
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ead9230, 2] may alias, No access Pointers: (ptr %arrayidx38, unknown before-or-after), (ptr %arrayidx29, unknown before-or-after)
  AliasSet[0x55652ead4570, 1] must alias, No access Pointers: (ptr %arrayidx33, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %indvars.iv78, !dbg !141 (write)
	  %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %0, !dbg !136 (read-only)
	  %arrayidx33 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv74, i64 %indvars.iv78, !dbg !139 (read-only)
Underlying objects for pointer   %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %indvars.iv78, !dbg !141
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %0, !dbg !136
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx33 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv74, i64 %indvars.iv78, !dbg !139
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: Found a runtime check ptr:  %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %indvars.iv78, !dbg !141
LAA: Found a runtime check ptr:  %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv74, i64 %0, !dbg !136
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{(1024 + @bb),+,4}<nw><%for.cond6.preheader>,+,1024}<nuw><%for.body24>Sink Scev: {{(1028 + @bb),+,4}<nw><%for.cond6.preheader>,+,1024}<nuw><%for.body24>(Induction step: 256)
LAA: Distance for   %3 = load float, ptr %arrayidx29, align 4, !dbg !136, !tbaa !110 to   store float %add34, ptr %arrayidx38, align 4, !dbg !142, !tbaa !110: 4
LAA: Strided accesses are independent
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2233: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ead3980, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652eae2950, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !126 (write)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv78, !dbg !124
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
oop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s176

Loop at line number: 933
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s211

Loop at line number: 962
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s212

Loop at line number: 985
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1213

Loop at line number: 1006
Loop doesn't contain function call
Loop contains memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s221

Loop at line number: 1029
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1221

Loop at line number: 1049
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s222

Loop at line number: 1071
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s231

Loop at line number: 1095
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s232

Loop at line number: 1119
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1232

Loop at line number: 1141
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s233

Loop at line number: 1165
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s233

Loop at line number: 1168
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2233

Loop at line number: 1190
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output depenLAA: Found a loop in s2233: for.body24
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652eae26d0, 2] may alias, No access Pointers: (ptr %arrayidx38, unknown before-or-after), (ptr %arrayidx29, unknown before-or-after)
  AliasSet[0x55652eadc690, 1] must alias, No access Pointers: (ptr %arrayidx33, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv78, i64 %indvars.iv74, !dbg !141 (write)
	  %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %0, i64 %indvars.iv74, !dbg !136 (read-only)
	  %arrayidx33 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv78, i64 %indvars.iv74, !dbg !139 (read-only)
Underlying objects for pointer   %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv78, i64 %indvars.iv74, !dbg !141
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %0, i64 %indvars.iv74, !dbg !136
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx33 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv78, i64 %indvars.iv74, !dbg !139
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: Found a runtime check ptr:  %arrayidx38 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv78, i64 %indvars.iv74, !dbg !141
LAA: Found a runtime check ptr:  %arrayidx29 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %0, i64 %indvars.iv74, !dbg !136
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{(4 + @bb)<nuw><nsw>,+,1024}<nw><%for.cond6.preheader>,+,4}<nuw><%for.body24>Sink Scev: {{(1028 + @bb),+,1024}<nw><%for.cond6.preheader>,+,4}<nuw><%for.body24>(Induction step: 1)
LAA: Distance for   %3 = load float, ptr %arrayidx29, align 4, !dbg !136, !tbaa !110 to   store float %add34, ptr %arrayidx38, align 4, !dbg !142, !tbaa !110: 1024
LAA: Positive distance 1024 with max VF = 256
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s235: for.body13
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652eadb450, 1] must alias, No access Pointers: (ptr %arrayidx27, unknown before-or-after)
  AliasSet[0x55652eae7300, 1] must alias, No access Pointers: (ptr %arrayidx21, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx27 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv56, !dbg !130 (write)
	  %arrayidx21 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv56, !dbg !128 (read-only)
Underlying objects for pointer   %arrayidx27 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv56, !dbg !130
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv56, !dbg !128
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s241: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652eae5760, 2] may alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after), (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652eae8080, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eaee430, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eaeda90, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %mul10, ptr %arrayidx12, align 4, !dbg !119, !tbaa !110 to   %3 = load float, ptr %arrayidx16, align 4, !dbg !121, !tbaa !110: 4
LAA: Failure because of positive distance 4
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s242: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652eaef4b0, 1] must alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after)
  AliasSet[0x55652eaeff30, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)
  AliasSet[0x55652eaf9880, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652eaf1ee0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !141 (write)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !135 (read-only)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !137 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !139 (read-only)
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !141
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !135
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !137
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !139
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s243: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 6 pointer values.
  AliasSet[0x55652eaeb150, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eaf7370, 2] may alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after), (ptr %arrayidx23, unknown before-or-after)
  AliasSet[0x55652eafd7c0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eafc1e0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eaf8e60, 1] must alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (write)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
	  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !118
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Found a runtime check ptr:  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %6 = load float, ptr %arrayidx23, align 4, !dbg !122, !tbaa !110 to   store float %7, ptr %arrayidx11, align 4, !dbg !124, !tbaa !110: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s244: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652eb01e70, 2] may alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after), (ptr %arrayidx22, unknown before-or-after)
  AliasSet[0x55652eb0be00, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb0b4d0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb0ab50, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (write)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122 (read)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !122
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %4 = load float, ptr %arrayidx22, align 4, !dbg !122, !tbaa !110 to   store float %5, ptr %arrayidx22, align 4, !dbg !124, !tbaa !110: 0
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %3, ptr %arrayidx11, align 4, !dbg !118, !tbaa !110 to   %4 = load float, ptr %arrayidx22, align 4, !dbg !122, !tbaa !110: 4
LAA: Failure because of positive distance 4
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %3, ptr %arrayidx11, align 4, !dbg !118, !tbaa !110 to   store float %5, ptr %arrayidx22, align 4, !dbg !124, !tbaa !110: 4
LAA: Failure because of positive distance 4
Total Dependences: 3
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s1244: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652eb0b290, 2] may alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after), (ptr %arrayidx22, unknown before-or-after)
  AliasSet[0x55652eb12170, 1] must alias, No access Pointers: (ptr %arrayidx25, unknown before-or-after)
  AliasSet[0x55652eb154e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb14cd0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx25 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !123 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx25 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !123
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Found a runtime check ptr:  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: Found a runtime check ptr:  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !121
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %add, ptr %arrayidx17, align 4, !dbg !119, !tbaa !110 to   %4 = load float, ptr %arrayidx22, align 4, !dbg !121, !tbaa !110: 4
LAA: Failure because of positive distance 4
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s2244: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 5 pointer values.
  AliasSet[0x55652eb09580, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx17, unknown before-or-after)
  AliasSet[0x55652eb17550, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb1be20, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb1a250, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117 (write)
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %add, ptr %arrayidx10, align 4, !dbg !118, !tbaa !110 to   store float %add15, ptr %arrayidx17, align 4, !dbg !122, !tbaa !110: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s251: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652eb129c0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652eb18880, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb20d40, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb23dd0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1251: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652eb238e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb38f00, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eb3fe20, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb3eab0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652eb398e0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (write)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (read)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !118
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !121
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2251: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652eb23b70, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb5ac00, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eb5dca0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb59ef0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652eb58420, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !109 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
	  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !109
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s3251: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652eb59750, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652eb73d60, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb779a0, 1] must alias, No access Pointers: (ptr %arrayidx23, unknown before-or-after)
  AliasSet[0x55652eb76720, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eb750f0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (write)
	  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !124 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv.next, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx23 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !124
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s252: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652eb79830, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eb782d0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eb8df70, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !109 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !109
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
dency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2233

Loop at line number: 1193
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s235

Loop at line number: 1217
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s241

Loop at line number: 1240
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s242

Loop at line number: 1267
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s243

Loop at line number: 1289
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s244

Loop at line number: 1313
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1244

Loop at line number: 1335
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2244

Loop at line number: 1356
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s251

Loop at line number: 1380
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1251

Loop at line number: 1402
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2251

Loop at line number: 1425
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s3251

Loop at line number: 1447
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s252

Loop at line number: 1473
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
LAA: Found a loop in s253: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652eb90a30, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652eba4d90, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ebab8f0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eba93a0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (read)
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !119
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s254: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ebab6b0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eba7d70, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s255: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ebac220, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)
  AliasSet[0x55652ebeb8e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s256: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652ebe25c0, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652ec0a210, 1] must alias, No access Pointers: (ptr %arrayidx24, unknown before-or-after)
  AliasSet[0x55652ec09e60, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ec08880, 1] must alias, No access Pointers: (ptr %arrayidx20, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !125 (write)
	  %arrayidx24 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv51, !dbg !130 (write)
	  %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv51, !dbg !127 (read-only)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !128 (read-only)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !125
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv51, !dbg !130
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv51, !dbg !127
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !128
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s257: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652ec058c0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ec296a0, 1] must alias, No access Pointers: (ptr %arrayidx22, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !126 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !126 (read)
	  %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !127 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !126
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv53, !dbg !127
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s258: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 6 alias sets for 6 pointer values.
  AliasSet[0x55652ec25e00, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ec44150, 1] must alias, No access Pointers: (ptr %arrayidx23, unknown before-or-after)
  AliasSet[0x55652ec4b810, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ec4dff0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ec45da0, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652ec259f0, 1] must alias, No access Pointers: (ptr %arrayidx20, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121 (write)
	  %arrayidx23 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !126 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx20 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx23 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !126
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !124
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s261: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652ec53300, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ec6ffa0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652ec71ad0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ec6ec00, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120 (read)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !120
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s271: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652ec71c00, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652ec6c970, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ec7f700, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (read)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s272: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ec80cc0, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652ec8e570, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652ec93f00, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ec92580, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ec8fa20, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !130 (write)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !132 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !127 (read-only)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !130 (read)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !132 (read)
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !130
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !130
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !132
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !132
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !127
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s273: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ec7f9e0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652eca7c00, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ecb2110, 1] must alias, No access Pointers: (ptr %arrayidx24, unknown before-or-after)
  AliasSet[0x55652ecad2c0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652eca8250, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(8):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (read)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120 (read)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s274: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ecb2d30, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ecc5f70, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ecca920, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ecc8a20, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eccb9d0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122 (read)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !107
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !114
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s275: for.body10
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652ecd9f50, 1] must alias, No access Pointers: (ptr %arrayidx26, unknown before-or-after)
  AliasSet[0x55652ecdc640, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ecdc2b0, 1] must alias, No access Pointers: (ptr %arrayidx22, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx26 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !128 (write)
	  %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !125 (read-only)
	  %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !126 (read-only)
Underlying objects for pointer   %arrayidx26 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !128
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !125
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv54, !dbg !126
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2275: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652ecdbbc0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ecede80, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)
  AliasSet[0x55652ecf16e0, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !127 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !127 (read)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !130 (read-only)
	  %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !131 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !127
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !127
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !130
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv61, !dbg !131
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s253

Loop at line number: 1498
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s254

Loop at line number: 1526
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s255

Loop at line number: 1552
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s256

Loop at line number: 1577
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s257

Loop at line number: 1602
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s258

Loop at line number: 1626
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s261

Loop at line number: 1653
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s271

Loop at line number: 1676
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s272

Loop at line number: 1703
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s273

Loop at line number: 1728
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s274

Loop at line number: 1753
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s275

Loop at line number: 1782
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2275

Loop at line number: 1804
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
LoLAA: Found a loop in s276: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652ecef5b0, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652ecfcdb0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ecff6b0, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr %c.d, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113 (read)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr %c.d, i64 0, i64 %indvars.iv, !dbg !113
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s277: for.body5
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s278: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 9 pointer values.
  AliasSet[0x55652ecfee40, 2] may alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after), (ptr %arrayidx25.phi.trans.insert, unknown before-or-after)
  AliasSet[0x55652ed1b240, 2] may alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after), (ptr %arrayidx27.phi.trans.insert, unknown before-or-after)
  AliasSet[0x55652ed1bd90, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ed1bb30, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652ed1b640, 2] may alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after), (ptr %arrayidx21, unknown before-or-after)

LAA:   Accesses(12):
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111 (read)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
	  %arrayidx27.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128 (read)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !130 (read-only)
	  %arrayidx21 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !131 (read-only)
	  %arrayidx25.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv (read-only)
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx25.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx27.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !130
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !122
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !131
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Found a runtime check ptr:  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx25.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv
LAA: Found a runtime check ptr:  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128
LAA: Found a runtime check ptr:  %arrayidx27.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@b,+,4}<nw><%for.body5>Sink Scev: {@b,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %4, ptr %arrayidx8, align 4, !dbg !124, !tbaa !113 to   %.pre = load float, ptr %arrayidx25.phi.trans.insert, align 4, !dbg !134, !tbaa !113: 0
LAA: Src Scev: {@b,+,4}<nw><%for.body5>Sink Scev: {@b,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx8, align 4, !dbg !119, !tbaa !113 to   store float %4, ptr %arrayidx8, align 4, !dbg !124, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %.pre58 = load float, ptr %arrayidx27.phi.trans.insert, align 4, !dbg !125, !tbaa !113 to   store float %8, ptr %arrayidx16, align 4, !dbg !133, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx16, align 4, !dbg !128, !tbaa !113 to   store float %8, ptr %arrayidx16, align 4, !dbg !133, !tbaa !113: 0
Total Dependences: 4
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s279: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 10 pointer values.
  AliasSet[0x55652ed1e630, 2] may alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after), (ptr %arrayidx38.phi.trans.insert, unknown before-or-after)
  AliasSet[0x55652ed3d170, 3] may alias, No access Pointers: (ptr %arrayidx27, unknown before-or-after), (ptr %arrayidx29, unknown before-or-after), (ptr %arrayidx40.phi.trans.insert, unknown before-or-after)
  AliasSet[0x55652ed3a6f0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ed363b0, 2] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx42.phi.trans.insert, unknown before-or-after)
  AliasSet[0x55652ed3e640, 2] may alias, No access Pointers: (ptr %arrayidx25, unknown before-or-after), (ptr %arrayidx32, unknown before-or-after)

LAA:   Accesses(14):
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx27 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !129 (write)
	  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !133 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111 (read)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx40.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv (read-only)
	  %arrayidx25 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !128 (read-only)
	  %arrayidx27 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !129 (read)
	  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !133 (read)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !135 (read-only)
	  %arrayidx38.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv (read-only)
	  %arrayidx42.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv (read-only)
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx38.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx27 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !129
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx27 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !129
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !133
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !133
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx40.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !121
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx42.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx25 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !128
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !135
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: Found a runtime check ptr:  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx38.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv
LAA: Found a runtime check ptr:  %arrayidx27 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !129
LAA: Found a runtime check ptr:  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !133
LAA: Found a runtime check ptr:  %arrayidx40.phi.trans.insert = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@b,+,4}<nw><%for.body5>Sink Scev: {@b,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %3, ptr %arrayidx8, align 4, !dbg !123, !tbaa !113 to   %.pre = load float, ptr %arrayidx38.phi.trans.insert, align 4, !dbg !138, !tbaa !113: 0
LAA: Src Scev: {@b,+,4}<nw><%for.body5>Sink Scev: {@b,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx8, align 4, !dbg !119, !tbaa !113 to   store float %3, ptr %arrayidx8, align 4, !dbg !123, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %.pre76 = load float, ptr %arrayidx40.phi.trans.insert, align 4, !dbg !127, !tbaa !113 to   store float %9, ptr %arrayidx29, align 4, !dbg !137, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %.pre76 = load float, ptr %arrayidx40.phi.trans.insert, align 4, !dbg !127, !tbaa !113 to   store float %6, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %7 = load float, ptr %arrayidx29, align 4, !dbg !133, !tbaa !113 to   store float %9, ptr %arrayidx29, align 4, !dbg !137, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113 to   %7 = load float, ptr %arrayidx29, align 4, !dbg !133, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113 to   store float %9, ptr %arrayidx29, align 4, !dbg !137, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113 to   store float %9, ptr %arrayidx29, align 4, !dbg !137, !tbaa !113: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113 to   store float %6, ptr %arrayidx27, align 4, !dbg !130, !tbaa !113: 0
Total Dependences: 9
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1279: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ed40810, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652ed3e8e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ed6b650, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)
  AliasSet[0x55652ed6e400, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652ed6cef0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !124 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125 (read)
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !124
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2710: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 6 pointer values.
  AliasSet[0x55652ed8d320, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ed940c0, 2] may alias, No access Pointers: (ptr %arrayidx46, unknown before-or-after), (ptr %arrayidx20, unknown before-or-after)
  AliasSet[0x55652ed93e60, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ed97250, 1] must alias, No access Pointers: (ptr %arrayidx24, unknown before-or-after)
  AliasSet[0x55652eda4ac0, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)

LAA:   Accesses(10):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx46 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !152 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113 (write)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !132 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx46 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !152 (read)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129 (read-only)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !132 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx46 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !152
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx46 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !152
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !132
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !132
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx46 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !152
LAA: Found a runtime check ptr:  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !132
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %16 = load float, ptr %arrayidx20, align 4, !dbg !135, !tbaa !114 to   store float %17, ptr %arrayidx20, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %21, ptr %arrayidx46, align 4, !dbg !154, !tbaa !114 to   %16 = load float, ptr %arrayidx20, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %20 = load float, ptr %arrayidx46, align 4, !dbg !154, !tbaa !114 to   store float %17, ptr %arrayidx20, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %21, ptr %arrayidx46, align 4, !dbg !154, !tbaa !114 to   store float %17, ptr %arrayidx20, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5>Sink Scev: {@c,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %20 = load float, ptr %arrayidx46, align 4, !dbg !154, !tbaa !114 to   store float %21, ptr %arrayidx46, align 4, !dbg !154, !tbaa !114: 0
Total Dependences: 5
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2710: for.body5.us.us
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 7 pointer values.
  AliasSet[0x55652eda9550, 1] must alias, No access Pointers: (ptr %arrayidx7.us.us, unknown before-or-after)
  AliasSet[0x55652ed984c0, 2] may alias, No access Pointers: (ptr %arrayidx39.us.us, unknown before-or-after), (ptr %arrayidx20.us.us, unknown before-or-after)
  AliasSet[0x55652ed974e0, 1] must alias, No access Pointers: (ptr %arrayidx.us.us, unknown before-or-after)
  AliasSet[0x55652edbf4e0, 1] must alias, No access Pointers: (ptr %arrayidx24.us.us, unknown before-or-after)
  AliasSet[0x55652edb7590, 2] may alias, No access Pointers: (ptr %arrayidx35.us.us, unknown before-or-after), (ptr %arrayidx12.us.us, unknown before-or-after)

LAA:   Accesses(10):
	  %arrayidx7.us.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv83, !dbg !116 (write)
	  %arrayidx39.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !126 (write)
	  %arrayidx.us.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv83, !dbg !113 (write)
	  %arrayidx20.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !132 (write)
	  %arrayidx.us.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv83, !dbg !113 (read)
	  %arrayidx7.us.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv83, !dbg !116 (read)
	  %arrayidx24.us.us = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv83, !dbg !119 (read-only)
	  %arrayidx35.us.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv83, !dbg !122 (read-only)
	  %arrayidx12.us.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv83, !dbg !129 (read-only)
	  %arrayidx20.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !132 (read)
Underlying objects for pointer   %arrayidx7.us.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv83, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7.us.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv83, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx39.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !126
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx20.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !132
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx20.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !132
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx.us.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv83, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx.us.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv83, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24.us.us = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv83, !dbg !119
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx35.us.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv83, !dbg !122
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx12.us.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv83, !dbg !129
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: Found a runtime check ptr:  %arrayidx39.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !126
LAA: Found a runtime check ptr:  %arrayidx20.us.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv83, !dbg !132
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@c,+,4}<nw><%for.body5.us.us>Sink Scev: {@c,+,4}<nw><%for.body5.us.us>(Induction step: 1)
LAA: Distance for   %10 = load float, ptr %arrayidx20.us.us, align 4, !dbg !135, !tbaa !114 to   store float %11, ptr %arrayidx20.us.us, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5.us.us>Sink Scev: {@c,+,4}<nw><%for.body5.us.us>(Induction step: 1)
LAA: Distance for   store float %7, ptr %arrayidx39.us.us, align 4, !dbg !127, !tbaa !114 to   %10 = load float, ptr %arrayidx20.us.us, align 4, !dbg !135, !tbaa !114: 0
LAA: Src Scev: {@c,+,4}<nw><%for.body5.us.us>Sink Scev: {@c,+,4}<nw><%for.body5.us.us>(Induction step: 1)
LAA: Distance for   store float %7, ptr %arrayidx39.us.us, align 4, !dbg !127, !tbaa !114 to   store float %11, ptr %arrayidx20.us.us, align 4, !dbg !135, !tbaa !114: 0
Total Dependences: 3
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2711: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652edb4f00, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652edb65e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652edec540, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (read)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2712: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652edf1530, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652edefb50, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ee0f780, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !118
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s281: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 4 pointer values.
  AliasSet[0x55652ee10ef0, 2] may alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after), (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ee31c30, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)
  AliasSet[0x55652ee370e0, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !111 (read-only)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !111
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !117
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Found a runtime check ptr:  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %0, !dbg !111
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(127996 + @a),+,-4}<%for.body5>(Induction step: 1)
LAA: Distance for   store float %sub11, ptr %arrayidx13, align 4, !dbg !121, !tbaa !112 to   %1 = load float, ptr %arrayidx, align 4, !dbg !111, !tbaa !112: {127996,+,-8}<%for.body5>
Pointer access with non-constant stride
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s1281: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ee36ea0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ee60440, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652ee68510, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652ee645b0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652ee61ef0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (read)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !117
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s291: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ee64900, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652ee85920, 2] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s292: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 3 pointer values.
  AliasSet[0x55652ee8d630, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652eea7520, 2] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !117 (read-only)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !121
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !116
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
op can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s276

Loop at line number: 1829
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s277

Loop at line number: 1854
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 3
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s278

Loop at line number: 1886
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s279

Loop at line number: 1916
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 3
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s1279

Loop at line number: 1948
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 3
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s2710

Loop at line number: 1977
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s2710

Loop at line number: 1977
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s2711

Loop at line number: 2013
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s2712

Loop at line number: 2037
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s281

Loop at line number: 2063
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1281

Loop at line number: 2087
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s291

Loop at line number: 2113
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s292

Loop at line number: 2140
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC LAA: Found a loop in s293: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 2 pointer values.
  AliasSet[0x55652eeac440, 2] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr @a, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (write)
	@a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
LAA: Found a runtime check ptr:@a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Bad stride - Not an AddRecExpr pointer @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23 SCEV: @a
LAA: Src Scev: @aSink Scev: {@a,+,4}<nuw><%for.body5>(Induction step: 0)
LAA: Distance for   %0 = load float, ptr @a, align 64, !dbg !107, !tbaa !110 to   store float %0, ptr %arrayidx, align 4, !dbg !115, !tbaa !110: {0,+,4}<nuw><nsw><%for.body5>
Pointer access with non-constant stride
Total Dependences: 1
LAA: unsafe dependent memory operations in loop
LAA: Found a loop in s2101: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652eea8c40, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)
  AliasSet[0x55652eed45a0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eed5b80, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx7 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !115 (read-only)
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !115
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !115
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !107
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @cc, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !114
  @cc = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !38
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Non unit strided pointer which is not either inbounds or in address space 0 may wrap:
LAA:   Pointer:   %arrayidx15 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv, !dbg !115
LAA:   SCEV: {@aa,+,1028}<%for.body5>
LAA:   Added an overflow assumption
LAA: Src Scev: {@aa,+,1028}<%for.body5>Sink Scev: {@aa,+,1028}<%for.body5>(Induction step: 257)
LAA: Distance for   %2 = load float, ptr %arrayidx15, align 4, !dbg !116, !tbaa !110 to   store float %3, ptr %arrayidx15, align 4, !dbg !116, !tbaa !110: 0
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s2102: for.body9
LAA: Found a write-only loop!
LAA: Found a loop in s2111: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 2 pointer values.
  AliasSet[0x55652eef9cc0, 2] may alias, No access Pointers: (ptr %arrayidx21, unknown before-or-after), (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx21 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !128 (write)
	  %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !128
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !124
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
LAA: Found a runtime check ptr:  %arrayidx21 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv46, i64 %indvars.iv, !dbg !128
LAA: Found a runtime check ptr:  %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %0, i64 %indvars.iv, !dbg !124
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {{(4 + @aa)<nuw><nsw>,+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>Sink Scev: {{(1028 + @aa),+,1024}<nuw><%for.cond6.preheader>,+,4}<nuw><%for.body9>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx16, align 4, !dbg !124, !tbaa !108 to   store float %conv17, ptr %arrayidx21, align 4, !dbg !129, !tbaa !108: 1024
LAA: Positive distance 1024 with max VF = 256
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s311: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in test: for.body
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i36
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i44
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i52
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i60
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i68
LAA: Found a read-only loop!
LAA: Found a loop in s31111: for.body.i76
LAA: Found a read-only loop!
can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s293

Loop at line number: 2164
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2101

Loop at line number: 2187
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2102

Loop at line number: 2210
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s2111

Loop at line number: 2234
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s311

Loop at line number: 2265
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  test

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can LAA: Found a loop in s31111: for.body.i84
LAA: Found a read-only loop!
LAA: Found a loop in s312: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s313: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s314: for.body5.for.body5_crit_edge
LAA: Found a read-only loop!
LAA: Found a loop in s315: for.body
LAA: Found a write-only loop!
LAA: Found a loop in s315: for.body12.for.body12_crit_edge
LAA: Found a read-only loop!
LAA: Found a loop in s316: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s317: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s318: for.body5
LAA: Found a strided access that is a candidate for versioning:  Ptr:   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133 Stride:   %2 = sext i32 %1 to i64, !dbg !112
LAA: Found a strided access that we can version.
LAA: Found a read-only loop!
LAA: Found a loop in s319: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652ef94c80, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652efa9be0, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652efa8980, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652efa7280, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652efa6d40, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !110 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !110
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s3110: for.body9
LAA: Found a read-only loop!
LAA: Found a loop in s13110: for.body9
LAA: Found a read-only loop!
LAA: Found a loop in s3111: for.body5
LAA: Found a read-only loop!
NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s31111

Loop at line number: 2277
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s312

Loop at line number: 2323
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s313

Loop at line number: 2346
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s314

Implicit code, Line number nit available 
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s315

Loop at line number: 2393
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s315

Implicit code, Line number nit available 
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s316

Loop at line number: 2429
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s317

Loop at line number: 2456
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s318

Loop at line number: 2487
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s319

Loop at line number: 2518
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s3110

Loop at line number: 2550
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s13110

Loop at line number: 2582
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s3111

Loop at line number: 2612
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorLAA: Found a loop in s3112: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652efe24b0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652eff6370, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s3113: for.body5.for.body5_crit_edge
LAA: Found a read-only loop!
LAA: Found a loop in s321: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f010b80, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f00dd80, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s322: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 4 pointer values.
  AliasSet[0x55652f00d360, 2] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652f00cec0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f01bf00, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (read)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !118 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !115
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !118
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx12, align 4, !dbg !118, !tbaa !98 to   store float %7, ptr %arrayidx, align 4, !dbg !121, !tbaa !98: 8
LAA: Positive distance 8 with max VF = 2
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx, align 4, !dbg !114, !tbaa !98 to   store float %7, ptr %arrayidx, align 4, !dbg !121, !tbaa !98: 0
Total Dependences: 2
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s323: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652f01ade0, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652f02aa50, 1] must alias, No access Pointers: (ptr %arrayidx19, unknown before-or-after)
  AliasSet[0x55652f02dd50, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f02bf50, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f02bab0, 1] must alias, No access Pointers: (ptr %arrayidx17, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121 (write)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx17 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx17 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !119
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s331: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s332: for.body5
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s341: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f03d970, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652f068e50, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom9, !dbg !120 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom9, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s342: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f068a40, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f067010, 1] must alias, No access Pointers: (ptr %arrayidx8, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108 (read)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom7, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !108
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom7, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s343: for.body9
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f080650, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)
  AliasSet[0x55652f07e630, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652f07e3b0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx18 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom17, !dbg !132 (write)
	  %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !119 (read-only)
	  %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !131 (read-only)
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %idxprom17, !dbg !132
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [256 x [256 x float]], ptr @bb, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !119
  @bb = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !36
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [256 x [256 x float]], ptr @aa, i64 0, i64 %indvars.iv, i64 %indvars.iv44, !dbg !131
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s351: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 10 pointer values.
  AliasSet[0x55652f07f270, 5] may alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after), (ptr %arrayidx18, unknown before-or-after), (ptr %arrayidx24, unknown before-or-after), (ptr %arrayidx30, unknown before-or-after)
  AliasSet[0x55652f08e9e0, 5] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx15, unknown before-or-after), (ptr %arrayidx21, unknown before-or-after), (ptr %arrayidx27, unknown before-or-after)

LAA:   Accesses(15):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !120 (write)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %8, !dbg !124 (write)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %12, !dbg !128 (write)
	  %arrayidx30 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !132 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (read)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %4, !dbg !119 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !120 (read)
	  %arrayidx15 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %8, !dbg !123 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %8, !dbg !124 (read)
	  %arrayidx21 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %12, !dbg !127 (read-only)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %12, !dbg !128 (read)
	  %arrayidx27 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %16, !dbg !131 (read-only)
	  %arrayidx30 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !132 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %8, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %8, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %12, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %12, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx30 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !132
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx30 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !132
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !113
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %4, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %8, !dbg !123
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %12, !dbg !127
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx27 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %16, !dbg !131
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %4, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %8, !dbg !124
LAA: Found a runtime check ptr:  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %12, !dbg !128
LAA: Found a runtime check ptr:  %arrayidx30 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !132
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %18 = load float, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 0
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94 to   %18 = load float, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   %18 = load float, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   %18 = load float, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   %18 = load float, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %14 = load float, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %10 = load float, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 16
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %19, ptr %arrayidx30, align 4, !dbg !133, !tbaa !94: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %14 = load float, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 0
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   %14 = load float, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   %14 = load float, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   %14 = load float, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %10 = load float, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %15, ptr %arrayidx24, align 4, !dbg !129, !tbaa !94: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %10 = load float, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94 to   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 0
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   %10 = load float, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   %10 = load float, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %11, ptr %arrayidx18, align 4, !dbg !125, !tbaa !94: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %6 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94 to   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94: 0
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   %6 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %7, ptr %arrayidx12, align 4, !dbg !121, !tbaa !94: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {@a,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %2 = load float, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94 to   store float %3, ptr %arrayidx7, align 4, !dbg !117, !tbaa !94: 0
Total Dependences: 5
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s1351: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f07d070, 1] must alias, No access Pointers: (ptr %A.020, unknown before-or-after)
  AliasSet[0x55652f09c5d0, 1] must alias, No access Pointers: (ptr %B.021, unknown before-or-after)
  AliasSet[0x55652f09e7d0, 1] must alias, No access Pointers: (ptr %C.022, unknown before-or-after)

LAA:   Accesses(3):
	  %A.020 = phi ptr [ @a, %for.cond2.preheader ], [ %incdec.ptr, %for.body5 ] (write)
	  %B.021 = phi ptr [ @b, %for.cond2.preheader ], [ %incdec.ptr6, %for.body5 ] (read-only)
	  %C.022 = phi ptr [ @c, %for.cond2.preheader ], [ %incdec.ptr7, %for.body5 ] (read-only)
Underlying objects for pointer   %A.020 = phi ptr [ @a, %for.cond2.preheader ], [ %incdec.ptr, %for.body5 ]
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %B.021 = phi ptr [ @b, %for.cond2.preheader ], [ %incdec.ptr6, %for.body5 ]
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %C.022 = phi ptr [ @c, %for.cond2.preheader ], [ %incdec.ptr7, %for.body5 ]
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s352: for.body5
LAA: Found a read-only loop!
ized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s3112

Loop at line number: 2638
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s3113

Implicit code, Line number nit available 
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s321

Loop at line number: 2687
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s322

Loop at line number: 2709
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s323

Loop at line number: 2731
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s331

Loop at line number: 2757
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s332

Loop at line number: 2789
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s341

Loop at line number: 2820
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s342

Loop at line number: 2848
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s343

Loop at line number: 2877
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 2
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s351

Loop at line number: 2904
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1351

Loop at line number: 2930
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s352

Loop at line number: 2957
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized LAA: Found a loop in s353: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 15 pointer values.
  AliasSet[0x55652f0b6110, 5] may alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx16, unknown before-or-after), (ptr %arrayidx24, unknown before-or-after), (ptr %arrayidx32, unknown before-or-after), (ptr %arrayidx40, unknown before-or-after)
  AliasSet[0x55652f0b37e0, 5] may alias, No access Pointers: (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx11, unknown before-or-after), (ptr %arrayidx19, unknown before-or-after), (ptr %arrayidx27, unknown before-or-after), (ptr %arrayidx35, unknown before-or-after)
  AliasSet[0x55652f0ba540, 5] may alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after), (ptr %arrayidx13, unknown before-or-after), (ptr %arrayidx21, unknown before-or-after), (ptr %arrayidx29, unknown before-or-after), (ptr %arrayidx37, unknown before-or-after)

LAA:   Accesses(20):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127 (write)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %6, !dbg !132 (write)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %11, !dbg !137 (write)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !142 (write)
	  %arrayidx40 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %21, !dbg !147 (write)
	  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !126 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127 (read)
	  %arrayidx11 = getelementptr inbounds i32, ptr %0, i64 %6, !dbg !130 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom12, !dbg !131 (read-only)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %6, !dbg !132 (read)
	  %arrayidx19 = getelementptr inbounds i32, ptr %0, i64 %11, !dbg !135 (read-only)
	  %arrayidx21 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom20, !dbg !136 (read-only)
	  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %11, !dbg !137 (read)
	  %arrayidx27 = getelementptr inbounds i32, ptr %0, i64 %16, !dbg !140 (read-only)
	  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom28, !dbg !141 (read-only)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !142 (read)
	  %arrayidx35 = getelementptr inbounds i32, ptr %0, i64 %21, !dbg !145 (read-only)
	  %arrayidx37 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom36, !dbg !146 (read-only)
	  %arrayidx40 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %21, !dbg !147 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %6, !dbg !132
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %6, !dbg !132
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %11, !dbg !137
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %11, !dbg !137
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !142
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !142
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx40 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %21, !dbg !147
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx40 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %21, !dbg !147
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !121
    %0 = load ptr, ptr %arg_info, align 8, !dbg !93, !tbaa !94
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds i32, ptr %0, i64 %6, !dbg !130
    %0 = load ptr, ptr %arg_info, align 8, !dbg !93, !tbaa !94
Underlying objects for pointer   %arrayidx19 = getelementptr inbounds i32, ptr %0, i64 %11, !dbg !135
    %0 = load ptr, ptr %arg_info, align 8, !dbg !93, !tbaa !94
Underlying objects for pointer   %arrayidx27 = getelementptr inbounds i32, ptr %0, i64 %16, !dbg !140
    %0 = load ptr, ptr %arg_info, align 8, !dbg !93, !tbaa !94
Underlying objects for pointer   %arrayidx35 = getelementptr inbounds i32, ptr %0, i64 %21, !dbg !145
    %0 = load ptr, ptr %arg_info, align 8, !dbg !93, !tbaa !94
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !126
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom12, !dbg !131
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx21 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom20, !dbg !136
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom28, !dbg !141
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx37 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom36, !dbg !146
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !127
LAA: Found a runtime check ptr:  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %6, !dbg !132
LAA: Found a runtime check ptr:  %arrayidx24 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %11, !dbg !137
LAA: Found a runtime check ptr:  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %16, !dbg !142
LAA: Found a runtime check ptr:  %arrayidx40 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %21, !dbg !147
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %24 = load float, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 0
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104 to   %24 = load float, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   %24 = load float, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   %24 = load float, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   %24 = load float, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %19 = load float, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %14 = load float, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %9 = load float, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 16
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(16 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %25, ptr %arrayidx40, align 4, !dbg !148, !tbaa !104: 16
LAA: Strided accesses are independent
LAA: Src Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %19 = load float, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 0
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   %19 = load float, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   %19 = load float, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   %19 = load float, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %14 = load float, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %9 = load float, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(12 + @a)<nuw><nsw>,+,20}<nw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %20, ptr %arrayidx32, align 4, !dbg !143, !tbaa !104: 12
LAA: Strided accesses are independent
LAA: Src Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %14 = load float, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104 to   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 0
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   %14 = load float, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   %14 = load float, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %9 = load float, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(8 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %15, ptr %arrayidx24, align 4, !dbg !138, !tbaa !104: 8
LAA: Strided accesses are independent
LAA: Src Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %9 = load float, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104 to   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104: 0
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   %9 = load float, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {(4 + @a)<nuw><nsw>,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %10, ptr %arrayidx16, align 4, !dbg !133, !tbaa !104: 4
LAA: Strided accesses are independent
LAA: Src Scev: {@a,+,20}<nuw><%for.body5>Sink Scev: {@a,+,20}<nuw><%for.body5>(Induction step: 5)
LAA: Distance for   %4 = load float, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104 to   store float %5, ptr %arrayidx9, align 4, !dbg !128, !tbaa !104: 0
Total Dependences: 5
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s421: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652f0bc460, 3] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !122 (write)
	  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !117 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !122
    %.pre = load ptr, ptr @xx, align 8, !dbg !103, !tbaa !93
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !117
    %.pre = load ptr, ptr @xx, align 8, !dbg !103, !tbaa !93
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !122
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !117
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
LAA: We need to do 1 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(4 + %0)<nuw>,+,4}<nuw><%for.body5>Sink Scev: {%0,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx, align 4, !dbg !117, !tbaa !118 to   store float %add8, ptr %arrayidx10, align 4, !dbg !123, !tbaa !118: -4
LAA: Dependence is negative
Total Dependences: 1
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s1421: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652f0bba40, 3] may alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !112 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !112
    %.pre = load ptr, ptr @xx, align 8, !tbaa !93
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !112
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
LAA: We need to do 1 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {%0,+,4}<nuw><%for.body5>Sink Scev: {@b,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %1 = load float, ptr %arrayidx, align 4, !dbg !112, !tbaa !115 to   store float %add, ptr %arrayidx9, align 4, !dbg !120, !tbaa !115: ***COULDNOTCOMPUTE***
LAA: Dependence because of non-constant distance
Total Dependences: 1
LAA: Retrying with memory checks
LAA: Found a runtime check ptr:  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !112
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
LAA: We need to do 2 pointer comparisons.
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s422: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652f0e6160, 3] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %1, !dbg !115 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !120
    %.pre = load ptr, ptr @xx, align 8, !tbaa !93
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %1, !dbg !115
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %1, !dbg !115
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: We need to do 1 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {(32 + @flat_2d_array)<nuw><nsw>,+,4}<nuw><%for.body5>Sink Scev: {%0,+,4}<nuw><%for.body5>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx, align 4, !dbg !115, !tbaa !116 to   store float %add8, ptr %arrayidx10, align 4, !dbg !121, !tbaa !116: ***COULDNOTCOMPUTE***
LAA: Dependence because of non-constant distance
Total Dependences: 1
LAA: Retrying with memory checks
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !120
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %1, !dbg !115
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: We need to do 2 pointer comparisons.
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s423: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652f0f4370, 3] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv.next, !dbg !121 (write)
	  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv.next, !dbg !121
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !113
    %0 = load ptr, ptr @xx, align 8, !tbaa !92
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv.next, !dbg !121
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds float, ptr %0, i64 %indvars.iv, !dbg !113
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: We need to do 2 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s424: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 1 alias sets for 3 pointer values.
  AliasSet[0x55652f0f34b0, 3] may alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after), (ptr %arrayidx, unknown before-or-after), (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !121 (write)
	  %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !121
    %0 = load ptr, ptr @xx, align 8, !tbaa !92
Underlying objects for pointer   %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv, !dbg !113
  @flat_2d_array = dso_local global [65536 x float] zeroinitializer, align 64, !dbg !13
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
LAA: Found a runtime check ptr:  %arrayidx10 = getelementptr inbounds float, ptr %0, i64 %indvars.iv.next, !dbg !121
LAA: Found a runtime check ptr:  %arrayidx = getelementptr inbounds [65536 x float], ptr @flat_2d_array, i64 0, i64 %indvars.iv, !dbg !113
LAA: Found a runtime check ptr:  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
LAA: We need to do 2 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
Total Dependences: 0
LAA: No unsafe dependent memory operations in loop.  We need runtime memory checks.
LAA: Found a loop in s431: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f10f110, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f10e9f0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !110
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s441: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 8 pointer values.
  AliasSet[0x55652f10e6a0, 3] may alias, No access Pointers: (ptr %arrayidx29, unknown before-or-after), (ptr %arrayidx22, unknown before-or-after), (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652f1273a0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f1249a0, 2] may alias, No access Pointers: (ptr %arrayidx25, unknown before-or-after), (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652f123d60, 2] may alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after), (ptr %arrayidx8, unknown before-or-after)

LAA:   Accesses(11):
	  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133 (write)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !128 (write)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx25 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !131 (read-only)
	  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133 (read)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !126 (read-only)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !128 (read)
	  %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120 (read)
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx29 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !107
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx25 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !131
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !126
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx8 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx29 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !133
LAA: Found a runtime check ptr:  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !128
LAA: Found a runtime check ptr:  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !120
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %3 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111 to   store float %4, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %7, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111 to   %3 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %10, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   %3 = load float, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %6 = load float, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111 to   store float %4, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %7, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111 to   store float %4, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %9 = load float, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   store float %4, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %10, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   store float %4, ptr %arrayidx12, align 4, !dbg !121, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %6 = load float, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111 to   store float %7, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %10, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   %6 = load float, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %9 = load float, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   store float %7, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %10, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   store float %7, ptr %arrayidx22, align 4, !dbg !129, !tbaa !111: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %9 = load float, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111 to   store float %10, ptr %arrayidx29, align 4, !dbg !134, !tbaa !111: 0
Total Dependences: 12
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s442: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 6 alias sets for 9 pointer values.
  AliasSet[0x55652f128c20, 4] may alias, No access Pointers: (ptr %arrayidx26, unknown before-or-after), (ptr %arrayidx20, unknown before-or-after), (ptr %arrayidx32, unknown before-or-after), (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652f139550, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f138e30, 1] must alias, No access Pointers: (ptr %arrayidx22, unknown before-or-after)
  AliasSet[0x55652f13b2f0, 1] must alias, No access Pointers: (ptr %arrayidx16, unknown before-or-after)
  AliasSet[0x55652f13e900, 1] must alias, No access Pointers: (ptr %arrayidx28, unknown before-or-after)
  AliasSet[0x55652f13d5e0, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)

LAA:   Accesses(13):
	  %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !134 (write)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !129 (write)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !139 (write)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (write)
	  %arrayidx = getelementptr inbounds [32000 x i32], ptr @indx, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx22 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !133 (read-only)
	  %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !134 (read)
	  %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128 (read-only)
	  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !129 (read)
	  %arrayidx28 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !138 (read-only)
	  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !139 (read)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (read)
Underlying objects for pointer   %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !134
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !134
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !129
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !129
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !139
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !139
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x i32], ptr @indx, i64 0, i64 %indvars.iv, !dbg !114
  @indx = dso_local local_unnamed_addr global [32000 x i32] zeroinitializer, align 64, !dbg !42
Underlying objects for pointer   %arrayidx22 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !133
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx16 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !128
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx28 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !138
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !121
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: Found a runtime check ptr:  %arrayidx26 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !134
LAA: Found a runtime check ptr:  %arrayidx20 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !129
LAA: Found a runtime check ptr:  %arrayidx32 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !139
LAA: Found a runtime check ptr:  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
LAA: We need to do 0 pointer comparisons.
LAA: May be able to perform a memory runtime check if needed.
LAA: Checking memory dependencies
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %2 = load float, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122 to   %2 = load float, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   %2 = load float, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   %2 = load float, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %11 = load float, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %8 = load float, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %3, ptr %arrayidx14, align 4, !dbg !125, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %11 = load float, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122 to   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   %11 = load float, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   %11 = load float, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %8 = load float, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %12, ptr %arrayidx32, align 4, !dbg !140, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %5 = load float, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122 to   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   %5 = load float, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %8 = load float, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %6, ptr %arrayidx20, align 4, !dbg !130, !tbaa !122: 0
LAA: Src Scev: {@a,+,4}<nw><%for.body5>Sink Scev: {@a,+,4}<nw><%for.body5>(Induction step: 1)
LAA: Distance for   %8 = load float, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122 to   store float %9, ptr %arrayidx26, align 4, !dbg !135, !tbaa !122: 0
Total Dependences: 22
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s443: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652f138ae0, 1] must alias, No access Pointers: (ptr %arrayidx12, unknown before-or-after)
  AliasSet[0x55652f13b620, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f14abb0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652f14e8c0, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !112 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
	  %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119 (read)
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx12 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !119
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !112
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s451: for.body5
LAA: Found a loop in s452: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f14d390, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f164330, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f163fa0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s453: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f161450, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f160200, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111 (read-only)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !111
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.

ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s353

Loop at line number: 2985
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s421

Loop at line number: 3021
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s1421

Loop at line number: 3043
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s422

Loop at line number: 3068
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s423

Loop at line number: 3094
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s424

Loop at line number: 3121
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s431

Loop at line number: 3147
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s441

Loop at line number: 3169
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 3
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s442

Loop at line number: 3197
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 4
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s443

Loop at line number: 3237
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  s451

Loop at line number: 3270
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s452

Loop at line number: 3292
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s453

Loop at line number: 3316
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOTLAA: Found a loop in s471: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652f160480, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652f17fed0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f17e8b0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f17cab0, 1] must alias, No access Pointers: (ptr %arrayidx14, unknown before-or-after)
  AliasSet[0x55652f17c610, 1] must alias, No access Pointers: (ptr %arrayidx18, unknown before-or-after)

LAA:   Accesses(6):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @x, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115 (read-only)
	  %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx18 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @x, i64 0, i64 %indvars.iv, !dbg !117
  @x = dso_local local_unnamed_addr global [32000 x float] zeroinitializer, align 64, !dbg !18
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !108
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !115
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx14 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !119
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx18 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !120
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s481: for.body5
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s482: for.body5
LAA: SCEV could not compute the loop exit count.
LAA: Found a loop in s491: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652f19c8e0, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652f1a1370, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f1a0f60, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f19e560, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f1a2490, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom12, !dbg !128 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !123 (read-only)
	  %arrayidx11 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom12, !dbg !128
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !122
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !123
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !125
    %0 = load ptr, ptr %arg_info, align 8, !dbg !92, !tbaa !93
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s4112: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f1a36a0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f1a27e0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f1ad920, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !137 (write)
	  %arrayidx = getelementptr inbounds i32, ptr %1, i64 %indvars.iv, !dbg !130 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !135 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !137 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !137
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !137
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds i32, ptr %1, i64 %indvars.iv, !dbg !130
    %1 = load ptr, ptr %0, align 8, !dbg !107, !tbaa !108
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !135
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s4113: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652f1b0860, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652f1aed00, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f1baae0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f1bcce0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom6, !dbg !127 (write)
	  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !122 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125 (read-only)
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom6, !dbg !127
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !117
    %0 = load ptr, ptr %arg_info, align 8, !dbg !92, !tbaa !93
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !125
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s4114: for.body
LAA: Found a loop in s4114: for.body5.us
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 5 alias sets for 5 pointer values.
  AliasSet[0x55652f1badc0, 1] must alias, No access Pointers: (ptr %arrayidx15.us, unknown before-or-after)
  AliasSet[0x55652f1caea0, 1] must alias, No access Pointers: (ptr %arrayidx.us, unknown before-or-after)
  AliasSet[0x55652f1cad70, 1] must alias, No access Pointers: (ptr %arrayidx7.us, unknown before-or-after)
  AliasSet[0x55652f1c9340, 1] must alias, No access Pointers: (ptr %arrayidx11.us, unknown before-or-after)
  AliasSet[0x55652f1c7540, 1] must alias, No access Pointers: (ptr %arrayidx13.us, unknown before-or-after)

LAA:   Accesses(5):
	  %arrayidx15.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !131 (write)
	  %arrayidx.us = getelementptr inbounds i32, ptr %1, i64 %indvars.iv, !dbg !120 (read-only)
	  %arrayidx7.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !124 (read-only)
	  %arrayidx11.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %idxprom10.us, !dbg !128 (read-only)
	  %arrayidx13.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129 (read-only)
Underlying objects for pointer   %arrayidx15.us = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !131
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx.us = getelementptr inbounds i32, ptr %1, i64 %indvars.iv, !dbg !120
    %1 = load ptr, ptr %0, align 8, !dbg !108, !tbaa !109
Underlying objects for pointer   %arrayidx7.us = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !124
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx11.us = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %idxprom10.us, !dbg !128
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx13.us = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !129
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s4115: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s4116: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in s4117: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 4 alias sets for 4 pointer values.
  AliasSet[0x55652f1e2980, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652f1f1ac0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f1f5180, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f1f4a00, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %idxprom6, !dbg !115 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !118
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %idxprom6, !dbg !115
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !116
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in s4121: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f1e0b80, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652f1f2ea0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f206c20, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (read)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in va: for.cond2.preheader
 be applied 

----------------------------------------------------------------------------------------- 

Function:  s471

Loop at line number: 3345
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s481

Loop at line number: 3369
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s482

Loop at line number: 3395
Loop doesn't contain function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s491

Loop at line number: 3422
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4112

Loop at line number: 3450
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4113

Loop at line number: 3476
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4114

Loop at line number: 3509
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4114

Loop at line number: 3505
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4115

Loop at line number: 3535
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4116

Loop at line number: 3567
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4117

Loop at line number: 3590
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  s4121

Loop at line number: 3616
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  va

Loop at line number: 3638
Loop contains function call
Loop contains memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

LAA: Found a loop in vag: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f208a20, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f224b00, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f224820, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !125 (write)
	  %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !125
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !117
    %0 = load ptr, ptr %arg_info, align 8, !dbg !92, !tbaa !93
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %idxprom6, !dbg !122
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vas: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f2242e0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f220ec0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f22c6e0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom8, !dbg !125 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117 (read-only)
	  %arrayidx7 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !122 (read-only)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %idxprom8, !dbg !125
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !117
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds i32, ptr %0, i64 %indvars.iv, !dbg !122
    %0 = load ptr, ptr %arg_info, align 8, !dbg !92, !tbaa !93
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vif: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f22e920, 1] must alias, No access Pointers: (ptr %arrayidx10, unknown before-or-after)
  AliasSet[0x55652f22c9b0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(2):
	  %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
Underlying objects for pointer   %arrayidx10 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !117
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vpv: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f22ee60, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f248210, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vtv: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f245400, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652f244540, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114 (read)
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !114
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vpvtv: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f2447c0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f25ea70, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f25e720, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !115
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vpvts: for.body7
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 2 alias sets for 2 pointer values.
  AliasSet[0x55652f25d730, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f25bbd0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)

LAA:   Accesses(3):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !124
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !119
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vpvpv: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f25da10, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652f274280, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f274000, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116 (read)
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !116
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !107
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !114
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vtvtv: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 3 alias sets for 3 pointer values.
  AliasSet[0x55652f2716b0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652f270de0, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e944830, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)

LAA:   Accesses(4):
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107 (read)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116 (read-only)
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !107
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !114
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !116
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
LAA: Found a loop in vsumr: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in vdotr: for.body5
LAA: Found a read-only loop!
LAA: Found a loop in vbor: for.body5
LAA: Processing memory accesses...
  AST: Alias Set Tracker: 7 alias sets for 7 pointer values.
  AliasSet[0x55652e9b0cc0, 1] must alias, No access Pointers: (ptr %arrayidx59, unknown before-or-after)
  AliasSet[0x55652e9aa7b0, 1] must alias, No access Pointers: (ptr %arrayidx, unknown before-or-after)
  AliasSet[0x55652e9da920, 1] must alias, No access Pointers: (ptr %arrayidx7, unknown before-or-after)
  AliasSet[0x55652e9e6fc0, 1] must alias, No access Pointers: (ptr %arrayidx9, unknown before-or-after)
  AliasSet[0x55652e9e3b70, 1] must alias, No access Pointers: (ptr %arrayidx11, unknown before-or-after)
  AliasSet[0x55652e9d8780, 1] must alias, No access Pointers: (ptr %arrayidx13, unknown before-or-after)
  AliasSet[0x55652e9ebcf0, 1] must alias, No access Pointers: (ptr %arrayidx15, unknown before-or-after)

LAA:   Accesses(7):
	  %arrayidx59 = getelementptr inbounds [32000 x float], ptr @x, i64 0, i64 %indvars.iv, !dbg !158 (write)
	  %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113 (read-only)
	  %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120 (read-only)
	  %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !121 (read-only)
	  %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122 (read-only)
	  %arrayidx13 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !123 (read-only)
	  %arrayidx15 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !124 (read-only)
Underlying objects for pointer   %arrayidx59 = getelementptr inbounds [32000 x float], ptr @x, i64 0, i64 %indvars.iv, !dbg !158
  @x = dso_local local_unnamed_addr global [32000 x float] zeroinitializer, align 64, !dbg !18
Underlying objects for pointer   %arrayidx = getelementptr inbounds [32000 x float], ptr @a, i64 0, i64 %indvars.iv, !dbg !113
  @a = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !23
Underlying objects for pointer   %arrayidx7 = getelementptr inbounds [32000 x float], ptr @b, i64 0, i64 %indvars.iv, !dbg !120
  @b = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !0
Underlying objects for pointer   %arrayidx9 = getelementptr inbounds [32000 x float], ptr @c, i64 0, i64 %indvars.iv, !dbg !121
  @c = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !25
Underlying objects for pointer   %arrayidx11 = getelementptr inbounds [32000 x float], ptr @d, i64 0, i64 %indvars.iv, !dbg !122
  @d = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !27
Underlying objects for pointer   %arrayidx13 = getelementptr inbounds [32000 x float], ptr @e, i64 0, i64 %indvars.iv, !dbg !123
  @e = dso_local global [32000 x float] zeroinitializer, align 64, !dbg !29
Underlying objects for pointer   %arrayidx15 = getelementptr inbounds [256 x float], ptr @aa, i64 0, i64 %indvars.iv, !dbg !124
  @aa = dso_local global [256 x [256 x float]] zeroinitializer, align 64, !dbg !31
LAA: May be able to perform a memory runtime check if needed.
LAA: No unsafe dependent memory operations in loop.  We don't need runtime memory checks.
----------------------------------------------------------------------------------------- 

Function:  vag

Loop at line number: 3664
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vas

Loop at line number: 3690
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vif

Loop at line number: 3712
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 2
Loop can be vectorized 
ALC can be applied 

----------------------------------------------------------------------------------------- 

Function:  vpv

Loop at line number: 3736
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vtv

Loop at line number: 3758
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vpvtv

Loop at line number: 3780
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vpvts

Loop at line number: 3805
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vpvpv

Loop at line number: 3827
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vtvtv

Loop at line number: 3849
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vsumr

Loop at line number: 3873
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vdotr

Loop at line number: 3897
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop contains output dependency
Number of paths: 1
Loop can NOT be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 

Function:  vbor

Loop at line number: 3921
Loop doesn't contain function call
Loop doesn't contain memory dependency
Loop doesn't contain output dependency
Number of paths: 1
Loop can be vectorized 
ALC can NOT be applied 

----------------------------------------------------------------------------------------- 
