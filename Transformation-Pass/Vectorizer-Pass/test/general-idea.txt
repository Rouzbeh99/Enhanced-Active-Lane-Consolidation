inner loop:

        for (int i = 0; i < LEN_1D; i++) {
            if (a[i] > b[i]) {
                s = a[i] - b[i] * d[i];
                c[i] += s;
                a[i] = s;
            }
        }

--------------------------------------------------------------------------------------
pseudo code:


    pre.alc block:
         form first iteration vec with step vector
         form second iteration vec
         form predicates for first iteration vec
         form predicates for second iteration vec


    alc.header:
        keep tracks of phi nodes for edges coming from pre.alc and latch
        There are 5 phi nodes, 4 for index vectors and their predicates, 1 for loop induction var

    lane gather:
        apply permutation logic on two incoming vectors from pre.alc and their predicates
        Result is the uniform vector and merge vector and their predicates

    alc.applied:
        if uniform vector is filled with active lanes, executes then block fully vectorized
        loads the next iteration indices into %new.index.vec and its predicates to  %new.predicates

    linearized:
        it is executed when there are not enough active lanes to fill uniform vector so we are sure that-
        merge vector is filled with all inactive lanes and could be discarded.
        loads the next iteration indices into %new.index.vec.linearized and its predicates to  %new.predicates.linearized

    new.latch:
        based on which block has been exeuted between alc.applied and linearized, forms next iteration index vectors and-
        their predicates.
        updates loop induction var

    middel.block:
        When execution of the alc loop finished, decides if there are any remaining iterations to be executed scalar