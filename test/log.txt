Args: llc -print-after-all -debug loop.ll -o loop.s 

Features:+armv6kz,+armv6kz
CPU:generic
TuneCPU:generic

G_ADD (opcode 45): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SUB (opcode 46): 1 type index, 0 imm indices
.. opcode 46 is aliased to 45
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_MUL (opcode 47): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SDIV (opcode 48): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 49): 1 type index, 0 imm indices
.. opcode 49 is aliased to 48
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 50): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UREM (opcode 51): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVREM (opcode 52): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVREM (opcode 53): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_AND (opcode 54): 1 type index, 0 imm indices
.. opcode 54 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_OR (opcode 55): 1 type index, 0 imm indices
.. opcode 55 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_XOR (opcode 56): 1 type index, 0 imm indices
.. opcode 56 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_IMPLICIT_DEF (opcode 57): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 58): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FRAME_INDEX (opcode 59): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_GLOBAL_VALUE (opcode 60): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_EXTRACT (opcode 61): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 62): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT (opcode 63): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 64): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR (opcode 65): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 67): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 68): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 69): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 70): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 71): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_FPTRUNC_ROUND (opcode 72): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 73): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 74): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 75): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 76): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READCYCLECOUNTER (opcode 77): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 78): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_SEXTLOAD (opcode 79): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 81): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 82): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 83): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 84): 2 type indices, 0 imm indices
.. opcode 84 is aliased to 78
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_INDEXED_STORE (opcode 85): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 86): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 87): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 88): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 92): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 93): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 94): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 95): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 96): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 99): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 100): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 101): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 102): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_BRINDIRECT (opcode 103): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 104): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 105): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 106): 2 type indices, 0 imm indices
.. opcode 106 is aliased to 112
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_TRUNC (opcode 107): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 108): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FCONSTANT (opcode 109): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_VASTART (opcode 110): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 111): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 112): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SEXT_INREG (opcode 113): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 114): 2 type indices, 0 imm indices
.. opcode 114 is aliased to 112
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SHL (opcode 115): 2 type indices, 0 imm indices
.. opcode 115 is aliased to 117
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 116): 2 type indices, 0 imm indices
.. opcode 116 is aliased to 117
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 117): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTR (opcode 120): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTL (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 122): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 123): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 124): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UADDO (opcode 125): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 126): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 127): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 128): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 129): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 130): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 132): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 133): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 134): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 135): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 136): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 137): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 138): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 139): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 140): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 141): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 142): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 143): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 144): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 145): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 146): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 147): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 148): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 149): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 150): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 151): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FSUB (opcode 152): 1 type index, 0 imm indices
.. opcode 152 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMUL (opcode 153): 1 type index, 0 imm indices
.. opcode 153 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMA (opcode 154): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMAD (opcode 155): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 156): 1 type index, 0 imm indices
.. opcode 156 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FREM (opcode 157): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FPOW (opcode 158): 1 type index, 0 imm indices
.. opcode 158 is aliased to 157
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FPOWI (opcode 159): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 160): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 162): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 165): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FPEXT (opcode 166): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTRUNC (opcode 167): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOSI (opcode 168): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 169): 2 type indices, 0 imm indices
.. opcode 169 is aliased to 168
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SITOFP (opcode 170): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 171): 2 type indices, 0 imm indices
.. opcode 171 is aliased to 170
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FABS (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 173): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 174): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 175): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 176): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 177): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 178): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 179): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 180): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 181): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_PTRMASK (opcode 182): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 183): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 184): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 185): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 186): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LROUND (opcode 188): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LLROUND (opcode 189): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 190): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 191): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 192): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 193): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 194): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 195): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 197): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_CTLZ_ZERO_UNDEF (opcode 198): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_CTPOP (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 200): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 201): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 202): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 203): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 204): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 205): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 206): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 207): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 209): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 210): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 211): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 212): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 213): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 214): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 215): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 216): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 217): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 218): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 219): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 220): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 221): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 222): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY_INLINE (opcode 223): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMMOVE (opcode 224): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMSET (opcode 225): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BZERO (opcode 226): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FADD (opcode 227): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 228): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 229): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 230): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 231): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 232): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 233): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 234): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 235): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 236): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 237): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 238): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 239): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 240): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 241): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SBFX (opcode 242): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UBFX (opcode 243): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
*** IR Dump After Pre-ISel Intrinsic Lowering (pre-isel-intrinsic-lowering) ***
; ModuleID = 'loop.ll'
source_filename = "loop.c"
target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armv6kz-unknown-linux-gnueabihf"

; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.declare(metadata, metadata, metadata) #1

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #3

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !58 {
entry:
  ret i32 0, !dbg !62
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.value(metadata, metadata, metadata) #1

attributes #0 = { argmemonly nofree nosync nounwind readonly "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #1 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #3 = { argmemonly nofree nounwind willreturn writeonly }
attributes #4 = { mustprogress nofree norecurse nosync nounwind readnone willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #5 = { nounwind }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2, !3, !4, !5, !6, !7, !8, !9, !10, !11}
!llvm.ident = !{!12}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "loop.c", directory: "/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/test", checksumkind: CSK_MD5, checksum: "2dc758b34530a7da2189a085b7920e62")
!2 = !{i32 7, !"Dwarf Version", i32 5}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{i32 1, !"min_enum_size", i32 4}
!6 = !{i32 8, !"branch-target-enforcement", i32 0}
!7 = !{i32 8, !"sign-return-address", i32 0}
!8 = !{i32 8, !"sign-return-address-all", i32 0}
!9 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!10 = !{i32 7, !"PIC Level", i32 2}
!11 = !{i32 7, !"PIE Level", i32 2}
!12 = !{!"clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)"}
!13 = distinct !DISubprogram(name: "dijkstra", scope: !1, file: !1, line: 22, type: !14, scopeLine: 22, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !21)
!14 = !DISubroutineType(types: !15)
!15 = !{!16, !16, !16, !17}
!16 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
!17 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !18, size: 32)
!18 = !DICompositeType(tag: DW_TAG_array_type, baseType: !16, size: 16384, elements: !19)
!19 = !{!20}
!20 = !DISubrange(count: 512)
!21 = !{!22, !23, !24, !25, !26, !27, !28}
!22 = !DILocalVariable(name: "n", arg: 1, scope: !13, file: !1, line: 22, type: !16)
!23 = !DILocalVariable(name: "s", arg: 2, scope: !13, file: !1, line: 22, type: !16)
!24 = !DILocalVariable(name: "e", arg: 3, scope: !13, file: !1, line: 22, type: !17)
!25 = !DILocalVariable(name: "vis", scope: !13, file: !1, line: 23, type: !18)
!26 = !DILocalVariable(name: "dis", scope: !13, file: !1, line: 24, type: !18)
!27 = !DILocalVariable(name: "max", scope: !13, file: !1, line: 25, type: !16)
!28 = !DILocalVariable(name: "i", scope: !29, file: !1, line: 27, type: !16)
!29 = distinct !DILexicalBlock(scope: !13, file: !1, line: 27, column: 5)
!30 = !DILocation(line: 0, scope: !13)
!31 = !DILocation(line: 24, column: 5, scope: !13)
!32 = !DILocation(line: 24, column: 9, scope: !13)
!33 = !DILocation(line: 0, scope: !29)
!34 = !DILocation(line: 27, column: 23, scope: !35)
!35 = distinct !DILexicalBlock(scope: !29, file: !1, line: 27, column: 5)
!36 = !DILocation(line: 27, column: 5, scope: !29)
!37 = !DILocation(line: 34, column: 17, scope: !13)
!38 = !DILocation(line: 34, column: 12, scope: !13)
!39 = !{!40, !40, i64 0}
!40 = !{!"int", !41, i64 0}
!41 = !{!"omnipotent char", !42, i64 0}
!42 = !{!"Simple C/C++ TBAA"}
!43 = !DILocation(line: 35, column: 1, scope: !13)
!44 = !DILocation(line: 34, column: 5, scope: !13)
!45 = !DILocation(line: 28, column: 13, scope: !46)
!46 = distinct !DILexicalBlock(scope: !47, file: !1, line: 28, column: 13)
!47 = distinct !DILexicalBlock(scope: !35, file: !1, line: 27, column: 33)
!48 = !DILocation(line: 28, column: 21, scope: !46)
!49 = !DILocation(line: 28, column: 13, scope: !47)
!50 = !DILocation(line: 29, column: 13, scope: !51)
!51 = distinct !DILexicalBlock(scope: !46, file: !1, line: 28, column: 27)
!52 = !DILocation(line: 29, column: 20, scope: !51)
!53 = !DILocation(line: 27, column: 28, scope: !35)
!54 = distinct !{!54, !36, !55, !56, !57}
!55 = !DILocation(line: 33, column: 5, scope: !29)
!56 = !{!"llvm.loop.mustprogress"}
!57 = !{!"llvm.loop.unroll.disable"}
!58 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 37, type: !59, scopeLine: 37, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !61)
!59 = !DISubroutineType(types: !60)
!60 = !{!16}
!61 = !{}
!62 = !DILocation(line: 43, column: 1, scope: !58)

Features:+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp
CPU:arm1176jzf-s
TuneCPU:arm1176jzf-s

G_ADD (opcode 45): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SUB (opcode 46): 1 type index, 0 imm indices
.. opcode 46 is aliased to 45
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_MUL (opcode 47): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SDIV (opcode 48): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_UDIV (opcode 49): 1 type index, 0 imm indices
.. opcode 49 is aliased to 48
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_SREM (opcode 50): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UREM (opcode 51): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVREM (opcode 52): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVREM (opcode 53): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_AND (opcode 54): 1 type index, 0 imm indices
.. opcode 54 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_OR (opcode 55): 1 type index, 0 imm indices
.. opcode 55 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_XOR (opcode 56): 1 type index, 0 imm indices
.. opcode 56 is aliased to 47
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_IMPLICIT_DEF (opcode 57): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PHI (opcode 58): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FRAME_INDEX (opcode 59): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_GLOBAL_VALUE (opcode 60): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_EXTRACT (opcode 61): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UNMERGE_VALUES (opcode 62): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INSERT (opcode 63): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MERGE_VALUES (opcode 64): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BUILD_VECTOR (opcode 65): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BUILD_VECTOR_TRUNC (opcode 66): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONCAT_VECTORS (opcode 67): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTRTOINT (opcode 68): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_INTTOPTR (opcode 69): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_BITCAST (opcode 70): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FREEZE (opcode 71): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_FPTRUNC_ROUND (opcode 72): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_TRUNC (opcode 73): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUND (opcode 74): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_LRINT (opcode 75): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_ROUNDEVEN (opcode 76): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READCYCLECOUNTER (opcode 77): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LOAD (opcode 78): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_SEXTLOAD (opcode 79): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ZEXTLOAD (opcode 80): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_LOAD (opcode 81): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_SEXTLOAD (opcode 82): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INDEXED_ZEXTLOAD (opcode 83): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STORE (opcode 84): 2 type indices, 0 imm indices
.. opcode 84 is aliased to 78
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_INDEXED_STORE (opcode 85): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG_WITH_SUCCESS (opcode 86): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMIC_CMPXCHG (opcode 87): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XCHG (opcode 88): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_ADD (opcode 89): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_SUB (opcode 90): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_AND (opcode 91): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_NAND (opcode 92): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_OR (opcode 93): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_XOR (opcode 94): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MAX (opcode 95): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_MIN (opcode 96): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMAX (opcode 97): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_UMIN (opcode 98): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FADD (opcode 99): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ATOMICRMW_FSUB (opcode 100): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FENCE (opcode 101): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRCOND (opcode 102): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_BRINDIRECT (opcode 103): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC (opcode 104): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INTRINSIC_W_SIDE_EFFECTS (opcode 105): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ANYEXT (opcode 106): 2 type indices, 0 imm indices
.. opcode 106 is aliased to 112
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_TRUNC (opcode 107): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CONSTANT (opcode 108): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FCONSTANT (opcode 109): 1 type index, 0 imm indices
.. opcode 109 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_VASTART (opcode 110): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VAARG (opcode 111): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SEXT (opcode 112): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SEXT_INREG (opcode 113): 1 type index, 1 imm index
.. type index coverage check SKIPPED: user-defined predicate detected
.. imm index coverage check SKIPPED: user-defined predicate detected
G_ZEXT (opcode 114): 2 type indices, 0 imm indices
.. opcode 114 is aliased to 112
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SHL (opcode 115): 2 type indices, 0 imm indices
.. opcode 115 is aliased to 117
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_LSHR (opcode 116): 2 type indices, 0 imm indices
.. opcode 116 is aliased to 117
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_ASHR (opcode 117): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FSHL (opcode 118): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSHR (opcode 119): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTR (opcode 120): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ROTL (opcode 121): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ICMP (opcode 122): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FCMP (opcode 123): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SELECT (opcode 124): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UADDO (opcode 125): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDE (opcode 126): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBO (opcode 127): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBE (opcode 128): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDO (opcode 129): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDE (opcode 130): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBO (opcode 131): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBE (opcode 132): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULO (opcode 133): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULO (opcode 134): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULH (opcode 135): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULH (opcode 136): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UADDSAT (opcode 137): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SADDSAT (opcode 138): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USUBSAT (opcode 139): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSUBSAT (opcode 140): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_USHLSAT (opcode 141): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SSHLSAT (opcode 142): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIX (opcode 143): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIX (opcode 144): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMULFIXSAT (opcode 145): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMULFIXSAT (opcode 146): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIX (opcode 147): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIX (opcode 148): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SDIVFIXSAT (opcode 149): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UDIVFIXSAT (opcode 150): 1 type index, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FADD (opcode 151): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FSUB (opcode 152): 1 type index, 0 imm indices
.. opcode 152 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMUL (opcode 153): 1 type index, 0 imm indices
.. opcode 153 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMA (opcode 154): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FMAD (opcode 155): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FDIV (opcode 156): 1 type index, 0 imm indices
.. opcode 156 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FREM (opcode 157): 1 type index, 0 imm indices
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FPOW (opcode 158): 1 type index, 0 imm indices
.. opcode 158 is aliased to 157
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FPOWI (opcode 159): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP (opcode 160): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FEXP2 (opcode 161): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG (opcode 162): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG2 (opcode 163): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FLOG10 (opcode 164): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEG (opcode 165): 1 type index, 0 imm indices
.. opcode 165 is aliased to 151
.. the first uncovered type index: 1, OK
.. the first uncovered imm index: 0, OK
G_FPEXT (opcode 166): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTRUNC (opcode 167): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOSI (opcode 168): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FPTOUI (opcode 169): 2 type indices, 0 imm indices
.. opcode 169 is aliased to 168
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_SITOFP (opcode 170): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_UITOFP (opcode 171): 2 type indices, 0 imm indices
.. opcode 171 is aliased to 170
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_FABS (opcode 172): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOPYSIGN (opcode 173): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCANONICALIZE (opcode 174): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM (opcode 175): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM (opcode 176): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINNUM_IEEE (opcode 177): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXNUM_IEEE (opcode 178): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMINIMUM (opcode 179): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FMAXIMUM (opcode 180): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_PTR_ADD (opcode 181): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_PTRMASK (opcode 182): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMIN (opcode 183): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SMAX (opcode 184): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMIN (opcode 185): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UMAX (opcode 186): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ABS (opcode 187): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LROUND (opcode 188): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_LLROUND (opcode 189): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BR (opcode 190): 0 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BRJT (opcode 191): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_INSERT_VECTOR_ELT (opcode 192): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_EXTRACT_VECTOR_ELT (opcode 193): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SHUFFLE_VECTOR (opcode 194): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ (opcode 195): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTTZ_ZERO_UNDEF (opcode 196): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_CTLZ (opcode 197): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_CTLZ_ZERO_UNDEF (opcode 198): 2 type indices, 0 imm indices
.. the first uncovered type index: 2, OK
.. the first uncovered imm index: 0, OK
G_CTPOP (opcode 199): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BSWAP (opcode 200): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BITREVERSE (opcode 201): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCEIL (opcode 202): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FCOS (opcode 203): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSIN (opcode 204): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FSQRT (opcode 205): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FFLOOR (opcode 206): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FRINT (opcode 207): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_FNEARBYINT (opcode 208): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_ADDRSPACE_CAST (opcode 209): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BLOCK_ADDR (opcode 210): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_JUMP_TABLE (opcode 211): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_DYN_STACKALLOC (opcode 212): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FADD (opcode 213): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSUB (opcode 214): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMUL (opcode 215): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FDIV (opcode 216): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FREM (opcode 217): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FMA (opcode 218): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_STRICT_FSQRT (opcode 219): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_READ_REGISTER (opcode 220): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_WRITE_REGISTER (opcode 221): 1 type index, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY (opcode 222): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMCPY_INLINE (opcode 223): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMMOVE (opcode 224): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_MEMSET (opcode 225): 3 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_BZERO (opcode 226): 2 type indices, 1 imm index
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FADD (opcode 227): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SEQ_FMUL (opcode 228): 3 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FADD (opcode 229): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMUL (opcode 230): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMAX (opcode 231): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_FMIN (opcode 232): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_ADD (opcode 233): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_MUL (opcode 234): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_AND (opcode 235): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_OR (opcode 236): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_XOR (opcode 237): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMAX (opcode 238): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_SMIN (opcode 239): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMAX (opcode 240): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_VECREDUCE_UMIN (opcode 241): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_SBFX (opcode 242): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
G_UBFX (opcode 243): 2 type indices, 0 imm indices
.. type index coverage check SKIPPED: no rules defined
.. imm index coverage check SKIPPED: no rules defined
*** IR Dump After Expand Atomic instructions (atomic-expand) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}
*** IR Dump After Simplify the CFG (simplifycfg) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}
*** IR Dump After MVE gather/scatter lowering (arm-mve-gather-scatter-lowering) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}
*** IR Dump After MVE lane interleaving (mve-laneinterleave) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body, label %for.cond.cleanup, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body, %entry
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %entry ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !54
}
LoopSimplify: Creating pre-header for.body.preheader
LoopSimplify: Creating dedicated exit block for.cond.cleanup.loopexit
*** IR Dump After Canonicalize natural loops (loop-simplify) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %0 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %0, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !54
}
canonfr: PHI:   %i.019 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
*** IR Dump After Canonicalize Freeze Instructions in Loops (canon-freeze) ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  br label %for.body, !dbg !36

; Loop:
for.body:                                         ; preds = %for.body.preheader, %for.body
  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  call void @llvm.dbg.value(metadata i32 %i.019, metadata !28, metadata !DIExpression()), !dbg !33
  %arrayidx2 = getelementptr inbounds [512 x i32], ptr %e, i32 %s, i32 %i.019, !dbg !45
  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %1, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %1, !dbg !49
  %2 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %i.019, !dbg !50
  store i32 %spec.select, ptr %2, align 4, !dbg !52
  %inc = add nuw nsw i32 %i.019, 1, !dbg !53
  call void @llvm.dbg.value(metadata i32 %inc, metadata !28, metadata !DIExpression()), !dbg !33
  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !54

; Exit blocks
for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37
FOUND USER:   %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
   OF SCEV: {1,+,1}<nuw><nsw><%for.body>
FOUND USER:   store i32 %spec.select, ptr %2, align 4, !dbg !52
   OF SCEV: {%dis,+,4}<nuw><%for.body>
FOUND USER:   %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39
   OF SCEV: {((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>

LSR on loop %for.body:
  Change loop exiting icmp to use postinc iv:   %exitcond.not = icmp eq i32 %inc, %n, !dbg !34
Collecting IV Chains.
IV Chain#0 Head: (  %1 = load i32, ptr %arrayidx2, align 4, !dbg !45, !tbaa !39) IV={((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>
IV Chain#1 Head: (  store i32 %spec.select, ptr %2, align 4, !dbg !52) IV={%dis,+,4}<nuw><%for.body>
IV Chain#2 Head: (  %exitcond.not = icmp eq i32 %inc, %n, !dbg !34) IV={1,+,1}<nuw><nsw><%for.body>
IV Chain#2  Inc: (  %i.019 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]) IV+0
Chain:   %exitcond.not = icmp eq i32 %inc, %n, !dbg !34 Cost: 1
LSR has identified the following interesting factors and types: *4
LSR is examining the following fixup sites:
  UserInst=%exitcond.not, OperandValToReplace=%inc, PostIncLoop=%for.body
  UserInst=store %spec.select, OperandValToReplace=%2
  UserInst=%1, OperandValToReplace=%arrayidx2
LSR found 3 uses:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({%n,+,-1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({%dis,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)

After generating reuse formulae:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({%n,+,-1}<nw><%for.body>)
    reg(%n) + 1*reg({0,+,-1}<nw><%for.body>)
    reg({(-1 * %n),+,1}<nw><%for.body>)
    reg((-1 * %n)) + 1*reg({0,+,1}<nuw><nsw><%for.body>)
    reg(%n) + -1*reg({0,+,1}<nuw><nsw><%for.body>)
    reg((-1 * %n)) + -1*reg({0,+,-1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({%dis,+,4}<nuw><%for.body>)
    reg(%dis) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    reg(%dis) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
    reg(%dis) + -4*reg({0,+,-1}<nw><%for.body>)
    reg(%dis) + -1*reg({0,+,-4}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
    reg((2048 * %s)<nsw>) + 1*reg({%e,+,4}<nw><%for.body>)
    reg((2048 * %s)<nsw>) + reg(%e) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    reg(%e) + 1*reg({(2048 * %s)<nsw>,+,4}<nsw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    reg((2048 * %s)<nsw>) + reg(%e) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
    reg((2048 * %s)<nsw>) + reg(%e) + -4*reg({0,+,-1}<nw><%for.body>)
    reg((2048 * %s)<nsw>) + reg(%e) + -1*reg({0,+,-4}<nw><%for.body>)
    reg(%e) + 4*reg({(512 * %s),+,1}<%for.body>)
    reg(%e) + -4*reg({(-512 * %s),+,-1}<%for.body>)
    reg(%e) + -1*reg({(-2048 * %s),+,-4}<nw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + -4*reg({0,+,-1}<nw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + -1*reg({0,+,-4}<nw><%for.body>)
Filtering for use LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
  Filtering out formula reg({(-1 * %n),+,1}<nw><%for.body>)
    in favor of formula reg({%n,+,-1}<nw><%for.body>)
  Filtering out formula reg(%n) + 1*reg({0,+,-1}<nw><%for.body>)
    in favor of formula reg((-1 * %n)) + -1*reg({0,+,-1}<nw><%for.body>)
  Filtering out formula reg((-1 * %n)) + 1*reg({0,+,1}<nuw><nsw><%for.body>)
    in favor of formula reg(%n) + -1*reg({0,+,1}<nuw><nsw><%for.body>)
Filtering for use LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
Filtering for use LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
  Filtering out formula reg((2048 * %s)<nsw>) + 1*reg({%e,+,4}<nw><%for.body>)
    in favor of formula reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
  Filtering out formula reg(%e) + 1*reg({(2048 * %s)<nsw>,+,4}<nsw><%for.body>)
    in favor of formula reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
  Filtering out formula reg((2048 * %s)<nsw>) + reg(%e) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    in favor of formula reg(((2048 * %s)<nsw> + %e)) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
  Filtering out formula reg((2048 * %s)<nsw>) + reg(%e) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
    in favor of formula reg(((2048 * %s)<nsw> + %e)) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
  Filtering out formula reg(%e) + -1*reg({(-2048 * %s),+,-4}<nw><%for.body>)
    in favor of formula reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
  Filtering out formula reg(%e) + -4*reg({(-512 * %s),+,-1}<%for.body>)
    in favor of formula reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
  Filtering out formula reg(%e) + 4*reg({(512 * %s),+,1}<%for.body>)
    in favor of formula reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
  Filtering out formula reg((2048 * %s)<nsw>) + reg(%e) + -1*reg({0,+,-4}<nw><%for.body>)
    in favor of formula reg(((2048 * %s)<nsw> + %e)) + -1*reg({0,+,-4}<nw><%for.body>)
  Filtering out formula reg((2048 * %s)<nsw>) + reg(%e) + -4*reg({0,+,-1}<nw><%for.body>)
    in favor of formula reg(((2048 * %s)<nsw> + %e)) + -4*reg({0,+,-1}<nw><%for.body>)

After filtering out undesirable candidates:
LSR is examining the following uses:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({%n,+,-1}<nw><%for.body>)
    reg((-1 * %n)) + -1*reg({0,+,-1}<nw><%for.body>)
    reg(%n) + -1*reg({0,+,1}<nuw><nsw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({%dis,+,4}<nuw><%for.body>)
    reg(%dis) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    reg(%dis) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
    reg(%dis) + -4*reg({0,+,-1}<nw><%for.body>)
    reg(%dis) + -1*reg({0,+,-4}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + -1*reg({0,+,-4}<nw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + 1*reg({0,+,4}<nuw><nsw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + -4*reg({0,+,-1}<nw><%for.body>)
    reg(((2048 * %s)<nsw> + %e)) + 4*reg({0,+,1}<nuw><nsw><%for.body>)
New best at 3 instructions 3 regs, with addrec cost 3, plus 5 setup cost.
Regs:
- {%n,+,-1}<nw><%for.body>
- {%dis,+,4}<nuw><%for.body>
- {((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>


The chosen solution requires 3 instructions 3 regs, with addrec cost 3, plus 5 setup cost:
  LSR Use: Kind=ICmpZero, Offsets={0}, widest fixup type: i32
    reg({%n,+,-1}<nw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({%dis,+,4}<nuw><%for.body>)
  LSR Use: Kind=Address of i32 in addrspace(0), Offsets={0}, widest fixup type: ptr
    reg({((2048 * %s)<nsw> + %e),+,4}<nw><%for.body>)
SALVAGE:   call void @llvm.dbg.value(metadata i32 undef, metadata !28, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !33
scev-salvage: IV SCEV: {%n,+,-1}<nw><%for.body>
scev-salvage: value to recover SCEV: {0,+,1}<nuw><nsw><%for.body>
scev-salvage: Value to salvage SCEV: {0,+,1}<nuw><nsw><%for.body>
scev-salvage: Updating:   call void @llvm.dbg.value(metadata i32 undef, metadata !28, metadata !DIExpression()), !dbg !33
scev-salvage: to:   call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
scev-salvage: value to recover SCEV: {1,+,1}<nuw><nsw><%for.body>
scev-salvage: Value to salvage SCEV: {1,+,1}<nuw><nsw><%for.body>
scev-salvage: Updating:   call void @llvm.dbg.value(metadata i32 undef, metadata !28, metadata !DIExpression(DW_OP_plus_uconst, 1, DW_OP_stack_value)), !dbg !33
scev-salvage: to:   call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
*** IR Dump After Loop Strength Reduction (loop-reduce) ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

; Loop:
for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52

; Exit blocks
for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37
MergeICmpsLegacyPass: dijkstra
*** IR Dump After Merge contiguous icmps into a memcmp (mergeicmps) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Expand memcmp() to load/stores (expandmemcmp) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Lower Garbage Collection Instructions (gc-lowering) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Shadow Stack GC Lowering (shadow-stack-gc-lowering) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Lower constant intrinsics (lower-constant-intrinsics) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Remove unreachable blocks from the CFG (unreachableblockelim) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.cond.cleanup.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.cond.cleanup 
---- Branch Probability Info : dijkstra ----

Computing probabilities for for.cond.cleanup
Computing probabilities for for.cond.cleanup.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.cond.cleanup.loopexit
 - 4: for.cond.cleanup
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup.loopexit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.cond.cleanup.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1342177280, succ = for.body.preheader
  => [ local  ] weight = 805306368, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to for.body.preheader
  => assign 6000000000000000 (0000000000000000) to for.cond.cleanup
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.cond.cleanup.loopexit
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup.loopexit
 - node: for.cond.cleanup.loopexit
  => [ local  ] weight = 2147483648, succ = for.cond.cleanup
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - for.body: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - entry: float = 1.0, scaled = 12.8, int = 12
 - for.body.preheader: float = 0.625, scaled = 8.0, int = 8
 - for.body: float = 20.0, scaled = 256.0, int = 255
 - for.cond.cleanup.loopexit: float = 0.625, scaled = 8.0, int = 8
 - for.cond.cleanup: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - entry: float = 1.0, int = 12
 - for.body.preheader: float = 0.625, int = 8
 - for.cond.cleanup.loopexit: float = 0.625, int = 8
 - for.cond.cleanup: float = 1.0, int = 12
 - for.body: float = 20.0, int = 255

********** Begin Constant Hoisting **********
********** Function: dijkstra
Collect constant i32 1000000 from   %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49 with cost 3
********** End Constant Hoisting **********
*** IR Dump After Constant Hoisting (consthoist) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Replace intrinsics with calls to vector library (replace-with-veclib) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Partially inline calls to library functions (partially-inline-libcalls) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Expand vector predication intrinsics (expandvp) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Scalarize Masked Memory Intrinsics (scalarize-masked-mem-intrin) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Expand reduction intrinsics (expand-reductions) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
********** Begin TLS Variable Hoist **********
********** Function: dijkstra
********** End TLS Variable Hoist **********
*** IR Dump After TLS Variable Hoist (tlshoist) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
*** Interleaved Access Pass: dijkstra
*** IR Dump After Interleaved Access Pass (interleaved-access) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
IR Promotion: Running on dijkstra
IR Promotion: Searching from:   %cmp3 = icmp eq i32 %2, 0, !dbg !48
IR Promotion: Searching from:   %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
*** IR Dump After Type Promotion (type-promotion) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 4
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 4 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup.loopexit, label %for.body, !dbg !36, !llvm.loop !52
}
---- Branch Probability Info : dijkstra ----

		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 5, Num: 6
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.cond.cleanup.loopexit
5: %for.body
6: %for.body.preheader
Found roots: %for.cond.cleanup 
Computing probabilities for for.cond.cleanup
Computing probabilities for for.cond.cleanup.loopexit
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%

block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: entry
 - 1: for.body.preheader
 - 2: for.body
 - 3: for.cond.cleanup.loopexit
 - 4: for.cond.cleanup
loop-detection
 - loop = for.body
compute-mass-in-loop: for.body*
 - node: for.body
  => [  exit  ] weight = 67108864, succ = for.cond.cleanup.loopexit
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to for.body
  => assign 0800000000000000 (0000000000000000) [exit] to for.cond.cleanup.loopexit
compute-loop-scale: for.body*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: for.body*
 - node: for.body
compute-mass-in-function
 - node: entry
  => [ local  ] weight = 1342177280, succ = for.body.preheader
  => [ local  ] weight = 805306368, succ = for.cond.cleanup
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to for.body.preheader
  => assign 6000000000000000 (0000000000000000) to for.cond.cleanup
 - node: for.body.preheader
  => [ local  ] weight = 2147483648, succ = for.body
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.body
 - node: for.body
  => [ local  ] weight = 576460752303423488, succ = for.cond.cleanup.loopexit
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup.loopexit
 - node: for.cond.cleanup.loopexit
  => [ local  ] weight = 2147483648, succ = for.cond.cleanup
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to for.cond.cleanup
 - node: for.cond.cleanup
  => mass:  ffffffffffffffff
unwrap-loop-package: for.body*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - for.body: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - entry: float = 1.0, scaled = 12.8, int = 12
 - for.body.preheader: float = 0.625, scaled = 8.0, int = 8
 - for.body: float = 20.0, scaled = 256.0, int = 255
 - for.cond.cleanup.loopexit: float = 0.625, scaled = 8.0, int = 8
 - for.cond.cleanup: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - entry: float = 1.0, int = 12
 - for.body.preheader: float = 0.625, int = 8
 - for.cond.cleanup.loopexit: float = 0.625, int = 8
 - for.cond.cleanup: float = 1.0, int = 12
 - for.body: float = 20.0, int = 255

MERGING MOSTLY EMPTY BLOCKS - BEFORE:

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup, !dbg !37

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44
AFTER:

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44



CGP: Found      local addrmode: [inbounds Base:%dis + 4*%sub]
*** IR Dump After CodeGen Prepare (codegenprepare) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Exception handling preparation (dwarfehprepare) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Merge internal globals (global-merge) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
HWLoops: Running on dijkstra
HWLoops: Loop for.body
ARMHWLoops: Disabled
HWLoops: it's not profitable to create a hardware-loop.
*** IR Dump After Hardware Loop Insertion (hardware-loops) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
ARM TP: Not a v8.1m.main+mve target.
*** IR Dump After Transform predicated vector loops to use MVE tail predication (mve-tail-predication) ***
; Preheader:
for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

; Loop:
for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52

; Exit blocks
for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44
*** IR Dump After Expand Atomic instructions (atomic-expand) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Simplify the CFG (simplifycfg) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After MVE gather/scatter lowering (arm-mve-gather-scatter-lowering) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After MVE lane interleaving (mve-laneinterleave) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Canonicalize natural loops (loop-simplify) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
MergeICmpsLegacyPass: main
*** IR Dump After Merge contiguous icmps into a memcmp (mergeicmps) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Expand memcmp() to load/stores (expandmemcmp) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Lower Garbage Collection Instructions (gc-lowering) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Shadow Stack GC Lowering (shadow-stack-gc-lowering) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Lower constant intrinsics (lower-constant-intrinsics) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Remove unreachable blocks from the CFG (unreachableblockelim) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : main ----

Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8

********** Begin Constant Hoisting **********
********** Function: main
********** End Constant Hoisting **********
*** IR Dump After Constant Hoisting (consthoist) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Replace intrinsics with calls to vector library (replace-with-veclib) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Partially inline calls to library functions (partially-inline-libcalls) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Expand vector predication intrinsics (expandvp) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Scalarize Masked Memory Intrinsics (scalarize-masked-mem-intrin) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Expand reduction intrinsics (expand-reductions) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
********** Begin TLS Variable Hoist **********
********** Function: main
********** End TLS Variable Hoist **********
*** IR Dump After TLS Variable Hoist (tlshoist) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** Interleaved Access Pass: main
*** IR Dump After Interleaved Access Pass (interleaved-access) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
IR Promotion: Running on main
*** IR Dump After Type Promotion (type-promotion) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
---- Branch Probability Info : main ----

		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
Computing probabilities for entry

block-frequency: main
=====================
reverse-post-order-traversal
 - 0: entry
loop-detection
compute-mass-in-function
 - node: entry
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - entry: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - entry: float = 1.0, int = 8

*** IR Dump After CodeGen Prepare (codegenprepare) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Exception handling preparation (dwarfehprepare) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Merge internal globals (global-merge) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
HWLoops: Running on main
*** IR Dump After Hardware Loop Insertion (hardware-loops) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After A No-Op Barrier Pass (barrier) ***
; ModuleID = 'loop.ll'
source_filename = "loop.c"
target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armv6kz-unknown-linux-gnueabihf"

; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.declare(metadata, metadata, metadata) #1

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #3

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.value(metadata, metadata, metadata) #1

attributes #0 = { argmemonly nofree nosync nounwind readonly "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #1 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #3 = { argmemonly nofree nounwind willreturn writeonly }
attributes #4 = { mustprogress nofree norecurse nosync nounwind readnone willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #5 = { nounwind }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2, !3, !4, !5, !6, !7, !8, !9, !10, !11}
!llvm.ident = !{!12}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "loop.c", directory: "/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/test", checksumkind: CSK_MD5, checksum: "2dc758b34530a7da2189a085b7920e62")
!2 = !{i32 7, !"Dwarf Version", i32 5}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{i32 1, !"min_enum_size", i32 4}
!6 = !{i32 8, !"branch-target-enforcement", i32 0}
!7 = !{i32 8, !"sign-return-address", i32 0}
!8 = !{i32 8, !"sign-return-address-all", i32 0}
!9 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!10 = !{i32 7, !"PIC Level", i32 2}
!11 = !{i32 7, !"PIE Level", i32 2}
!12 = !{!"clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)"}
!13 = distinct !DISubprogram(name: "dijkstra", scope: !1, file: !1, line: 22, type: !14, scopeLine: 22, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !21)
!14 = !DISubroutineType(types: !15)
!15 = !{!16, !16, !16, !17}
!16 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
!17 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !18, size: 32)
!18 = !DICompositeType(tag: DW_TAG_array_type, baseType: !16, size: 16384, elements: !19)
!19 = !{!20}
!20 = !DISubrange(count: 512)
!21 = !{!22, !23, !24, !25, !26, !27, !28}
!22 = !DILocalVariable(name: "n", arg: 1, scope: !13, file: !1, line: 22, type: !16)
!23 = !DILocalVariable(name: "s", arg: 2, scope: !13, file: !1, line: 22, type: !16)
!24 = !DILocalVariable(name: "e", arg: 3, scope: !13, file: !1, line: 22, type: !17)
!25 = !DILocalVariable(name: "vis", scope: !13, file: !1, line: 23, type: !18)
!26 = !DILocalVariable(name: "dis", scope: !13, file: !1, line: 24, type: !18)
!27 = !DILocalVariable(name: "max", scope: !13, file: !1, line: 25, type: !16)
!28 = !DILocalVariable(name: "i", scope: !29, file: !1, line: 27, type: !16)
!29 = distinct !DILexicalBlock(scope: !13, file: !1, line: 27, column: 5)
!30 = !DILocation(line: 0, scope: !13)
!31 = !DILocation(line: 24, column: 5, scope: !13)
!32 = !DILocation(line: 24, column: 9, scope: !13)
!33 = !DILocation(line: 0, scope: !29)
!34 = !DILocation(line: 27, column: 23, scope: !35)
!35 = distinct !DILexicalBlock(scope: !29, file: !1, line: 27, column: 5)
!36 = !DILocation(line: 27, column: 5, scope: !29)
!37 = !DILocation(line: 34, column: 17, scope: !13)
!38 = !DILocation(line: 34, column: 12, scope: !13)
!39 = !{!40, !40, i64 0}
!40 = !{!"int", !41, i64 0}
!41 = !{!"omnipotent char", !42, i64 0}
!42 = !{!"Simple C/C++ TBAA"}
!43 = !DILocation(line: 35, column: 1, scope: !13)
!44 = !DILocation(line: 34, column: 5, scope: !13)
!45 = !DILocation(line: 28, column: 13, scope: !46)
!46 = distinct !DILexicalBlock(scope: !47, file: !1, line: 28, column: 13)
!47 = distinct !DILexicalBlock(scope: !35, file: !1, line: 27, column: 33)
!48 = !DILocation(line: 28, column: 21, scope: !46)
!49 = !DILocation(line: 28, column: 13, scope: !47)
!50 = !DILocation(line: 29, column: 20, scope: !51)
!51 = distinct !DILexicalBlock(scope: !46, file: !1, line: 28, column: 27)
!52 = distinct !{!52, !36, !53, !54, !55}
!53 = !DILocation(line: 33, column: 5, scope: !29)
!54 = !{!"llvm.loop.mustprogress"}
!55 = !{!"llvm.loop.unroll.disable"}
!56 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 37, type: !57, scopeLine: 37, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !59)
!57 = !DISubroutineType(types: !58)
!58 = !{!16}
!59 = !{}
!60 = !DILocation(line: 43, column: 1, scope: !56)
[SafeStack] Function: dijkstra
[SafeStack]     safestack is not requested for this function
*** IR Dump After Safe Stack instrumentation pass (safe-stack) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}
		Looking for trivial roots
Found a new trivial root: %for.cond.cleanup
Last visited node: %for.body.preheader
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %for.cond.cleanup
3: %entry
4: %for.body
5: %for.body.preheader
Found roots: %for.cond.cleanup 
---- Branch Probability Info : dijkstra ----

Computing probabilities for for.cond.cleanup
Computing probabilities for for.body
eraseBlock for.body
set edge for.body -> 0 successor probability to 0x04000000 / 0x80000000 = 3.12%
set edge for.body -> 1 successor probability to 0x7c000000 / 0x80000000 = 96.88%
Computing probabilities for for.body.preheader
Computing probabilities for entry
eraseBlock entry
set edge entry -> 0 successor probability to 0x50000000 / 0x80000000 = 62.50%
set edge entry -> 1 successor probability to 0x30000000 / 0x80000000 = 37.50%



=== dijkstra
isHA: 0 i32
isHA: 0 i32
isHA: 0 ptr
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %7
Creating new node: t4: i32,ch = CopyFromReg t0, Register:i32 %8
Creating new node: t6: i32,ch = CopyFromReg t0, Register:i32 %9
processDbgDeclares: setVariableDbgInfo FI=0,   call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
Argument does not have assigned frame index!
Argument does not have assigned frame index!
Argument does not have assigned frame index!
Creating new node: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
SelectionDAG visiting debug intrinsic:   call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
Skipping   call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32 (variable info stashed in MF side table)
Creating constant: t10: i8 = Constant<0>
Creating constant: t11: i32 = Constant<2048>
isHA: 0 i32
isHA: 0 ptr
isHA: 0 i8
Creating constant: t13: i32 = Constant<0>
isHA: 0 i32
Creating constant: t14: i32 = TargetConstant<0>
Creating new node: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
Creating new node: t17: i32,ch = CopyFromReg t15, Register:i32 $sp, loop.c:24:9
Creating new node: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Creating new node: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Creating new node: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Creating new node: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Creating constant: t27: i32 = TargetConstant<-1>
Creating new node: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
Creating new node: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
Creating new node: t31: i1 = setcc t2, Constant:i32<0>, setgt:ch, loop.c:27:23
Creating constant: t32: i1 = Constant<-1>
Creating new node: t33: i1 = xor t31, Constant:i1<-1>, loop.c:27:5
Creating new node: t35: ch = brcond t29:1, t33, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t37: ch = br t35, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
Initial selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 38 nodes:
  t0: ch = EntryToken
  t4: i32,ch = CopyFromReg t0, Register:i32 %8
  t6: i32,ch = CopyFromReg t0, Register:i32 %9
  t10: i8 = Constant<0>
  t12: i32 = ExternalSymbol'memset'
    t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
  t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
  t17: i32,ch = CopyFromReg t15, Register:i32 $sp, loop.c:24:9
  t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
  t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
  t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
          t2: i32,ch = CopyFromReg t0, Register:i32 %7
        t31: i1 = setcc t2, Constant:i32<0>, setgt:ch, loop.c:27:23
      t33: i1 = xor t31, Constant:i1<-1>, loop.c:27:5
    t35: ch = brcond t29:1, t33, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t37: ch = br t35, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5



Combining: t37: ch = br t35, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Combining: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>

Combining: t35: ch = brcond t29:1, t33, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t39: i1 = setcc t2, Constant:i32<0>, setle:ch, loop.c:27:23
Creating new node: t40: ch = brcond t29:1, t39, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
 ... into: t40: ch = brcond t29:1, t39, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t37: ch = br t40, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Combining: t40: ch = brcond t29:1, t39, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t41: ch = br_cc t29:1, setle:ch, t2, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
 ... into: t41: ch = br_cc t29:1, setle:ch, t2, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t38: ch = setle

Combining: t37: ch = br t41, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Combining: t41: ch = br_cc t29:1, setle:ch, t2, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating constant: t42: i32 = Constant<1>
Creating new node: t44: i32 = setcc t2, Constant:i32<1>, setlt:ch, loop.c:27:5
Creating new node: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
 ... into: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t42: i32 = Constant<1>

Combining: t43: ch = setlt

Combining: t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Combining: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Combining: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9

Combining: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9

Combining: t27: i32 = TargetConstant<-1>

Combining: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9

Combining: t25: Untyped = RegisterMask

Combining: t24: i32 = TargetExternalSymbol'memset'

Combining: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9

Combining: t22: i32 = Register $r2

Combining: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9

Combining: t20: i32 = Register $r1

Combining: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9

Combining: t18: i32 = Register $r0

Combining: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9

Combining: t14: i32 = TargetConstant<0>

Combining: t13: i32 = Constant<0>

Combining: t11: i32 = Constant<2048>

Combining: t9: i32 = FrameIndex<0>

Combining: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

Combining: t7: i32 = TargetFrameIndex<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %7

Combining: t1: i32 = Register %7

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
      t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
    t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
  t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
  t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
  t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
      t2: i32,ch = CopyFromReg t0, Register:i32 %7
    t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5


Legalizing node: t43: ch = setlt
Analyzing result type: ch
Legal result type
Legally typed node: t43: ch = setlt

Legalizing node: t42: i32 = Constant<1>
Analyzing result type: i32
Legal result type
Legally typed node: t42: i32 = Constant<1>

Legalizing node: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>
Analyzing result type: ch
Legal result type
Legally typed node: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>

Legalizing node: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Analyzing result type: ch
Legal result type
Legally typed node: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Legalizing node: t27: i32 = TargetConstant<-1>
Ignoring node results
Legally typed node: t27: i32 = TargetConstant<-1>

Legalizing node: t25: Untyped = RegisterMask
Analyzing result type: Untyped
Legal result type
Legally typed node: t25: Untyped = RegisterMask

Legalizing node: t24: i32 = TargetExternalSymbol'memset'
Analyzing result type: i32
Legal result type
Legally typed node: t24: i32 = TargetExternalSymbol'memset'

Legalizing node: t22: i32 = Register $r2
Ignoring node results
Legally typed node: t22: i32 = Register $r2

Legalizing node: t20: i32 = Register $r1
Ignoring node results
Legally typed node: t20: i32 = Register $r1

Legalizing node: t18: i32 = Register $r0
Ignoring node results
Legally typed node: t18: i32 = Register $r0

Legalizing node: t14: i32 = TargetConstant<0>
Ignoring node results
Legally typed node: t14: i32 = TargetConstant<0>

Legalizing node: t13: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t13: i32 = Constant<0>

Legalizing node: t11: i32 = Constant<2048>
Analyzing result type: i32
Legal result type
Legally typed node: t11: i32 = Constant<2048>

Legalizing node: t9: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t9: i32 = FrameIndex<0>

Legalizing node: t7: i32 = TargetFrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t7: i32 = TargetFrameIndex<0>

Legalizing node: t1: i32 = Register %7
Ignoring node results
Legally typed node: t1: i32 = Register %7

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %7
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %7

Legalizing node: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: i32 = TargetFrameIndex<0>
Legal operand
Legally typed node: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

Legalizing node: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
Legal operand
Legally typed node: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9

Legalizing node: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
Legal operand
Analyzing operand: t9: i32 = FrameIndex<0>
Legal operand
Legally typed node: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9

Legalizing node: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Legal operand
Analyzing operand: t13: i32 = Constant<0>
Legal operand
Analyzing operand: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Legal operand
Legally typed node: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9

Legalizing node: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Legal operand
Analyzing operand: t11: i32 = Constant<2048>
Legal operand
Analyzing operand: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Legal operand
Legally typed node: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9

Legalizing node: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Legal operand
Analyzing operand: t24: i32 = TargetExternalSymbol'memset'
Legal operand
Analyzing operand: t25: Untyped = RegisterMask
Legal operand
Analyzing operand: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Legal operand
Legally typed node: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9

Legalizing node: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Legal operand
Analyzing operand: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Legal operand
Legally typed node: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9

Legalizing node: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
Legal operand
Analyzing operand: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
Legal operand
Legally typed node: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9

Legalizing node: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
Legal operand
Analyzing operand: t43: ch = setlt
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %7
Legal operand
Analyzing operand: t42: i32 = Constant<1>
Legal operand
Analyzing operand: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal operand
Legally typed node: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Legalizing node: t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Legal operand
Analyzing operand: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>
Legal operand
Legally typed node: t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Legalizing node: t65535: ch = handlenode t37
Analyzing result type: ch
Legal result type
Analyzing operand: t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
Legal operand
Legally typed node: t65535: ch = handlenode t37

Type-legalized selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 28 nodes:
  t0: ch = EntryToken
      t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
    t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
  t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
  t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
  t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
      t2: i32,ch = CopyFromReg t0, Register:i32 %7
    t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5



Legalizing: t37: ch = br t45, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
Legal node: nothing to do

Legalizing: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Trying custom legalization
Lowering node: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating constant: t46: i32 = Constant<11>
Creating new node: t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
Creating new node: t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
Successfully custom legalized node
 ... replacing: t45: ch = br_cc t29:1, setlt:ch, t2, Constant:i32<1>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
     with:      t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5

Legalizing: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
Legal node: nothing to do

Legalizing: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9

Legalizing: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Legal node: nothing to do

Legalizing: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Legal node: nothing to do

Legalizing: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Legal node: nothing to do

Legalizing: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Legal node: nothing to do

Legalizing: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9

Legalizing: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %7
Legal node: nothing to do

Legalizing: t42: i32 = Constant<1>
Legal node: nothing to do

Legalizing: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>
Legal node: nothing to do

Legalizing: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal node: nothing to do

Legalizing: t27: i32 = TargetConstant<-1>

Legalizing: t25: Untyped = RegisterMask
Legal node: nothing to do

Legalizing: t24: i32 = TargetExternalSymbol'memset'
Legal node: nothing to do

Legalizing: t22: i32 = Register $r2

Legalizing: t20: i32 = Register $r1

Legalizing: t18: i32 = Register $r0

Legalizing: t14: i32 = TargetConstant<0>

Legalizing: t13: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t11: i32 = Constant<2048>
Legal node: nothing to do

Legalizing: t9: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t7: i32 = TargetFrameIndex<0>
Legal node: nothing to do

Legalizing: t1: i32 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
Legal node: nothing to do

Legalizing: t48: i32 = Register $cpsr

Legalizing: t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
Legal node: nothing to do

Legalizing: t46: i32 = Constant<11>
Legal node: nothing to do
Legalized selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 30 nodes:
  t0: ch = EntryToken
      t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
    t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
  t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
  t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
  t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
        t2: i32,ch = CopyFromReg t0, Register:i32 %7
      t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
    t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
  t37: ch = br t49, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5



Legalizing: t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
Legal node: nothing to do

Combining: t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5

Legalizing: t48: i32 = Register $cpsr

Combining: t48: i32 = Register $cpsr

Legalizing: t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
Legal node: nothing to do

Combining: t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5

Legalizing: t46: i32 = Constant<11>
Legal node: nothing to do

Combining: t46: i32 = Constant<11>

Legalizing: t37: ch = br t49, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
Legal node: nothing to do

Combining: t37: ch = br t49, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5

Legalizing: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
Legal node: nothing to do

Combining: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9

Legalizing: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9

Combining: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9

Legalizing: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
Legal node: nothing to do

Combining: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9

Legalizing: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
Legal node: nothing to do

Combining: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9

Legalizing: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
Legal node: nothing to do

Combining: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9

Legalizing: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
Legal node: nothing to do

Combining: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9

Legalizing: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9

Combining: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9

Legalizing: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
Legal node: nothing to do

Combining: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %7
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %7

Legalizing: t42: i32 = Constant<1>
Legal node: nothing to do

Combining: t42: i32 = Constant<1>

Legalizing: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>
Legal node: nothing to do

Combining: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>

Legalizing: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal node: nothing to do

Combining: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Legalizing: t27: i32 = TargetConstant<-1>

Combining: t27: i32 = TargetConstant<-1>

Legalizing: t25: Untyped = RegisterMask
Legal node: nothing to do

Combining: t25: Untyped = RegisterMask

Legalizing: t24: i32 = TargetExternalSymbol'memset'
Legal node: nothing to do

Combining: t24: i32 = TargetExternalSymbol'memset'

Legalizing: t22: i32 = Register $r2

Combining: t22: i32 = Register $r2

Legalizing: t20: i32 = Register $r1

Combining: t20: i32 = Register $r1

Legalizing: t18: i32 = Register $r0

Combining: t18: i32 = Register $r0

Legalizing: t14: i32 = TargetConstant<0>

Combining: t14: i32 = TargetConstant<0>

Legalizing: t13: i32 = Constant<0>
Legal node: nothing to do

Combining: t13: i32 = Constant<0>

Legalizing: t11: i32 = Constant<2048>
Legal node: nothing to do

Combining: t11: i32 = Constant<2048>

Legalizing: t9: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t9: i32 = FrameIndex<0>

Legalizing: t7: i32 = TargetFrameIndex<0>
Legal node: nothing to do

Combining: t7: i32 = TargetFrameIndex<0>

Legalizing: t1: i32 = Register %7

Combining: t1: i32 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 30 nodes:
  t0: ch = EntryToken
      t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
    t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
  t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9
  t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
  t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9
        t2: i32,ch = CopyFromReg t0, Register:i32 %7
      t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
    t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
  t37: ch = br t49, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t37: ch = br t49, BasicBlock:ch<for.body.preheader 0x558603aa17a0>, loop.c:27:5
ISEL: Starting pattern match
  Morphed node: t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t49, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t49: ch = ARMISD::BRCOND t29:1, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<11>, Register:i32 $cpsr, t47, loop.c:27:5
Creating constant: t50: i32 = TargetConstant<11>
Creating new machine node: t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47, loop.c:27:5

ISEL: Starting selection on root node: t29: i32,ch,glue = CopyFromReg t28, Register:i32 $r0, t28:1, loop.c:24:9

ISEL: Starting selection on root node: t28: ch,glue = callseq_end t26, TargetConstant:i32<0>, TargetConstant:i32<-1>, t26:1, loop.c:24:9
ISEL: Starting pattern match
  Initial Opcode index to 134736
  OpcodeSwitch from 134740 to 134744
Creating constant: t52: i32 = TargetConstant<14>
  Morphed node: t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26, t26:1, loop.c:24:9
ISEL: Match complete!

ISEL: Starting selection on root node: t26: ch,glue = ARMISD::CALL t23, TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23:1, loop.c:24:9
ISEL: Starting pattern match
  Initial Opcode index to 135379
  OpcodeSwitch from 135385 to 135425
  Morphed node: t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9
ISEL: Match complete!

ISEL: Starting selection on root node: t23: ch,glue = CopyToReg t21, Register:i32 $r2, Constant:i32<2048>, t21:1, loop.c:24:9

ISEL: Starting selection on root node: t21: ch,glue = CopyToReg t19, Register:i32 $r1, Constant:i32<0>, t19:1, loop.c:24:9

ISEL: Starting selection on root node: t19: ch,glue = CopyToReg t15, Register:i32 $r0, FrameIndex:i32<0>, loop.c:24:9

ISEL: Starting selection on root node: t15: ch,glue = callseq_start t8, TargetConstant:i32<0>, TargetConstant:i32<0>, loop.c:24:9
ISEL: Starting pattern match
  Initial Opcode index to 134797
  OpcodeSwitch from 134800 to 134804
  Morphed node: t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9
ISEL: Match complete!

ISEL: Starting selection on root node: t47: glue = ARMISD::CMP t2, Constant:i32<1>, loop.c:27:5
ISEL: Starting pattern match
  Initial Opcode index to 131660
  Match failed at index 131670
  Continuing at 131691
  Match failed at index 131692
  Continuing at 131712
  Continuing at 131713
  Match failed at index 131714
  Continuing at 131736
Creating constant: t54: i32 = TargetConstant<1>
  Morphed node: t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %7

ISEL: Starting selection on root node: t48: i32 = Register $cpsr

ISEL: Starting selection on root node: t36: ch = BasicBlock<for.body.preheader 0x558603aa17a0>

ISEL: Starting selection on root node: t34: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

ISEL: Starting selection on root node: t27: i32 = TargetConstant<-1>

ISEL: Starting selection on root node: t25: Untyped = RegisterMask

ISEL: Starting selection on root node: t24: i32 = TargetExternalSymbol'memset'

ISEL: Starting selection on root node: t22: i32 = Register $r2

ISEL: Starting selection on root node: t20: i32 = Register $r1

ISEL: Starting selection on root node: t18: i32 = Register $r0

ISEL: Starting selection on root node: t14: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t13: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 140738
  Match failed at index 140745
  Continuing at 140768
  Morphed node: t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
ISEL: Match complete!

ISEL: Starting selection on root node: t11: i32 = Constant<2048>
ISEL: Starting pattern match
  Initial Opcode index to 140738
  Match failed at index 140745
  Continuing at 140768
Creating constant: t55: i32 = TargetConstant<2048>
  Morphed node: t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
ISEL: Match complete!

ISEL: Starting selection on root node: t9: i32 = FrameIndex<0>

ISEL: Starting selection on root node: t7: i32 = TargetFrameIndex<0>

ISEL: Starting selection on root node: t1: i32 = Register %7

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'dijkstra:entry'
SelectionDAG has 33 nodes:
  t0: ch = EntryToken
      t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5
    t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9
    t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
  t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9
    t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
  t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9
    t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
  t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9
  t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9
  t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9
      t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9
        t2: i32,ch = CopyFromReg t0, Register:i32 %7
      t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5
    t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47:1, loop.c:27:5
  t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t51, loop.c:27:5


Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling %bb.0 'entry' **********
SU(0): t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t51, loop.c:27:5

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47:1, loop.c:27:5

    t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 2
  Depth              : 3
  Height             : 1
  Predecessors:
    SU(3): Ord  Latency=1 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %7

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 2
  Successors:
    SU(1): Data Latency=1
SU(3): t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9

    t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9

    t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9

    t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9

    t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9

    t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9

  # preds left       : 4
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(4): Data Latency=1
    SU(5): Data Latency=1
    SU(7): Ord  Latency=1 Barrier
    SU(6): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(4): t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(5): t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(3): Data Latency=1
SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(8): Ord  Latency=1 Barrier
  Successors:
    SU(3): Ord  Latency=1 Barrier
SU(8): t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(7): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t51, loop.c:27:5


*** Scheduling [0]: SU(0): t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t51, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 1: SU(1): t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47:1, loop.c:27:5

    t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5


*** Scheduling [1]: SU(1): t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47:1, loop.c:27:5

    t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 2: SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %7

Height 2: SU(3): t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9

    t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9

    t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9

    t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9

    t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9

    t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9


*** Scheduling [2]: SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %7


Examining Available:
Height 2: SU(3): t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9

    t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9

    t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9

    t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9

    t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9

    t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9


*** Scheduling [2]: SU(3): t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9

    t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9

    t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9

    t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9

    t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9

    t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9

GPR: 3 / 9

Examining Available:
Height 3: SU(4): t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(5): t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9


*** Scheduling [3]: SU(4): t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 2 / 9

Examining Available:
Height 3: SU(5): t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9


*** Scheduling [4]: SU(5): t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 3: SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9


*** Scheduling [5]: SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 3: SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9


*** Scheduling [6]: SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 7: SU(8): t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5


*** Scheduling [7]: SU(8): t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

*** Final schedule ***
SU(8): t8: ch = lifetime.start<0 to 2048> t0, TargetFrameIndex:i32<0>, loop.c:24:5

SU(7): t15: i32,ch,glue = ADJCALLSTACKDOWN TargetConstant:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, t8, loop.c:24:9

SU(6): t9: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(5): t13: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(4): t11: i32 = MOVi TargetConstant:i32<2048>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(3): t29: i32,ch,glue = CopyFromReg t28:1, Register:i32 $r0, t28:2, loop.c:24:9

    t19: ch,glue = CopyToReg t15:1, Register:i32 $r0, t9, loop.c:24:9

    t21: ch,glue = CopyToReg t19, Register:i32 $r1, t13, t19:1, loop.c:24:9

    t23: ch,glue = CopyToReg t21, Register:i32 $r2, t11, t21:1, loop.c:24:9

    t26: i32,ch,glue = BL TargetExternalSymbol:i32'memset', Register:i32 $r0, Register:i32 $r1, Register:i32 $r2, RegisterMask:Untyped, t23, t23:1, loop.c:24:9

    t28: i32,ch,glue = ADJCALLSTACKUP TargetConstant:i32<0>, TargetConstant:i32<-1>, TargetConstant:i32<14>, Register:i32 $noreg, t26:1, t26:2, loop.c:24:9

SU(2): t2: i32,ch = CopyFromReg t0, Register:i32 %7

SU(1): t51: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<11>, Register:i32 $cpsr, t29:1, t47:1, loop.c:27:5

    t47: i32,glue = CMPri t2, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

SU(0): t37: ch = B BasicBlock:ch<for.body.preheader 0x558603aa17a0>, t51, loop.c:27:5


Total amount of phi nodes to update: 0
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
Creating constant: t3: i32 = Constant<11>
Creating new node: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
Creating new node: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
Creating new node: t7: i32 = add t6, t4, loop.c:27:5
Creating new node: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
Creating new node: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
Creating new node: t13: ch = TokenFactor t9, t12, loop.c:27:5
Creating new node: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Initial selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
            t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
          t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
        t7: i32 = add t6, t4, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
      t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Combining: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Combining: t14: ch = BasicBlock<for.body 0x558603aa1970>

Combining: t13: ch = TokenFactor t9, t12, loop.c:27:5

Combining: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>

Combining: t11: i32 = Register %14

Combining: t10: i32 = FrameIndex<0>

Combining: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

Combining: t8: i32 = Register %0

Combining: t7: i32 = add t6, t4, loop.c:27:5

Combining: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

Combining: t5: i32 = Register %9

Combining: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5

Combining: t3: i32 = Constant<11>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

Combining: t1: i32 = Register %8

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
            t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
          t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
        t7: i32 = add t6, t4, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
      t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5


Legalizing node: t14: ch = BasicBlock<for.body 0x558603aa1970>
Analyzing result type: ch
Legal result type
Legally typed node: t14: ch = BasicBlock<for.body 0x558603aa1970>

Legalizing node: t11: i32 = Register %14
Ignoring node results
Legally typed node: t11: i32 = Register %14

Legalizing node: t10: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t10: i32 = FrameIndex<0>

Legalizing node: t8: i32 = Register %0
Ignoring node results
Legally typed node: t8: i32 = Register %0

Legalizing node: t5: i32 = Register %9
Ignoring node results
Legally typed node: t5: i32 = Register %9

Legalizing node: t3: i32 = Constant<11>
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = Constant<11>

Legalizing node: t1: i32 = Register %8
Ignoring node results
Legally typed node: t1: i32 = Register %8

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

Legalizing node: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
Legal operand
Analyzing operand: t3: i32 = Constant<11>
Legal operand
Legally typed node: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5

Legalizing node: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

Legalizing node: t7: i32 = add t6, t4, loop.c:27:5
Analyzing result type: i32
Legal result type
Analyzing operand: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
Legal operand
Analyzing operand: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
Legal operand
Legally typed node: t7: i32 = add t6, t4, loop.c:27:5

Legalizing node: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t7: i32 = add t6, t4, loop.c:27:5
Legal operand
Legally typed node: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

Legalizing node: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t10: i32 = FrameIndex<0>
Legal operand
Legally typed node: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>

Legalizing node: t13: ch = TokenFactor t9, t12, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
Legal operand
Analyzing operand: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
Legal operand
Legally typed node: t13: ch = TokenFactor t9, t12, loop.c:27:5

Legalizing node: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t13: ch = TokenFactor t9, t12, loop.c:27:5
Legal operand
Analyzing operand: t14: ch = BasicBlock<for.body 0x558603aa1970>
Legal operand
Legally typed node: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Legalizing node: t65535: ch = handlenode t15
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal operand
Legally typed node: t65535: ch = handlenode t15

Type-legalized selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
            t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
          t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
        t7: i32 = add t6, t4, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
      t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Legalizing: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal node: nothing to do

Legalizing: t13: ch = TokenFactor t9, t12, loop.c:27:5
Legal node: nothing to do

Legalizing: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
Legal node: nothing to do

Legalizing: t7: i32 = add t6, t4, loop.c:27:5
Legal node: nothing to do

Legalizing: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
Legal node: nothing to do

Legalizing: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
Legal node: nothing to do

Legalizing: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
Legal node: nothing to do

Legalizing: t14: ch = BasicBlock<for.body 0x558603aa1970>
Legal node: nothing to do

Legalizing: t11: i32 = Register %14

Legalizing: t10: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t8: i32 = Register %0

Legalizing: t5: i32 = Register %9

Legalizing: t3: i32 = Constant<11>
Legal node: nothing to do

Legalizing: t1: i32 = Register %8

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
            t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
          t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
        t7: i32 = add t6, t4, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
      t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Legalizing: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal node: nothing to do

Combining: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Legalizing: t13: ch = TokenFactor t9, t12, loop.c:27:5
Legal node: nothing to do

Combining: t13: ch = TokenFactor t9, t12, loop.c:27:5

Legalizing: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
Legal node: nothing to do

Combining: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

Legalizing: t7: i32 = add t6, t4, loop.c:27:5
Legal node: nothing to do

Combining: t7: i32 = add t6, t4, loop.c:27:5

Legalizing: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
Legal node: nothing to do

Combining: t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5

Legalizing: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
Legal node: nothing to do

Combining: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>

Legalizing: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
Legal node: nothing to do

Combining: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

Legalizing: t14: ch = BasicBlock<for.body 0x558603aa1970>
Legal node: nothing to do

Combining: t14: ch = BasicBlock<for.body 0x558603aa1970>

Legalizing: t11: i32 = Register %14

Combining: t11: i32 = Register %14

Legalizing: t10: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t10: i32 = FrameIndex<0>

Legalizing: t8: i32 = Register %0

Combining: t8: i32 = Register %0

Legalizing: t5: i32 = Register %9

Combining: t5: i32 = Register %9

Legalizing: t3: i32 = Constant<11>
Legal node: nothing to do

Combining: t3: i32 = Constant<11>

Legalizing: t1: i32 = Register %8

Combining: t1: i32 = Register %8

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
            t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
          t4: i32 = shl nsw t2, Constant:i32<11>, loop.c:27:5
        t7: i32 = add t6, t4, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
      t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5


===== Instruction selection begins: %bb.1 'for.body.preheader'

ISEL: Starting selection on root node: t15: ch = br t13, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
ISEL: Starting pattern match
  Initial Opcode index to 141305
  Morphed node: t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t13: ch = TokenFactor t9, t12, loop.c:27:5

ISEL: Starting selection on root node: t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

ISEL: Starting selection on root node: t7: i32 = add t6, t4, loop.c:27:5
ISEL: Starting pattern match
  Initial Opcode index to 10547
  Skipped scope entry (due to false predicate) at index 10554, continuing at 10600
  Skipped scope entry (due to false predicate) at index 10601, continuing at 10648
  Skipped scope entry (due to false predicate) at index 10649, continuing at 10695
  Skipped scope entry (due to false predicate) at index 10696, continuing at 10743
  Skipped scope entry (due to false predicate) at index 10744, continuing at 10790
  Skipped scope entry (due to false predicate) at index 10791, continuing at 10838
  Skipped scope entry (due to false predicate) at index 10839, continuing at 10885
  Skipped scope entry (due to false predicate) at index 10886, continuing at 10933
  Match failed at index 10552
  Continuing at 10934
  Skipped scope entry (due to false predicate) at index 10939, continuing at 10986
  Skipped scope entry (due to false predicate) at index 10987, continuing at 11035
  Skipped scope entry (due to false predicate) at index 11036, continuing at 11083
  Skipped scope entry (due to false predicate) at index 11084, continuing at 11132
  Skipped scope entry (due to false predicate) at index 11133, continuing at 11180
  Skipped scope entry (due to false predicate) at index 11181, continuing at 11229
  Skipped scope entry (due to false predicate) at index 11230, continuing at 11277
  Skipped scope entry (due to false predicate) at index 11278, continuing at 11326
  Match failed at index 10937
  Continuing at 11327
  Skipped scope entry (due to false predicate) at index 11332, continuing at 11361
  Skipped scope entry (due to false predicate) at index 11362, continuing at 11392
  Skipped scope entry (due to false predicate) at index 11393, continuing at 11422
  Skipped scope entry (due to false predicate) at index 11423, continuing at 11453
  Match failed at index 11330
  Continuing at 11454
  Skipped scope entry (due to false predicate) at index 11459, continuing at 11489
  Skipped scope entry (due to false predicate) at index 11490, continuing at 11521
  Skipped scope entry (due to false predicate) at index 11522, continuing at 11552
  Skipped scope entry (due to false predicate) at index 11553, continuing at 11584
  Match failed at index 11457
  Continuing at 11585
  Match failed at index 11588
  Continuing at 11694
  Match failed at index 11697
  Continuing at 11919
  Match failed at index 11923
  Continuing at 12103
  Match failed at index 12106
  Continuing at 12320
  Match failed at index 12324
  Continuing at 12596
  Match failed at index 12599
  Continuing at 12778
  Match failed at index 12781
  Continuing at 12824
  Match failed at index 12827
  Continuing at 13013
  Match failed at index 13020
  Continuing at 13200
  Match failed at index 13206
  Continuing at 13231
  Match failed at index 13234
  Continuing at 13391
  Match failed at index 13397
  Continuing at 13422
  Continuing at 13423
  Match failed at index 13426
  Continuing at 13587
  Match failed at index 13590
  Continuing at 13630
  Match failed at index 13632
  Continuing at 13673
  Match failed at index 13677
  Continuing at 13966
  Match failed at index 13969
  Continuing at 14264
Creating constant: t16: i32 = TargetConstant<90>
Creating constant: t17: i32 = TargetConstant<14>
  Morphed node: t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t12: ch = CopyToReg t0, Register:i32 %14, FrameIndex:i32<0>

ISEL: Starting selection on root node: t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

ISEL: Starting selection on root node: t14: ch = BasicBlock<for.body 0x558603aa1970>

ISEL: Starting selection on root node: t11: i32 = Register %14

ISEL: Starting selection on root node: t10: i32 = FrameIndex<0>
Creating constant: t20: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t8: i32 = Register %0

ISEL: Starting selection on root node: t5: i32 = Register %9

ISEL: Starting selection on root node: t1: i32 = Register %8

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.1 'dijkstra:for.body.preheader'
SelectionDAG has 19 nodes:
  t0: ch = EntryToken
          t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5
          t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5
        t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5
      t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5
        t10: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
      t12: ch = CopyToReg t0, Register:i32 %14, t10
    t13: ch = TokenFactor t9, t12, loop.c:27:5
  t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5


Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling %bb.1 'for.body.preheader' **********
SU(0): t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=0 Barrier
SU(1): t13: ch = TokenFactor t9, t12, loop.c:27:5

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=1 Barrier
    SU(2): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=0 Barrier
SU(2): t12: ch = CopyToReg t0, Register:i32 %14, t10

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 1
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(3): t10: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(2): Data Latency=1
SU(4): t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 1
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(1): Ord  Latency=1 Barrier
SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 2
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(7): Data Latency=1
    SU(6): Data Latency=1
  Successors:
    SU(4): Data Latency=1
SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 3
  Successors:
    SU(5): Data Latency=1
SU(7): t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 3
  Successors:
    SU(5): Data Latency=1

Examining Available:
Height 0: SU(0): t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5


*** Scheduling [0]: SU(0): t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 0: SU(1): t13: ch = TokenFactor t9, t12, loop.c:27:5


*** Scheduling [1]: SU(1): t13: ch = TokenFactor t9, t12, loop.c:27:5


Examining Available:
  Comparing latency of SU (4) depth 2 vs SU (2) depth 1
Height 2: SU(4): t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

Height 2: SU(2): t12: ch = CopyToReg t0, Register:i32 %14, t10

  Comparing latency of SU (4) depth 2 vs SU (2) depth 1

*** Scheduling [2]: SU(4): t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

GPR: 1 / 9

Examining Available:
Height 2: SU(2): t12: ch = CopyToReg t0, Register:i32 %14, t10

Height 3: SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5


*** Scheduling [2]: SU(2): t12: ch = CopyToReg t0, Register:i32 %14, t10

GPR: 2 / 9

Examining Available:
Height 3: SU(3): t10: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Height 3: SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5


*** Scheduling [3]: SU(3): t10: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 3: SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5

*** Hazard in cycle +1, SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5


*** Scheduling [5]: SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 2 / 9

Examining Available:
Height 6: SU(7): t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

Height 6: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5


*** Scheduling [6]: SU(7): t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

GPR: 1 / 9

Examining Available:
Height 6: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5


*** Scheduling [6]: SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

*** Final schedule ***
SU(6): t2: i32,ch = CopyFromReg t0, Register:i32 %8, loop.c:27:5

SU(7): t6: i32,ch = CopyFromReg t0, Register:i32 %9, loop.c:27:5

SU(5): t7: i32 = ADDrsi t6, t2, TargetConstant:i32<90>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:5

SU(3): t10: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(2): t12: ch = CopyToReg t0, Register:i32 %14, t10

SU(4): t9: ch = CopyToReg t0, Register:i32 %0, t7, loop.c:27:5

SU(1): t13: ch = TokenFactor t9, t12, loop.c:27:5

SU(0): t15: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t13, loop.c:27:5


Total amount of phi nodes to update: 3
Node 0 : (0x558603aa1a58, 2147483648)
Node 1 : (0x558603aa1ac0, 2147483662)
Node 2 : (0x558603aa1b28, 2147483655)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Creating constant: t3: i32 = Constant<0>
Creating new node: t4: i32 = undef
Creating new node: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Creating new node: t7: i1 = setcc t5, Constant:i32<0>, seteq:ch, loop.c:28:21
Creating constant: t8: i32 = Constant<1000000>
Creating new node: t9: i32 = select t7, Constant:i32<1000000>, t5, loop.c:28:13
Creating new node: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Creating new node: t12: ch = store<(store (s32) into %ir.lsr.iv1)> t5:1, t9, t11, undef:i32, loop.c:29:20
Creating new node: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
Creating constant: t15: i32 = Constant<-1>
Creating new node: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Creating new node: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
Creating constant: t19: i32 = Constant<4>
Creating new node: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
Creating new node: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
Creating new node: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
Creating new node: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
Creating new node: t26: i1 = setcc t16, Constant:i32<0>, seteq:ch, loop.c:27:23
Creating new node: t27: ch = TokenFactor t18, t22, t25, t12, loop.c:27:5
Creating new node: t29: ch = brcond t27, t26, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t31: ch = br t29, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Initial selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 32 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
  t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
          t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
          t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
            t7: i1 = setcc t5, Constant:i32<0>, seteq:ch, loop.c:28:21
          t9: i32 = select t7, Constant:i32<1000000>, t5, loop.c:28:13
        t12: ch = store<(store (s32) into %ir.lsr.iv1)> t5:1, t9, t11, undef:i32, loop.c:29:20
      t27: ch = TokenFactor t18, t22, t25, t12, loop.c:27:5
      t26: i1 = setcc t16, Constant:i32<0>, seteq:ch, loop.c:27:23
    t29: ch = brcond t27, t26, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t31: ch = br t29, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Combining: t31: ch = br t29, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Combining: t30: ch = BasicBlock<for.body 0x558603aa1970>

Combining: t29: ch = brcond t27, t26, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t32: ch = br_cc t27, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
 ... into: t32: ch = br_cc t27, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Combining: t32: ch = br_cc t27, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Combining: t27: ch = TokenFactor t18, t22, t25, t12, loop.c:27:5

Combining: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23

Combining: t24: i32 = Register %6

Combining: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23

Combining: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23

Combining: t21: i32 = Register %5

Combining: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23

Combining: t19: i32 = Constant<4>

Combining: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Combining: t17: i32 = Register %4

Combining: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23

Combining: t15: i32 = Constant<-1>

Combining: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

Combining: t13: i32 = Register %3

Combining: t12: ch = store<(store (s32) into %ir.lsr.iv1)> t5:1, t9, t11, undef:i32, loop.c:29:20
Creating new node: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t9, t11, undef:i32, loop.c:29:20
Creating new node: t34: ch = TokenFactor t5:1, t33, loop.c:29:20

Replacing.1 t12: ch = store<(store (s32) into %ir.lsr.iv1)> t5:1, t9, t11, undef:i32, loop.c:29:20

With: t34: ch = TokenFactor t5:1, t33, loop.c:29:20
 and 0 other values

Combining: t34: ch = TokenFactor t5:1, t33, loop.c:29:20

Combining: t27: ch = TokenFactor t18, t22, t25, t34, loop.c:27:5
Creating new node: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
 ... into: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5

Combining: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Combining: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23

Combining: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23

Combining: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Combining: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5

Combining: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t9, t11, undef:i32, loop.c:29:20

Combining: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

Combining: t10: i32 = Register %2

Combining: t9: i32 = select t7, Constant:i32<1000000>, t5, loop.c:28:13
Creating new node: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
 ... into: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13

Combining: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20

Combining: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13

Combining: t8: i32 = Constant<1000000>

Combining: t6: ch = seteq

Combining: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13

Combining: t4: i32 = undef

Combining: t3: i32 = Constant<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

Combining: t1: i32 = Register %1

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 30 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
  t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
          t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
          t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
          t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
        t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20
      t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
    t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5


Legalizing node: t30: ch = BasicBlock<for.body 0x558603aa1970>
Analyzing result type: ch
Legal result type
Legally typed node: t30: ch = BasicBlock<for.body 0x558603aa1970>

Legalizing node: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Analyzing result type: ch
Legal result type
Legally typed node: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Legalizing node: t24: i32 = Register %6
Ignoring node results
Legally typed node: t24: i32 = Register %6

Legalizing node: t21: i32 = Register %5
Ignoring node results
Legally typed node: t21: i32 = Register %5

Legalizing node: t19: i32 = Constant<4>
Analyzing result type: i32
Legal result type
Legally typed node: t19: i32 = Constant<4>

Legalizing node: t17: i32 = Register %4
Ignoring node results
Legally typed node: t17: i32 = Register %4

Legalizing node: t15: i32 = Constant<-1>
Analyzing result type: i32
Legal result type
Legally typed node: t15: i32 = Constant<-1>

Legalizing node: t13: i32 = Register %3
Ignoring node results
Legally typed node: t13: i32 = Register %3

Legalizing node: t10: i32 = Register %2
Ignoring node results
Legally typed node: t10: i32 = Register %2

Legalizing node: t8: i32 = Constant<1000000>
Analyzing result type: i32
Legal result type
Legally typed node: t8: i32 = Constant<1000000>

Legalizing node: t6: ch = seteq
Analyzing result type: ch
Legal result type
Legally typed node: t6: ch = seteq

Legalizing node: t4: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t4: i32 = undef

Legalizing node: t3: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t3: i32 = Constant<0>

Legalizing node: t1: i32 = Register %1
Ignoring node results
Legally typed node: t1: i32 = Register %1

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

Legalizing node: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Legal operand
Analyzing operand: t4: i32 = undef
Legal operand
Legally typed node: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13

Legalizing node: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
Analyzing result type: i32
Legal result type
Analyzing operand: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Legal operand
Analyzing operand: t3: i32 = Constant<0>
Legal operand
Analyzing operand: t8: i32 = Constant<1000000>
Legal operand
Analyzing operand: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Legal operand
Analyzing operand: t6: ch = seteq
Legal operand
Legally typed node: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13

Legalizing node: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Legal operand
Analyzing operand: t19: i32 = Constant<4>
Legal operand
Legally typed node: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23

Legalizing node: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
Legal operand
Legally typed node: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23

Legalizing node: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

Legalizing node: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
Analyzing result type: i32
Legal result type
Analyzing operand: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Legal operand
Analyzing operand: t19: i32 = Constant<4>
Legal operand
Legally typed node: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23

Legalizing node: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
Legal operand
Legally typed node: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23

Legalizing node: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
Legal operand
Analyzing operand: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Legal operand
Analyzing operand: t4: i32 = undef
Legal operand
Legally typed node: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20

Legalizing node: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

Legalizing node: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Analyzing result type: i32
Legal result type
Analyzing operand: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
Legal operand
Analyzing operand: t15: i32 = Constant<-1>
Legal operand
Legally typed node: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23

Legalizing node: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Legal operand
Legally typed node: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Legalizing node: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
Legal operand
Analyzing operand: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
Legal operand
Analyzing operand: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
Legal operand
Analyzing operand: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Legal operand
Analyzing operand: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20
Legal operand
Legally typed node: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5

Legalizing node: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
Legal operand
Analyzing operand: t6: ch = seteq
Legal operand
Analyzing operand: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Legal operand
Analyzing operand: t3: i32 = Constant<0>
Legal operand
Analyzing operand: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal operand
Legally typed node: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5

Legalizing node: t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Analyzing result type: ch
Legal result type
Analyzing operand: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Legal operand
Analyzing operand: t30: ch = BasicBlock<for.body 0x558603aa1970>
Legal operand
Legally typed node: t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Legalizing node: t65535: ch = handlenode t31
Analyzing result type: ch
Legal result type
Analyzing operand: t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal operand
Legally typed node: t65535: ch = handlenode t31

Type-legalized selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 30 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
  t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
          t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
          t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
          t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
        t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20
      t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
    t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
  t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Legalizing: t31: ch = br t32, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal node: nothing to do

Legalizing: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Trying custom legalization
Lowering node: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
Creating new node: t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
Creating new node: t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
Successfully custom legalized node
 ... replacing: t32: ch = br_cc t35, seteq:ch, t16, Constant:i32<0>, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, loop.c:27:5
     with:      t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5

Legalizing: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
Legal node: nothing to do

Legalizing: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t36, t11, undef:i32, loop.c:29:20
Legalizing store operation
Optimizing float store operations
Legal store

Legalizing: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
Legal node: nothing to do

Legalizing: t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
Legal node: nothing to do

Legalizing: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
Trying custom legalization
Lowering node: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
Creating new node: t40: glue = ARMISD::CMPZ t5, Constant:i32<0>, loop.c:28:13
Creating new node: t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
Successfully custom legalized node
 ... replacing: t36: i32 = select_cc t5, Constant:i32<0>, Constant:i32<1000000>, t5, seteq:ch, loop.c:28:13
     with:      t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13

Legalizing: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
Legal node: nothing to do

Legalizing: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Legal node: nothing to do

Legalizing: t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
Legal node: nothing to do

Legalizing: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Legalizing non-extending load operation

Legalizing: t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
Legal node: nothing to do

Legalizing: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
Legal node: nothing to do

Legalizing: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Legal node: nothing to do

Legalizing: t30: ch = BasicBlock<for.body 0x558603aa1970>
Legal node: nothing to do

Legalizing: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal node: nothing to do

Legalizing: t24: i32 = Register %6

Legalizing: t21: i32 = Register %5

Legalizing: t19: i32 = Constant<4>
Legal node: nothing to do

Legalizing: t17: i32 = Register %4

Legalizing: t15: i32 = Constant<-1>
Legal node: nothing to do

Legalizing: t13: i32 = Register %3

Legalizing: t10: i32 = Register %2

Legalizing: t8: i32 = Constant<1000000>
Legal node: nothing to do

Legalizing: t4: i32 = undef
Legal node: nothing to do

Legalizing: t3: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t1: i32 = Register %1

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Legalizing: t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
Legal node: nothing to do

Legalizing: t40: glue = ARMISD::CMPZ t5, Constant:i32<0>, loop.c:28:13
Legal node: nothing to do

Legalizing: t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
Legal node: nothing to do

Legalizing: t38: i32 = Register $cpsr

Legalizing: t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
Legal node: nothing to do
Legalized selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 32 nodes:
  t0: ch = EntryToken
  t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
  t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
          t20: i32 = add t11, Constant:i32<4>, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t20, loop.c:27:23
          t23: i32 = add t2, Constant:i32<4>, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
            t40: glue = ARMISD::CMPZ t5, Constant:i32<0>, loop.c:28:13
          t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
        t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t41, t11, undef:i32, loop.c:29:20
      t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
      t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
    t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
  t31: ch = br t39, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5



Legalizing: t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
Legal node: nothing to do

Combining: t41: i32 = ARMISD::CMOV t5, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13

Legalizing: t40: glue = ARMISD::CMPZ t5, Constant:i32<0>, loop.c:28:13
Legal node: nothing to do

Combining: t40: glue = ARMISD::CMPZ t5, Constant:i32<0>, loop.c:28:13

Legalizing: t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
Legal node: nothing to do

Combining: t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5

Legalizing: t38: i32 = Register $cpsr

Combining: t38: i32 = Register $cpsr

Legalizing: t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
Legal node: nothing to do

Combining: t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5

Legalizing: t31: ch = br t39, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
Legal node: nothing to do

Combining: t31: ch = br t39, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5

Legalizing: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5
Legal node: nothing to do

Combining: t35: ch = TokenFactor t18, t22, t25, t5:1, t33, loop.c:27:5

Legalizing: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t41, t11, undef:i32, loop.c:29:20
Legalizing store operation
Optimizing float store operations
Legal store

Combining: t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t41, t11, undef:i32, loop.c:29:20
Creating new node: t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20

Replacing.5 t33: ch = store<(store (s32) into %ir.lsr.iv1)> t0, t41, t11, undef:i32, loop.c:29:20

With: t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20


Legalizing: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
Legal node: nothing to do

Combining: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Legalizing: t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23
Legal node: nothing to do

Combining: t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

Legalizing: t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20
Legalizing store operation
Legal store

Combining: t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20

Legalizing: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23
Legal node: nothing to do

Combining: t25: ch = CopyToReg t0, Register:i32 %6, t23, loop.c:27:23

Legalizing: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
Legal node: nothing to do

Combining: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23

Legalizing: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Legalizing non-extending load operation

Combining: t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13
Creating new node: t43: i32,i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39), <post-inc>> t0, t2, Constant:i32<4>, loop.c:28:13

Replacing.5 t5: i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39)> t0, t2, undef:i32, loop.c:28:13

With: t43: i32,i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39), <post-inc>> t0, t2, Constant:i32<4>, loop.c:28:13


Legalizing: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
Legal node: nothing to do

Combining: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

Legalizing: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
Legal node: nothing to do

Combining: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

Legalizing: t30: ch = BasicBlock<for.body 0x558603aa1970>
Legal node: nothing to do

Combining: t30: ch = BasicBlock<for.body 0x558603aa1970>

Legalizing: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>
Legal node: nothing to do

Combining: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

Legalizing: t24: i32 = Register %6

Combining: t24: i32 = Register %6

Legalizing: t21: i32 = Register %5

Combining: t21: i32 = Register %5

Legalizing: t19: i32 = Constant<4>
Legal node: nothing to do

Combining: t19: i32 = Constant<4>

Legalizing: t17: i32 = Register %4

Combining: t17: i32 = Register %4

Legalizing: t15: i32 = Constant<-1>
Legal node: nothing to do

Combining: t15: i32 = Constant<-1>

Legalizing: t13: i32 = Register %3

Combining: t13: i32 = Register %3

Legalizing: t10: i32 = Register %2

Combining: t10: i32 = Register %2

Legalizing: t8: i32 = Constant<1000000>
Legal node: nothing to do

Combining: t8: i32 = Constant<1000000>

Legalizing: t3: i32 = Constant<0>
Legal node: nothing to do

Combining: t3: i32 = Constant<0>

Legalizing: t1: i32 = Register %1

Combining: t1: i32 = Register %1

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 29 nodes:
  t0: ch = EntryToken
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
      t40: glue = ARMISD::CMPZ t43, Constant:i32<0>, loop.c:28:13
    t41: i32 = ARMISD::CMOV t43, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
    t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
  t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20
    t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t43: i32,i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39), <post-inc>> t0, t2, Constant:i32<4>, loop.c:28:13
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t43:1, loop.c:27:23
      t35: ch = TokenFactor t18, t22, t25, t43:2, t42:1, loop.c:27:5
      t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
    t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
  t31: ch = br t39, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5


===== Instruction selection begins: %bb.3 'for.body'

ISEL: Starting selection on root node: t31: ch = br t39, BasicBlock:ch<for.body 0x558603aa1970>, loop.c:27:5
ISEL: Starting pattern match
  Initial Opcode index to 141305
  Morphed node: t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t39, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t39: ch = ARMISD::BRCOND t35, BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, Constant:i32<0>, Register:i32 $cpsr, t37, loop.c:27:5
Creating constant: t44: i32 = TargetConstant<0>
Creating new machine node: t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37, loop.c:27:5

ISEL: Starting selection on root node: t35: ch = TokenFactor t18, t22, t25, t43:2, t42:1, loop.c:27:5

ISEL: Starting selection on root node: t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

ISEL: Starting selection on root node: t42: i32,ch = store<(store (s32) into %ir.lsr.iv1), <post-inc>> t0, t41, t11, Constant:i32<4>, loop.c:29:20
ISEL: Starting pattern match
  Initial Opcode index to 90585
  Match failed at index 90591
  Continuing at 91062
  Match failed at index 91072
  Continuing at 91156
  Match failed at index 91176
  Continuing at 91198
Creating constant: t47: i32 = TargetConstant<4>
Creating constant: t48: i32 = TargetConstant<14>
  Morphed node: t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20
ISEL: Match complete!

ISEL: Starting selection on root node: t41: i32 = ARMISD::CMOV t43, Constant:i32<1000000>, Constant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
ISEL: Starting pattern match
  Initial Opcode index to 102634
  Match failed at index 102644
  Continuing at 102662
  Match failed at index 102663
  Continuing at 102690
  Match failed at index 102691
  Continuing at 102718
  Match failed at index 102719
  Continuing at 102779
  Match failed at index 102787
  Continuing at 102804
  Match failed at index 102806
  Continuing at 102831
  Match failed at index 102834
  Continuing at 102861
  Match failed at index 102863
  Continuing at 102888
  Match failed at index 102891
  Continuing at 102918
  Match failed at index 102920
  Continuing at 102945
  Match failed at index 102952
  Continuing at 103131
  Skipped scope entry (due to false predicate) at index 103143, continuing at 103166
  Skipped scope entry (due to false predicate) at index 103167, continuing at 103190
  Skipped scope entry (due to false predicate) at index 103191, continuing at 103217
  Skipped scope entry (due to false predicate) at index 103218, continuing at 103241
  Skipped scope entry (due to false predicate) at index 103242, continuing at 103265
  Skipped scope entry (due to false predicate) at index 103266, continuing at 103292
  Skipped scope entry (due to false predicate) at index 103299, continuing at 103316
  Skipped scope entry (due to false predicate) at index 103317, continuing at 103334
  Match failed at index 103297
  Continuing at 103335
  Continuing at 103336
  Morphed node: t41: i32 = MOVCCr t43, Constant:i32<1000000>, TargetConstant:i32<0>, Register:i32 $cpsr, t40, loop.c:28:13
ISEL: Match complete!

ISEL: Starting selection on root node: t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

ISEL: Starting selection on root node: t37: glue = ARMISD::CMPZ t16, Constant:i32<0>, loop.c:27:5
ISEL: Starting pattern match
  Initial Opcode index to 101291
  Match failed at index 101294
  Continuing at 101416
  Match failed at index 101421
  Continuing at 101451
  Match failed at index 101454
  Continuing at 101701
  Match failed at index 101706
  Continuing at 101761
  Match failed at index 101764
  Continuing at 101970
  Match failed at index 101979
  Continuing at 102000
  Match failed at index 102001
  Continuing at 102022
  Match failed at index 102023
  Continuing at 102043
  Continuing at 102044
  Match failed at index 102046
  Continuing at 102130
  Match failed at index 102135
  Continuing at 102157
  Match failed at index 102159
  Continuing at 102221
  Match failed at index 102232
  Continuing at 102252
  Match failed at index 102253
  Continuing at 102275
  Continuing at 102276
  Match failed at index 102278
  Continuing at 102344
  Continuing at 102345
  Match failed at index 102347
  Continuing at 102416
  Morphed node: t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5
ISEL: Match complete!

ISEL: Starting selection on root node: t40: glue = ARMISD::CMPZ t43, Constant:i32<0>, loop.c:28:13
ISEL: Starting pattern match
  Initial Opcode index to 101291
  Match failed at index 101294
  Continuing at 101416
  Match failed at index 101421
  Continuing at 101451
  Match failed at index 101454
  Continuing at 101701
  Match failed at index 101706
  Continuing at 101761
  Match failed at index 101764
  Continuing at 101970
  Match failed at index 101979
  Continuing at 102000
  Match failed at index 102001
  Continuing at 102022
  Match failed at index 102023
  Continuing at 102043
  Continuing at 102044
  Match failed at index 102046
  Continuing at 102130
  Match failed at index 102135
  Continuing at 102157
  Match failed at index 102159
  Continuing at 102221
  Match failed at index 102232
  Continuing at 102252
  Match failed at index 102253
  Continuing at 102275
  Continuing at 102276
  Match failed at index 102278
  Continuing at 102344
  Continuing at 102345
  Match failed at index 102347
  Continuing at 102416
  Morphed node: t40: i32,glue = CMPri t43, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13
ISEL: Match complete!

ISEL: Starting selection on root node: t25: ch = CopyToReg t0, Register:i32 %6, t43:1, loop.c:27:23

ISEL: Starting selection on root node: t16: i32 = add t14, Constant:i32<-1>, loop.c:27:23
ISEL: Starting pattern match
  Initial Opcode index to 10547
  Skipped scope entry (due to false predicate) at index 10554, continuing at 10600
  Skipped scope entry (due to false predicate) at index 10601, continuing at 10648
  Skipped scope entry (due to false predicate) at index 10649, continuing at 10695
  Skipped scope entry (due to false predicate) at index 10696, continuing at 10743
  Skipped scope entry (due to false predicate) at index 10744, continuing at 10790
  Skipped scope entry (due to false predicate) at index 10791, continuing at 10838
  Skipped scope entry (due to false predicate) at index 10839, continuing at 10885
  Skipped scope entry (due to false predicate) at index 10886, continuing at 10933
  Match failed at index 10552
  Continuing at 10934
  Skipped scope entry (due to false predicate) at index 10939, continuing at 10986
  Skipped scope entry (due to false predicate) at index 10987, continuing at 11035
  Skipped scope entry (due to false predicate) at index 11036, continuing at 11083
  Skipped scope entry (due to false predicate) at index 11084, continuing at 11132
  Skipped scope entry (due to false predicate) at index 11133, continuing at 11180
  Skipped scope entry (due to false predicate) at index 11181, continuing at 11229
  Skipped scope entry (due to false predicate) at index 11230, continuing at 11277
  Skipped scope entry (due to false predicate) at index 11278, continuing at 11326
  Match failed at index 10937
  Continuing at 11327
  Skipped scope entry (due to false predicate) at index 11332, continuing at 11361
  Skipped scope entry (due to false predicate) at index 11362, continuing at 11392
  Skipped scope entry (due to false predicate) at index 11393, continuing at 11422
  Skipped scope entry (due to false predicate) at index 11423, continuing at 11453
  Match failed at index 11330
  Continuing at 11454
  Skipped scope entry (due to false predicate) at index 11459, continuing at 11489
  Skipped scope entry (due to false predicate) at index 11490, continuing at 11521
  Skipped scope entry (due to false predicate) at index 11522, continuing at 11552
  Skipped scope entry (due to false predicate) at index 11553, continuing at 11584
  Match failed at index 11457
  Continuing at 11585
  Match failed at index 11588
  Continuing at 11694
  Match failed at index 11697
  Continuing at 11919
  Match failed at index 11923
  Continuing at 12103
  Match failed at index 12106
  Continuing at 12320
  Match failed at index 12324
  Continuing at 12596
  Match failed at index 12599
  Continuing at 12778
  Match failed at index 12781
  Continuing at 12824
  Match failed at index 12827
  Continuing at 13013
  Match failed at index 13020
  Continuing at 13200
  Match failed at index 13206
  Continuing at 13231
  Match failed at index 13234
  Continuing at 13391
  Match failed at index 13397
  Continuing at 13422
  Continuing at 13423
  Match failed at index 13426
  Continuing at 13587
  Match failed at index 13590
  Continuing at 13630
  Match failed at index 13632
  Continuing at 13673
  Match failed at index 13677
  Continuing at 13966
  Match failed at index 13969
  Continuing at 14264
  Match failed at index 14274
  Continuing at 14298
  Match failed at index 14300
  Continuing at 14343
  Match failed at index 14347
  Continuing at 14373
  Match failed at index 14375
  Continuing at 14418
  Match failed at index 14424
  Continuing at 14448
  Continuing at 14449
  Match failed at index 14451
  Continuing at 14495
  Match failed at index 14500
  Continuing at 14526
  Match failed at index 14528
  Continuing at 14572
  Match failed at index 14575
  Continuing at 14675
  Match failed at index 14677
  Continuing at 14756
  Match failed at index 14759
  Continuing at 14797
  Match failed at index 14800
  Continuing at 14982
  Match failed at index 14989
  Continuing at 15124
  Match failed at index 15135
  Continuing at 15162
  Match failed at index 15164
  Continuing at 15199
  Continuing at 15200
  Match failed at index 15202
  Continuing at 15261
  Skipped scope entry (due to false predicate) at index 15271, continuing at 15300
Creating constant: t49: i32 = TargetConstant<-1>
Creating constant: t50: i32 = TargetConstant<1>
  Morphed node: t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23
ISEL: Match complete!

ISEL: Starting selection on root node: t43: i32,i32,ch = load<(load (s32) from %ir.lsr.iv3, !tbaa !39), <post-inc>> t0, t2, Constant:i32<4>, loop.c:28:13
Creating new machine node: t51: i32,i32,ch = LDR_POST_IMM t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13

ISEL: Starting selection on root node: t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

ISEL: Starting selection on root node: t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

ISEL: Starting selection on root node: t38: i32 = Register $cpsr

ISEL: Starting selection on root node: t30: ch = BasicBlock<for.body 0x558603aa1970>

ISEL: Starting selection on root node: t28: ch = BasicBlock<for.cond.cleanup 0x558603aa1888>

ISEL: Starting selection on root node: t24: i32 = Register %6

ISEL: Starting selection on root node: t21: i32 = Register %5

ISEL: Starting selection on root node: t17: i32 = Register %4

ISEL: Starting selection on root node: t13: i32 = Register %3

ISEL: Starting selection on root node: t10: i32 = Register %2

ISEL: Starting selection on root node: t8: i32 = Constant<1000000>
ISEL: Starting pattern match
  Initial Opcode index to 140738
  Skipped scope entry (due to false predicate) at index 140743, continuing at 140768
  Skipped scope entry (due to false predicate) at index 140769, continuing at 140794
  Skipped scope entry (due to false predicate) at index 140795, continuing at 140816
  Skipped scope entry (due to false predicate) at index 140817, continuing at 140845
Creating constant: t52: i32 = TargetConstant<1000000>
  Morphed node: t8: i32 = MOVi32imm TargetConstant:i32<1000000>
ISEL: Match complete!

ISEL: Starting selection on root node: t1: i32 = Register %1

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.3 'dijkstra:for.body'
SelectionDAG has 33 nodes:
  t0: ch = EntryToken
    t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23
  t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23
      t8: i32 = MOVi32imm TargetConstant:i32<1000000>
      t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13
    t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13
    t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20
  t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20
  t49: i32 = TargetConstant<-1>
    t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13
  t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13
        t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23
        t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23
        t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23
      t35: ch = TokenFactor t18, t22, t25, t51:2, t42:1, loop.c:27:5
      t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5
    t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37:1, loop.c:27:5
  t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t45, loop.c:27:5


Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling %bb.3 'for.body' **********
SU(0): t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t45, loop.c:27:5

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 9
  Height             : 0
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
SU(1): t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37:1, loop.c:27:5

    t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 2
  Depth              : 8
  Height             : 1
  Predecessors:
    SU(4): Ord  Latency=0 Barrier
    SU(2): Data Latency=1
  Successors:
    SU(0): Ord  Latency=1 Barrier
SU(2): t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 3
  Predecessors:
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=1
    SU(13): Data Latency=1
SU(3): t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(2): Data Latency=1
SU(4): t35: ch = TokenFactor t18, t22, t25, t51:2, t42:1, loop.c:27:5

  # preds left       : 5
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 8
  Height             : 1
  Predecessors:
    SU(13): Ord  Latency=1 Barrier
    SU(12): Ord  Latency=1 Barrier
    SU(11): Ord  Latency=1 Barrier
    SU(9): Ord  Latency=1 Barrier
    SU(5): Ord  Latency=1 Barrier
  Successors:
    SU(1): Ord  Latency=0 Barrier
SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20

  # preds left       : 2
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 6
  Height             : 3
  Predecessors:
    SU(7): Data Latency=2
    SU(6): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(12): Data Latency=1
SU(6): t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 4
  Successors:
    SU(5): Data Latency=1
SU(7): t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13

    t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 2
  Depth              : 4
  Height             : 5
  Predecessors:
    SU(9): Data Latency=3
    SU(8): Data Latency=2
  Successors:
    SU(5): Data Latency=2
SU(8): t8: i32 = MOVi32imm TargetConstant:i32<1000000>

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 2
  Depth              : 0
  Height             : 7
  Successors:
    SU(7): Data Latency=2
SU(9): t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13

  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 1
  Latency            : 1
  Depth              : 1
  Height             : 8
  Predecessors:
    SU(10): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
    SU(7): Data Latency=3
    SU(11): Data Latency=1
SU(10): t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 9
  Successors:
    SU(9): Data Latency=1
SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(9): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(12): t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 2
  Predecessors:
    SU(5): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier
SU(13): t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1
  Successors:
    SU(4): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t45, loop.c:27:5


*** Scheduling [0]: SU(0): t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t45, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 1: SU(1): t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37:1, loop.c:27:5

    t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5


*** Scheduling [1]: SU(1): t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37:1, loop.c:27:5

    t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 1: SU(4): t35: ch = TokenFactor t18, t22, t25, t51:2, t42:1, loop.c:27:5


*** Scheduling [2]: SU(4): t35: ch = TokenFactor t18, t22, t25, t51:2, t42:1, loop.c:27:5

GPR: 1 / 9

Examining Available:
  Comparing latency of SU (13) depth 2 vs SU (12) depth 7
  Comparing latency of SU (12) depth 7 vs SU (11) depth 2
Height 3: SU(12): t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

Height 3: SU(13): t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Height 3: SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

  Comparing latency of SU (13) depth 2 vs SU (12) depth 7
  Comparing latency of SU (12) depth 7 vs SU (11) depth 2

*** Scheduling [3]: SU(12): t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

GPR: 2 / 9

Examining Available:
Height 3: SU(13): t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

Height 3: SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

Height 4: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20


*** Scheduling [3]: SU(13): t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

GPR: 2 / 9

Examining Available:
Height 3: SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

Height 4: SU(2): t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23

Height 4: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20


*** Scheduling [3]: SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

GPR: 3 / 9

Examining Available:
Height 4: SU(2): t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23

Height 4: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20


*** Scheduling [4]: SU(2): t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 3 / 9

Examining Available:
Height 5: SU(3): t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

Height 4: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20


*** Scheduling [5]: SU(3): t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

GPR: 2 / 9

Examining Available:
Height 4: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20


*** Scheduling [5]: SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 3 / 9

Examining Available:
Height 6: SU(6): t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

Height 7: SU(7): t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13

    t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13


*** Scheduling [6]: SU(6): t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

GPR: 2 / 9

Examining Available:
Height 7: SU(7): t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13

    t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13


*** Scheduling [7]: SU(7): t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13

    t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 2 / 9

Examining Available:
Height 9: SU(8): t8: i32 = MOVi32imm TargetConstant:i32<1000000>

Height 10: SU(9): t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13


*** Scheduling [9]: SU(8): t8: i32 = MOVi32imm TargetConstant:i32<1000000>

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 10: SU(9): t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13


*** Scheduling [10]: SU(9): t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001

Examining Available:
Height 11: SU(10): t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13


*** Scheduling [11]: SU(10): t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

  SU(10) has too many regdefs
*** Final schedule ***
SU(10): t2: i32,ch = CopyFromReg t0, Register:i32 %1, loop.c:28:13

SU(9): t51: i32,i32,ch = LDR_POST_IMM<Mem:(load (s32) from %ir.lsr.iv3, !tbaa !39)> t2, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:28:13

SU(8): t8: i32 = MOVi32imm TargetConstant:i32<1000000>

SU(7): t41: i32 = MOVCCr t51, t8, TargetConstant:i32<0>, Register:i32 $cpsr, t40:1, loop.c:28:13

    t40: i32,glue = CMPri t51, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:28:13

SU(6): t11: i32,ch = CopyFromReg t0, Register:i32 %2, loop.c:29:20

SU(5): t42: i32,ch = STR_POST_IMM<Mem:(store (s32) into %ir.lsr.iv1)> t41, t11, Register:i32 $noreg, TargetConstant:i32<4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:29:20

SU(3): t14: i32,ch = CopyFromReg t0, Register:i32 %3, loop.c:27:23

SU(2): t16: i32 = SUBri t14, TargetConstant:i32<1>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:27:23

SU(11): t25: ch = CopyToReg t0, Register:i32 %6, t51:1, loop.c:27:23

SU(13): t18: ch = CopyToReg t0, Register:i32 %4, t16, loop.c:27:23

SU(12): t22: ch = CopyToReg t0, Register:i32 %5, t42, loop.c:27:23

SU(4): t35: ch = TokenFactor t18, t22, t25, t51:2, t42:1, loop.c:27:5

SU(1): t45: ch,glue = Bcc BasicBlock:ch<for.cond.cleanup 0x558603aa1888>, TargetConstant:i32<0>, Register:i32 $cpsr, t35, t37:1, loop.c:27:5

    t37: i32,glue = CMPri t16, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, loop.c:27:5

SU(0): t31: ch = B BasicBlock:ch<for.body 0x558603aa1970>, t45, loop.c:27:5


Total amount of phi nodes to update: 3
Node 0 : (0x558603aa1a58, 2147483654)
Node 1 : (0x558603aa1ac0, 2147483653)
Node 2 : (0x558603aa1b28, 2147483652)
Creating new node: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
Creating constant: t3: i32 = Constant<-1>
Creating new node: t4: i32 = add nsw t2, Constant:i32<-1>, loop.c:34:17
Creating constant: t6: i32 = Constant<2>
Creating new node: t7: i32 = shl t4, Constant:i32<2>, loop.c:34:12
Creating new node: t8: i32 = add FrameIndex:i32<0>, t7, loop.c:34:12
Creating constant: t9: i32 = Constant<0>
Creating new node: t10: i32 = undef
Creating new node: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t8, undef:i32, loop.c:34:12
Creating new node: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
isHA: 0 i32
Creating new node: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Creating new node: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
Initial selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 17 nodes:
  t0: ch = EntryToken
  t9: i32 = Constant<0>
          t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
        t4: i32 = add nsw t2, Constant:i32<-1>, loop.c:34:17
      t7: i32 = shl t4, Constant:i32<2>, loop.c:34:12
    t8: i32 = add FrameIndex:i32<0>, t7, loop.c:34:12
  t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t8, undef:i32, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5



Combining: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5

Combining: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

Combining: t14: i32 = Register $r0

Combining: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

Combining: t12: i32 = TargetFrameIndex<0>

Combining: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t8, undef:i32, loop.c:34:12

Combining: t10: i32 = undef

Combining: t8: i32 = add FrameIndex:i32<0>, t7, loop.c:34:12

Combining: t7: i32 = shl t4, Constant:i32<2>, loop.c:34:12
Creating new node: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
Creating constant: t18: i32 = Constant<-4>
Creating new node: t19: i32 = add t17, Constant:i32<-4>, loop.c:34:12
 ... into: t19: i32 = add t17, Constant:i32<-4>, loop.c:34:12

Combining: t8: i32 = add FrameIndex:i32<0>, t19, loop.c:34:12
Creating new node: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
Creating new node: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
 ... into: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12

Combining: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12

Combining: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12

Combining: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12

Combining: t18: i32 = Constant<-4>

Combining: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17

Combining: t6: i32 = Constant<2>

Combining: t5: i32 = FrameIndex<0>

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

Combining: t1: i32 = Register %7

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
        t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
      t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
    t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
  t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5


Legalizing node: t18: i32 = Constant<-4>
Analyzing result type: i32
Legal result type
Legally typed node: t18: i32 = Constant<-4>

Legalizing node: t14: i32 = Register $r0
Ignoring node results
Legally typed node: t14: i32 = Register $r0

Legalizing node: t12: i32 = TargetFrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t12: i32 = TargetFrameIndex<0>

Legalizing node: t10: i32 = undef
Analyzing result type: i32
Legal result type
Legally typed node: t10: i32 = undef

Legalizing node: t6: i32 = Constant<2>
Analyzing result type: i32
Legal result type
Legally typed node: t6: i32 = Constant<2>

Legalizing node: t5: i32 = FrameIndex<0>
Analyzing result type: i32
Legal result type
Legally typed node: t5: i32 = FrameIndex<0>

Legalizing node: t1: i32 = Register %7
Ignoring node results
Legally typed node: t1: i32 = Register %7

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Legally typed node: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

Legalizing node: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
Analyzing result type: i32
Legal result type
Analyzing operand: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
Legal operand
Analyzing operand: t6: i32 = Constant<2>
Legal operand
Legally typed node: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17

Legalizing node: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
Analyzing result type: i32
Legal result type
Analyzing operand: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
Legal operand
Analyzing operand: t5: i32 = FrameIndex<0>
Legal operand
Legally typed node: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12

Legalizing node: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
Analyzing result type: i32
Legal result type
Analyzing operand: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
Legal operand
Analyzing operand: t18: i32 = Constant<-4>
Legal operand
Legally typed node: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12

Legalizing node: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
Analyzing result type: i32
Legal result type
Analyzing result type: ch
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
Legal operand
Analyzing operand: t10: i32 = undef
Legal operand
Legally typed node: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12

Legalizing node: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
Analyzing result type: ch
Legal result type
Analyzing operand: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
Legal operand
Analyzing operand: t12: i32 = TargetFrameIndex<0>
Legal operand
Legally typed node: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

Legalizing node: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
Legal operand
Analyzing operand: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
Legal operand
Legally typed node: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

Legalizing node: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
Analyzing result type: ch
Legal result type
Analyzing operand: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Legal operand
Analyzing operand: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Legal operand
Legally typed node: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5

Legalizing node: t65535: ch = handlenode t16
Analyzing result type: ch
Legal result type
Analyzing operand: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
Legal operand
Legally typed node: t65535: ch = handlenode t16

Type-legalized selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
        t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
      t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
    t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
  t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5



Legalizing: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
Legal node: nothing to do

Legalizing: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Legal node: nothing to do

Legalizing: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
Legal node: nothing to do

Legalizing: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
Legalizing non-extending load operation

Legalizing: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
Legal node: nothing to do

Legalizing: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
Legal node: nothing to do

Legalizing: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
Legal node: nothing to do

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
Legal node: nothing to do

Legalizing: t18: i32 = Constant<-4>
Legal node: nothing to do

Legalizing: t14: i32 = Register $r0

Legalizing: t12: i32 = TargetFrameIndex<0>
Legal node: nothing to do

Legalizing: t10: i32 = undef
Legal node: nothing to do

Legalizing: t6: i32 = Constant<2>
Legal node: nothing to do

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Legalizing: t1: i32 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
        t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
      t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
    t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
  t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5



Legalizing: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
Legal node: nothing to do

Combining: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5

Legalizing: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
Legal node: nothing to do

Combining: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

Legalizing: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
Legal node: nothing to do

Combining: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

Legalizing: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
Legalizing non-extending load operation

Combining: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12

Legalizing: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
Legal node: nothing to do

Combining: t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12

Legalizing: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
Legal node: nothing to do

Combining: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12

Legalizing: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
Legal node: nothing to do

Combining: t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17

Legalizing: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
Legal node: nothing to do

Combining: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

Legalizing: t18: i32 = Constant<-4>
Legal node: nothing to do

Combining: t18: i32 = Constant<-4>

Legalizing: t14: i32 = Register $r0

Combining: t14: i32 = Register $r0

Legalizing: t12: i32 = TargetFrameIndex<0>
Legal node: nothing to do

Combining: t12: i32 = TargetFrameIndex<0>

Legalizing: t10: i32 = undef
Legal node: nothing to do

Combining: t10: i32 = undef

Legalizing: t6: i32 = Constant<2>
Legal node: nothing to do

Combining: t6: i32 = Constant<2>

Legalizing: t5: i32 = FrameIndex<0>
Legal node: nothing to do

Combining: t5: i32 = FrameIndex<0>

Legalizing: t1: i32 = Register %7

Combining: t1: i32 = Register %7

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
          t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
        t17: i32 = shl t2, Constant:i32<2>, loop.c:34:17
      t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
    t21: i32 = add t20, Constant:i32<-4>, loop.c:34:12
  t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5


===== Instruction selection begins: %bb.2 'for.cond.cleanup'

ISEL: Starting selection on root node: t16: ch = ARMISD::RET_FLAG t15, Register:i32 $r0, t15:1, loop.c:34:5
ISEL: Starting pattern match
  Initial Opcode index to 141200
Creating constant: t22: i32 = TargetConstant<14>
  Morphed node: t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5
ISEL: Match complete!

ISEL: Starting selection on root node: t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

ISEL: Starting selection on root node: t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

ISEL: Starting selection on root node: t11: i32,ch = load<(load (s32) from %ir.arrayidx8, !tbaa !39)> t0, t21, undef:i32, loop.c:34:12
ISEL: Starting pattern match
  Initial Opcode index to 103614
  Match failed at index 103632
  Continuing at 103652
  Match failed at index 103653
  Continuing at 103707
  Match failed at index 103708
  Continuing at 103813
  Continuing at 103814
  Match failed at index 103816
  Continuing at 103915
  Match failed at index 103930
  Continuing at 103951
  Match failed at index 103952
  Continuing at 104008
  Match failed at index 104009
  Continuing at 104065
  Match failed at index 104066
  Continuing at 104093
  Match failed at index 104094
  Continuing at 104176
  Match failed at index 104179
  Continuing at 104202
  Match failed at index 104203
  Continuing at 104259
  Match failed at index 104260
  Continuing at 104316
  Match failed at index 104317
  Continuing at 104344
  Match failed at index 104345
  Continuing at 104427
  Match failed at index 104428
  Continuing at 104520
Creating constant: t24: i32 = TargetConstant<-4>
  Morphed node: t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12
ISEL: Match complete!

ISEL: Starting selection on root node: t20: i32 = add t17, FrameIndex:i32<0>, loop.c:34:12
ISEL: Starting pattern match
  Initial Opcode index to 10547
  Skipped scope entry (due to false predicate) at index 10554, continuing at 10600
  Skipped scope entry (due to false predicate) at index 10601, continuing at 10648
  Skipped scope entry (due to false predicate) at index 10649, continuing at 10695
  Skipped scope entry (due to false predicate) at index 10696, continuing at 10743
  Skipped scope entry (due to false predicate) at index 10744, continuing at 10790
  Skipped scope entry (due to false predicate) at index 10791, continuing at 10838
  Skipped scope entry (due to false predicate) at index 10839, continuing at 10885
  Skipped scope entry (due to false predicate) at index 10886, continuing at 10933
  Match failed at index 10552
  Continuing at 10934
  Skipped scope entry (due to false predicate) at index 10939, continuing at 10986
  Skipped scope entry (due to false predicate) at index 10987, continuing at 11035
  Skipped scope entry (due to false predicate) at index 11036, continuing at 11083
  Skipped scope entry (due to false predicate) at index 11084, continuing at 11132
  Skipped scope entry (due to false predicate) at index 11133, continuing at 11180
  Skipped scope entry (due to false predicate) at index 11181, continuing at 11229
  Skipped scope entry (due to false predicate) at index 11230, continuing at 11277
  Skipped scope entry (due to false predicate) at index 11278, continuing at 11326
  Match failed at index 10937
  Continuing at 11327
  Skipped scope entry (due to false predicate) at index 11332, continuing at 11361
  Skipped scope entry (due to false predicate) at index 11362, continuing at 11392
  Skipped scope entry (due to false predicate) at index 11393, continuing at 11422
  Skipped scope entry (due to false predicate) at index 11423, continuing at 11453
  Match failed at index 11330
  Continuing at 11454
  Skipped scope entry (due to false predicate) at index 11459, continuing at 11489
  Skipped scope entry (due to false predicate) at index 11490, continuing at 11521
  Skipped scope entry (due to false predicate) at index 11522, continuing at 11552
  Skipped scope entry (due to false predicate) at index 11553, continuing at 11584
  Match failed at index 11457
  Continuing at 11585
  Match failed at index 11588
  Continuing at 11694
  Match failed at index 11697
  Continuing at 11919
  Match failed at index 11923
  Continuing at 12103
  Match failed at index 12106
  Continuing at 12320
  Match failed at index 12324
  Continuing at 12596
  Match failed at index 12599
  Continuing at 12778
  Match failed at index 12781
  Continuing at 12824
  Match failed at index 12827
  Continuing at 13013
  Match failed at index 13020
  Continuing at 13200
  Match failed at index 13206
  Continuing at 13231
  Match failed at index 13234
  Continuing at 13391
  Match failed at index 13397
  Continuing at 13422
  Continuing at 13423
  Match failed at index 13426
  Continuing at 13587
  Match failed at index 13590
  Continuing at 13630
  Match failed at index 13632
  Continuing at 13673
  Match failed at index 13677
  Continuing at 13966
  Match failed at index 13969
  Continuing at 14264
  Match failed at index 14274
  Continuing at 14298
  Match failed at index 14300
  Continuing at 14343
  Match failed at index 14347
  Continuing at 14373
  Match failed at index 14375
  Continuing at 14418
Creating constant: t25: i32 = TargetConstant<18>
  Morphed node: t20: i32 = ADDrsi FrameIndex:i32<0>, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12
ISEL: Match complete!

ISEL: Starting selection on root node: t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

ISEL: Starting selection on root node: t14: i32 = Register $r0

ISEL: Starting selection on root node: t12: i32 = TargetFrameIndex<0>

ISEL: Starting selection on root node: t5: i32 = FrameIndex<0>
Creating constant: t26: i32 = TargetConstant<0>

ISEL: Starting selection on root node: t1: i32 = Register %7

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.2 'dijkstra:for.cond.cleanup'
SelectionDAG has 16 nodes:
  t0: ch = EntryToken
      t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
      t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17
    t20: i32 = ADDrsi t5, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12
  t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12
    t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1
  t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5
  t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5


Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling %bb.2 'for.cond.cleanup' **********
SU(0): t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5

    t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 6
  Height             : 0
  Predecessors:
    SU(5): Ord  Latency=1 Barrier
    SU(1): Data Latency=2
SU(1): t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12

  # preds left       : 1
  # succs left       : 2
  # rdefs left       : 1
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(2): Data Latency=3
  Successors:
    SU(0): Data Latency=2
    SU(5): Ord  Latency=1 Barrier
SU(2): t20: i32 = ADDrsi t5, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12

  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 2
  Depth              : 1
  Height             : 5
  Predecessors:
    SU(4): Data Latency=0
    SU(3): Data Latency=1
  Successors:
    SU(1): Data Latency=3
SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 0
  Depth              : 0
  Height             : 6
  Successors:
    SU(2): Data Latency=1
SU(4): t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 5
  Successors:
    SU(2): Data Latency=0
SU(5): t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 0
  Depth              : 5
  Height             : 1
  Predecessors:
    SU(1): Ord  Latency=1 Barrier
  Successors:
    SU(0): Ord  Latency=1 Barrier

Examining Available:
Height 0: SU(0): t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5

    t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5


*** Scheduling [0]: SU(0): t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5

    t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 1: SU(5): t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1


*** Scheduling [1]: SU(5): t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

GPR: 1 / 9

Examining Available:
Height 2: SU(1): t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12


*** Scheduling [2]: SU(1): t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 5: SU(2): t20: i32 = ADDrsi t5, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12


*** Scheduling [5]: SU(2): t20: i32 = ADDrsi t5, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 2 / 9

Examining Available:
Height 6: SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

Height 5: SU(4): t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg


*** Scheduling [6]: SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

GPR: 1 / 9

Examining Available:
Height 5: SU(4): t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg


*** Scheduling [6]: SU(4): t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000000
	0000000000000000000000000000000000000000000000000000000000000001
*** Final schedule ***
SU(4): t5: i32 = ADDri TargetFrameIndex:i32<0>, TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(3): t2: i32,ch = CopyFromReg t0, Register:i32 %7, loop.c:34:17

SU(2): t20: i32 = ADDrsi t5, t2, TargetConstant:i32<18>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg, loop.c:34:12

SU(1): t11: i32,ch = LDRi12<Mem:(load (s32) from %ir.arrayidx8, !tbaa !39)> t20, TargetConstant:i32<-4>, TargetConstant:i32<14>, Register:i32 $noreg, t0, loop.c:34:12

SU(5): t13: ch = lifetime.end<0 to 2048> t11:1, TargetFrameIndex:i32<0>, loop.c:35:1

SU(0): t16: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t15, t15:1, loop.c:34:5

    t15: ch,glue = CopyToReg t13, Register:i32 $r0, t11, loop.c:34:5


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Finalize ISel and expand pseudo-instructions (finalize-isel) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Early Tail Duplication (early-tailduplication) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Optimize machine instruction PHIs (opt-phis) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
80B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
96B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
112B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
128B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
144B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
160B	  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
176B	  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
192B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
208B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
224B	  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
240B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
256B	  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
272B	  B %bb.1, debug-location !36; loop.c:27:5

288B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

304B	  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
320B	  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
336B	  B %bb.3, debug-location !36; loop.c:27:5

352B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

368B	  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
384B	  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
432B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
448B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

464B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

480B	  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
496B	  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
512B	  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
544B	  %16:gpr = MOVi32imm 1000000
560B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
592B	  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
608B	  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
624B	  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
640B	  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
656B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  LIFETIME_START %stack.0.dis, debug-location !31; loop.c:24:5
80B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
96B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
112B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
128B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
144B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
160B	  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
176B	  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
192B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
208B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
224B	  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
240B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
256B	  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
272B	  B %bb.1, debug-location !36; loop.c:27:5

288B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

304B	  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
320B	  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
336B	  B %bb.3, debug-location !36; loop.c:27:5

352B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

368B	  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
384B	  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  LIFETIME_END %stack.0.dis, debug-location !43; loop.c:35:1
432B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
448B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

464B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

480B	  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
496B	  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
512B	  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3, !tbaa !39); loop.c:28:13
544B	  %16:gpr = MOVi32imm 1000000
560B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
592B	  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
608B	  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
624B	  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
640B	  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
656B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** Stack Coloring **********
********** Function: dijkstra
Found a lifetime start marker for slot #0 with allocation: dis
Found a lifetime end marker for slot #0 with allocation: dis
Conservative slots : { 0 }
Found a use of slot #0 at %bb.0 index 96B with allocation: dis
Found a use of slot #0 at %bb.1 index 320B with allocation: dis
Found a use of slot #0 at %bb.2 index 368B with allocation: dis
Found 2 markers and 1 slots
Slot structure:
Slot #0 - 2048 bytes.
Total Stack size: 2048 bytes

Dataflow iterations: 2
Inspecting block #0 [entry]
BEGIN : { 1 }
END : { 0 }
LIVE_IN : { }
LIVE_OUT : { 1 }
Inspecting block #1 [for.body.preheader]
BEGIN : { 1 }
END : { 0 }
LIVE_IN : { 1 }
LIVE_OUT : { 1 }
Inspecting block #3 [for.body]
BEGIN : { 0 }
END : { 0 }
LIVE_IN : { 1 }
LIVE_OUT : { 1 }
Inspecting block #2 [for.cond.cleanup]
BEGIN : { 0 }
END : { 1 }
LIVE_IN : { 1 }
LIVE_OUT : { }
Interval[0]:
$noreg [96B,416B:0)[464B,672B:0) 0@0B-phi  weight:0.000000e+00
Merge 0 slots. Saved 0 bytes
Fixed 0 machine memory operands.
Fixed 0 debug locations.
Fixed 0 machine instructions.
Removed 2 markers.
# *** IR Dump After Merge disjoint stack slots (stack-coloring) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

Allocate FI(0) to local offset -2048
# *** IR Dump After Local Stack Slot Allocation (localstackalloc) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

DeadMachineInstructionElim: DELETING: %13:gpr = COPY $r0, debug-location !32; loop.c:24:9
# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  %16:gpr = MOVi32imm 1000000
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), killed %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB3[for.body]
 - 3: BB2[for.cond.cleanup]
loop-detection
 - loop = BB3[for.body]
compute-mass-in-loop: BB3[for.body]*
 - node: BB3[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.cond.cleanup]
compute-loop-scale: BB3[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[for.body]*
 - node: BB3[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.body]
 - node: BB3[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB3[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB3[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB3[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB2[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.cond.cleanup]: float = 1.0, int = 12
 - BB3[for.body]: float = 20.0, int = 255

******** Pre-regalloc Machine LICM: dijkstra ********
Entering %bb.3
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Hoisting %16:gpr = MOVi32imm 1000000
 from %bb.3 to %bb.1
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
LICM: Instruction not safe to move.
LICM: Instruction not a LICM candidate
Exiting %bb.3
# *** IR Dump After Early Machine Loop Invariant Code Motion (early-machinelicm) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %19:gpr = ADDrsi killed %18:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %14:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB3[for.body]
 - 3: BB2[for.cond.cleanup]
loop-detection
 - loop = BB3[for.body]
compute-mass-in-loop: BB3[for.body]*
 - node: BB3[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.cond.cleanup]
compute-loop-scale: BB3[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[for.body]*
 - node: BB3[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.body]
 - node: BB3[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB3[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB3[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB3[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB2[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.cond.cleanup]: float = 1.0, int = 12
 - BB3[for.body]: float = 20.0, int = 255

Entering: entry
Entering: for.cond.cleanup
Examining: %18:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
*** Found a common subexpression: %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
Exiting: for.cond.cleanup
Entering: for.body.preheader
Examining: %14:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
*** Found a common subexpression: %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
Entering: for.body
Exiting: for.body
Exiting: for.body.preheader
Exiting: entry
# *** IR Dump After Machine Common Subexpression Elimination (machine-cse) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.3
4: %bb.1
5: %bb.0
Found roots: %bb.2 
******** Machine Sinking ********
# *** IR Dump After Machine code sinking (machine-sink) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, $noreg, debug-location !34; loop.c:27:23
  CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** PEEPHOLE OPTIMIZER **********
********** Function: dijkstra
NAPhysCopy: blowing away all info due to ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
Encountered load fold barrier on ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
Encountered load fold barrier on BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
NAPhysCopy: blowing away all info due to ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
Encountered load fold barrier on ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
Attempting to optimize compare: CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
NAPhysCopy: blowing away all info due to Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
Encountered load fold barrier on Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
Optimize recurrence chain from %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
	Inst: early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
Attempting to optimize compare: CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
Encountered load fold barrier on early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
Attempting to optimize compare: CMPri %4:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  -> Successfully optimized compare!
NAPhysCopy: blowing away all info due to Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
Encountered load fold barrier on Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
# *** IR Dump After Peephole Optimizations (peephole-opt) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After ARM MVE TailPred and VPT Optimisation Pass (arm-mve-vpt-opts) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After ARM pre- register allocation load / store optimization pass (arm-prera-ldst-opt) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

Skipping Detect dead lanes pass
# *** IR Dump After Detect Dead Lanes (detect-dead-lanes) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** PROCESS IMPLICIT DEFS **********
********** Function: dijkstra
# *** IR Dump After Process Implicit Definitions (processimpdefs) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Remove unreachable machine basic blocks (unreachable-mbb-elimination) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %15:gpr(tied-def 0), %16:gpr, 0, $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Live Variable Analysis (livevars) ***:
# Machine code for function dijkstra: IsSSA, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY killed $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY killed $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY killed $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY killed %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY killed %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit killed $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %1:gpr = PHI %0:gpr, %bb.1, %6:gpr, %bb.3
  %2:gpr = PHI %10:gpr, %bb.1, %5:gpr, %bb.3
  %3:gpr = PHI %7:gpr, %bb.1, %4:gpr, %bb.3
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM killed %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr killed %15:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, killed %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri killed %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Eliminate PHI nodes for register allocation (phi-node-elimination) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY killed $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY killed $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY killed $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY killed %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY killed %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  %21:gpr = COPY killed %0:gpr
  %22:gpr = COPY %10:gpr
  %23:gpr = COPY %7:gpr
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit killed $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %3:gpr = COPY killed %23:gpr
  %2:gpr = COPY killed %22:gpr
  %1:gpr = COPY killed %21:gpr
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %15:gpr, %6:gpr = LDR_POST_IMM killed %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr killed %15:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, killed %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri killed %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  %21:gpr = COPY killed %6:gpr
  %22:gpr = COPY killed %5:gpr
  %23:gpr = COPY killed %4:gpr
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** REWRITING TWO-ADDR INSTRS **********
********** Function: dijkstra
	%15:gpr, %6:gpr = LDR_POST_IMM killed %1:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
		prepend:	%6:gpr = COPY %1:gpr, debug-location !45; loop.c:28:13
		rewrite to:	%15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
	%17:gpr = MOVCCr killed %15:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
		prepend:	%17:gpr = COPY %15:gpr, debug-location !49; loop.c:28:13
		rewrite to:	%17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
	early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, killed %2:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
		prepend:	%5:gpr = COPY %2:gpr, debug-location !50; loop.c:29:20
		rewrite to:	early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
# *** IR Dump After Two-Address instruction pass (twoaddressinstruction) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %9:gpr = COPY killed $r2
  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %8:gpr = COPY killed $r1
  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  %7:gpr = COPY killed $r0
  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  %11:gpr = MOVi 0, 14, $noreg, $noreg
  %12:gpr = MOVi 2048, 14, $noreg, $noreg
  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
  $r1 = COPY killed %11:gpr, debug-location !32; loop.c:24:9
  $r2 = COPY killed %12:gpr, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)

  %0:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  %16:gpr = MOVi32imm 1000000
  %21:gpr = COPY killed %0:gpr
  %22:gpr = COPY %10:gpr
  %23:gpr = COPY %7:gpr
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3

  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
  BX_RET 14, $noreg, implicit killed $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

  %3:gpr = COPY killed %23:gpr
  %2:gpr = COPY killed %22:gpr
  %1:gpr = COPY killed %21:gpr
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %6:gpr = COPY killed %1:gpr, debug-location !45; loop.c:28:13
  %15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  %17:gpr = COPY killed %15:gpr, debug-location !49; loop.c:28:13
  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
  %5:gpr = COPY killed %2:gpr, debug-location !50; loop.c:29:20
  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
  %4:gpr = SUBri killed %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  %21:gpr = COPY killed %6:gpr
  %22:gpr = COPY killed %5:gpr
  %23:gpr = COPY killed %4:gpr
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY killed $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY killed $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY killed $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
96B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
112B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = COPY killed %11:gpr, debug-location !32; loop.c:24:9
160B	  $r2 = COPY killed %12:gpr, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %0:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
304B	  %21:gpr = COPY killed %0:gpr
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

464B	  %3:gpr = COPY killed %23:gpr
480B	  %2:gpr = COPY killed %22:gpr
496B	  %1:gpr = COPY killed %21:gpr
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
512B	  %6:gpr = COPY killed %1:gpr, debug-location !45; loop.c:28:13
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
560B	  %17:gpr = COPY killed %15:gpr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
592B	  %5:gpr = COPY killed %2:gpr, debug-location !50; loop.c:29:20
608B	  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %4:gpr = SUBri killed %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
640B	  %21:gpr = COPY killed %6:gpr
656B	  %22:gpr = COPY killed %5:gpr
672B	  %23:gpr = COPY killed %4:gpr
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY killed $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY killed $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY killed $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
96B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
112B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = COPY killed %11:gpr, debug-location !32; loop.c:24:9
160B	  $r2 = COPY killed %12:gpr, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %0:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
304B	  %21:gpr = COPY killed %0:gpr
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

464B	  %3:gpr = COPY killed %23:gpr
480B	  %2:gpr = COPY killed %22:gpr
496B	  %1:gpr = COPY killed %21:gpr
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
512B	  %6:gpr = COPY killed %1:gpr, debug-location !45; loop.c:28:13
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
560B	  %17:gpr = COPY killed %15:gpr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
592B	  %5:gpr = COPY killed %2:gpr, debug-location !50; loop.c:29:20
608B	  early-clobber %5:gpr = STR_POST_IMM killed %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %4:gpr = SUBri killed %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
640B	  %21:gpr = COPY killed %6:gpr
656B	  %22:gpr = COPY killed %5:gpr
672B	  %23:gpr = COPY killed %4:gpr
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

Computing live-in reg-units in ABI blocks.
0B	%bb.0 R0#0 R1#0 R2#0
Created 3 new intervals.
********** INTERVALS **********
R0 [0B,48r:0)[128r,176r:3)[176r,176d:2)[416r,432r:1) 0@0B-phi 1@416r 2@176r 3@128r
R1 [0B,32r:0)[144r,176r:1) 0@0B-phi 1@144r
R2 [0B,16r:0)[160r,176r:1) 0@0B-phi 1@160r
%0 [272r,304r:0) 0@272r  weight:0.000000e+00
%1 [496r,512r:0) 0@496r  weight:0.000000e+00
%2 [480r,592r:0) 0@480r  weight:0.000000e+00
%3 [464r,624r:0) 0@464r  weight:0.000000e+00
%4 [624r,672r:0) 0@624r  weight:0.000000e+00
%5 [592r,608e:0)[608e,656r:1) 0@592r 1@608e  weight:0.000000e+00
%6 [512r,528r:0)[528r,640r:1) 0@512r 1@528r  weight:0.000000e+00
%7 [48r,384r:0)[448B,720B:0) 0@48r  weight:0.000000e+00
%8 [32r,272r:0) 0@32r  weight:0.000000e+00
%9 [16r,272r:0) 0@16r  weight:0.000000e+00
%10 [80r,384r:0)[448B,720B:0) 0@80r  weight:0.000000e+00
%11 [96r,144r:0) 0@96r  weight:0.000000e+00
%12 [112r,160r:0) 0@112r  weight:0.000000e+00
%15 [528r,560r:0) 0@528r  weight:0.000000e+00
%16 [288r,368B:0)[448B,720B:0) 0@288r  weight:0.000000e+00
%17 [560r,576r:0)[576r,608r:1) 0@560r 1@576r  weight:0.000000e+00
%19 [384r,400r:0) 0@384r  weight:0.000000e+00
%20 [400r,416r:0) 0@400r  weight:0.000000e+00
%21 [304r,368B:0)[448B,496r:2)[640r,720B:1) 0@304r 1@640r 2@448B-phi  weight:0.000000e+00
%22 [320r,368B:0)[448B,480r:2)[656r,720B:1) 0@320r 1@656r 2@448B-phi  weight:0.000000e+00
%23 [336r,368B:0)[448B,464r:2)[672r,720B:1) 0@336r 1@672r 2@448B-phi  weight:0.000000e+00
RegMasks: 176r
********** MACHINEINSTRS **********
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
96B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
112B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
160B	  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
304B	  %21:gpr = COPY %0:gpr
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

464B	  %3:gpr = COPY %23:gpr
480B	  %2:gpr = COPY %22:gpr
496B	  %1:gpr = COPY %21:gpr
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
512B	  %6:gpr = COPY %1:gpr, debug-location !45; loop.c:28:13
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
560B	  %17:gpr = COPY %15:gpr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
592B	  %5:gpr = COPY %2:gpr, debug-location !50; loop.c:29:20
608B	  early-clobber %5:gpr = STR_POST_IMM %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
640B	  %21:gpr = COPY %6:gpr
656B	  %22:gpr = COPY %5:gpr
672B	  %23:gpr = COPY %4:gpr
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Live Interval Analysis (liveintervals) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
96B	  %11:gpr = MOVi 0, 14, $noreg, $noreg
112B	  %12:gpr = MOVi 2048, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
160B	  $r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %0:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
304B	  %21:gpr = COPY %0:gpr
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

464B	  %3:gpr = COPY %23:gpr
480B	  %2:gpr = COPY %22:gpr
496B	  %1:gpr = COPY %21:gpr
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
512B	  %6:gpr = COPY %1:gpr, debug-location !45; loop.c:28:13
528B	  %15:gpr, %6:gpr = LDR_POST_IMM %6:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %15:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
560B	  %17:gpr = COPY %15:gpr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
592B	  %5:gpr = COPY %2:gpr, debug-location !50; loop.c:29:20
608B	  early-clobber %5:gpr = STR_POST_IMM %17:gpr, %5:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %3:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %4:gpr = SUBri %3:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
640B	  %21:gpr = COPY %6:gpr
656B	  %22:gpr = COPY %5:gpr
672B	  %23:gpr = COPY %4:gpr
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** SIMPLE REGISTER COALESCING **********
********** Function: dijkstra
********** JOINING INTERVALS ***********
for.body:
464B	%3:gpr = COPY %23:gpr
	Considering merging to GPR with %3 in %23
		RHS = %3 [464r,624r:0) 0@464r  weight:0.000000e+00
		LHS = %23 [336r,368B:0)[448B,464r:2)[672r,720B:1) 0@336r 1@672r 2@448B-phi  weight:0.000000e+00
		merge %3:0@464r into %23:2@448B --> @448B
		erased:	464r	%3:gpr = COPY %23:gpr
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r12 $lr $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 ]
		updated: 624B	%4:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
		updated: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
		updated: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
	Success: %3 -> %23
	Result = %23 [336r,368B:0)[448B,624r:2)[672r,720B:1) 0@336r 1@672r 2@448B-phi  weight:0.000000e+00
480B	%2:gpr = COPY %22:gpr
	Considering merging to GPR with %2 in %22
		RHS = %2 [480r,592r:0) 0@480r  weight:0.000000e+00
		LHS = %22 [320r,368B:0)[448B,480r:2)[656r,720B:1) 0@320r 1@656r 2@448B-phi  weight:0.000000e+00
		merge %2:0@480r into %22:2@448B --> @448B
		erased:	480r	%2:gpr = COPY %22:gpr
		updated: 592B	%5:gpr = COPY %22:gpr, debug-location !50; loop.c:29:20
	Success: %2 -> %22
	Result = %22 [320r,368B:0)[448B,592r:2)[656r,720B:1) 0@320r 1@656r 2@448B-phi  weight:0.000000e+00
496B	%1:gpr = COPY %21:gpr
	Considering merging to GPR with %1 in %21
		RHS = %1 [496r,512r:0) 0@496r  weight:0.000000e+00
		LHS = %21 [304r,368B:0)[448B,496r:2)[640r,720B:1) 0@304r 1@640r 2@448B-phi  weight:0.000000e+00
		merge %1:0@496r into %21:2@448B --> @448B
		erased:	496r	%1:gpr = COPY %21:gpr
		updated: 512B	%6:gpr = COPY %21:gpr, debug-location !45; loop.c:28:13
	Success: %1 -> %21
	Result = %21 [304r,368B:0)[448B,512r:2)[640r,720B:1) 0@304r 1@640r 2@448B-phi  weight:0.000000e+00
512B	%6:gpr = COPY %21:gpr, debug-location !45; loop.c:28:13
	Considering merging to GPR with %6 in %21
		RHS = %6 [512r,528r:0)[528r,640r:1) 0@512r 1@528r  weight:0.000000e+00
		LHS = %21 [304r,368B:0)[448B,512r:2)[640r,720B:1) 0@304r 1@640r 2@448B-phi  weight:0.000000e+00
		merge %21:1@640r into %6:1@528r --> @528r
		merge %6:0@512r into %21:2@448B --> @448B
		erased:	640r	%21:gpr = COPY %6:gpr
		erased:	512r	%6:gpr = COPY %21:gpr, debug-location !45; loop.c:28:13
		updated: 528B	%15:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
	Success: %6 -> %21
	Result = %21 [304r,368B:0)[448B,528r:2)[528r,720B:1) 0@304r 1@528r 2@448B-phi  weight:0.000000e+00
560B	%17:gpr = COPY %15:gpr, debug-location !49; loop.c:28:13
	Considering merging to GPR with %15 in %17
		RHS = %15 [528r,560r:0) 0@528r  weight:0.000000e+00
		LHS = %17 [560r,576r:0)[576r,608r:1) 0@560r 1@576r  weight:0.000000e+00
		merge %17:0@560r into %15:0@528r --> @528r
		erased:	560r	%17:gpr = COPY %15:gpr, debug-location !49; loop.c:28:13
		updated: 528B	%17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
		updated: 544B	CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
	Success: %15 -> %17
	Result = %17 [528r,576r:0)[576r,608r:1) 0@528r 1@576r  weight:0.000000e+00
592B	%5:gpr = COPY %22:gpr, debug-location !50; loop.c:29:20
	Considering merging to GPR with %5 in %22
		RHS = %5 [592r,608e:0)[608e,656r:1) 0@592r 1@608e  weight:0.000000e+00
		LHS = %22 [320r,368B:0)[448B,592r:2)[656r,720B:1) 0@320r 1@656r 2@448B-phi  weight:0.000000e+00
		merge %22:1@656r into %5:1@608e --> @608e
		merge %5:0@592r into %22:2@448B --> @448B
		erased:	656r	%22:gpr = COPY %5:gpr
		erased:	592r	%5:gpr = COPY %22:gpr, debug-location !50; loop.c:29:20
		updated: 608B	early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	Success: %5 -> %22
	Result = %22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:0.000000e+00
672B	%23:gpr = COPY %4:gpr
	Considering merging to GPR with %4 in %23
		RHS = %4 [624r,672r:0) 0@624r  weight:0.000000e+00
		LHS = %23 [336r,368B:0)[448B,624r:2)[672r,720B:1) 0@336r 1@672r 2@448B-phi  weight:0.000000e+00
		merge %23:1@672r into %4:0@624r --> @624r
		erased:	672r	%23:gpr = COPY %4:gpr
		updated: 624B	%23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
	Success: %4 -> %23
	Result = %23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:0.000000e+00
entry:
16B	%9:gpr = COPY $r2
	Considering merging %9 with $r2
	Can only merge into reserved registers.
32B	%8:gpr = COPY $r1
	Considering merging %8 with $r1
	Can only merge into reserved registers.
48B	%7:gpr = COPY $r0
	Considering merging %7 with $r0
	Can only merge into reserved registers.
128B	$r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
	Considering merging %10 with $r0
	Can only merge into reserved registers.
144B	$r1 = COPY %11:gpr, debug-location !32; loop.c:24:9
	Considering merging %11 with $r1
	Can only merge into reserved registers.
Remat: $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Shrink: %11 [96r,144r:0) 0@96r  weight:0.000000e+00
All defs dead: 96r	dead %11:gpr = MOVi 0, 14, $noreg, $noreg
Shrunk: %11 [96r,96d:0) 0@96r  weight:0.000000e+00
Deleting dead def 96r	dead %11:gpr = MOVi 0, 14, $noreg, $noreg
160B	$r2 = COPY %12:gpr, debug-location !32; loop.c:24:9
	Considering merging %12 with $r2
	Can only merge into reserved registers.
Remat: $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Shrink: %12 [112r,160r:0) 0@112r  weight:0.000000e+00
All defs dead: 112r	dead %12:gpr = MOVi 2048, 14, $noreg, $noreg
Shrunk: %12 [112r,112d:0) 0@112r  weight:0.000000e+00
Deleting dead def 112r	dead %12:gpr = MOVi 2048, 14, $noreg, $noreg
for.body.preheader:
304B	%21:gpr = COPY %0:gpr
	Considering merging to GPR with %0 in %21
		RHS = %0 [272r,304r:0) 0@272r  weight:0.000000e+00
		LHS = %21 [304r,368B:0)[448B,528r:2)[528r,720B:1) 0@304r 1@528r 2@448B-phi  weight:0.000000e+00
		merge %21:0@304r into %0:0@272r --> @272r
		erased:	304r	%21:gpr = COPY %0:gpr
		updated: 272B	%21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
	Success: %0 -> %21
	Result = %21 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi  weight:0.000000e+00
320B	%22:gpr = COPY %10:gpr
	Considering merging to GPR with %10 in %22
		RHS = %10 [80r,384r:0)[448B,720B:0) 0@80r  weight:0.000000e+00
		LHS = %22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:0.000000e+00
		merge %22:0@320r into %10:0@80r --> @80r
		interference at %22:1@608e
	Interference!
336B	%23:gpr = COPY %7:gpr
	Considering merging to GPR with %7 in %23
		RHS = %7 [48r,384r:0)[448B,720B:0) 0@48r  weight:0.000000e+00
		LHS = %23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:0.000000e+00
		merge %23:0@336r into %7:0@48r --> @48r
		interference at %23:2@624r
	Interference!
for.cond.cleanup:
416B	$r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
	Considering merging %20 with $r0
	Can only merge into reserved registers.
320B	%22:gpr = COPY %10:gpr
	Considering merging to GPR with %10 in %22
		RHS = %10 [80r,384r:0)[448B,720B:0) 0@80r  weight:0.000000e+00
		LHS = %22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:0.000000e+00
		merge %22:0@320r into %10:0@80r --> @80r
		interference at %22:1@608e
	Interference!
336B	%23:gpr = COPY %7:gpr
	Considering merging to GPR with %7 in %23
		RHS = %7 [48r,384r:0)[448B,720B:0) 0@48r  weight:0.000000e+00
		LHS = %23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:0.000000e+00
		merge %23:0@336r into %7:0@48r --> @48r
		interference at %23:2@624r
	Interference!
Trying to inflate 0 regs.
********** INTERVALS **********
R0 [0B,48r:0)[128r,176r:3)[176r,176d:2)[416r,432r:1) 0@0B-phi 1@416r 2@176r 3@128r
R1 [0B,32r:0)[144r,176r:1) 0@0B-phi 1@144r
R2 [0B,16r:0)[160r,176r:1) 0@0B-phi 1@160r
%7 [48r,384r:0)[448B,720B:0) 0@48r  weight:0.000000e+00
%8 [32r,272r:0) 0@32r  weight:0.000000e+00
%9 [16r,272r:0) 0@16r  weight:0.000000e+00
%10 [80r,384r:0)[448B,720B:0) 0@80r  weight:0.000000e+00
%16 [288r,368B:0)[448B,720B:0) 0@288r  weight:0.000000e+00
%17 [528r,576r:0)[576r,608r:1) 0@528r 1@576r  weight:0.000000e+00
%19 [384r,400r:0) 0@384r  weight:0.000000e+00
%20 [400r,416r:0) 0@400r  weight:0.000000e+00
%21 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi  weight:0.000000e+00
%22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:0.000000e+00
%23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:0.000000e+00
RegMasks: 176r
********** MACHINEINSTRS **********
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Simple Register Coalescing (simple-register-coalescing) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Rename Disconnected Subregister Components (rename-independent-subregs) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Machine Instruction Scheduler (machine-scheduler) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  %9:gpr = COPY $r2
	  DBG_VALUE %9:gpr, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  %8:gpr = COPY $r1
	  DBG_VALUE %8:gpr, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  %7:gpr = COPY $r0
	  DBG_VALUE %7:gpr, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), %23:gpr, %7:gpr, debug-location !33; loop.c:0 line no:27
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB3[for.body]
 - 3: BB2[for.cond.cleanup]
loop-detection
 - loop = BB3[for.body]
compute-mass-in-loop: BB3[for.body]*
 - node: BB3[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.cond.cleanup]
compute-loop-scale: BB3[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[for.body]*
 - node: BB3[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.body]
 - node: BB3[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB3[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB3[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB3[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB2[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.cond.cleanup]: float = 1.0, int = 12
 - BB3[for.body]: float = 20.0, int = 255

********** COMPUTING LIVE DEBUG VARIABLES: dijkstra **********
********** DEBUG VARIABLES **********
!"n,22"	 [0B;0e): 0 [48r;256B): 1 Loc0=$r0 Loc1=%7
!"s,22"	 [0B;0e): 0 [32r;256B): 1 Loc0=$r1 Loc1=%8
!"e,22"	 [0B;0e): 0 [16r;256B): 1 Loc0=$r2 Loc1=%9
!"max,25"	 [192r;256B): 0 Loc0=1000000
!"vis,23"	 [192r;192d): undef
!"i,27"	 [192r;256B): 0 [448B;608r): 1, 2 list [608r;624r): 1, 2 list Loc0=0 Loc1=%23 Loc2=%7
********** DEBUG LABELS **********
# *** IR Dump After Debug Variable Analysis (livedebugvars) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Live Stack Slot Analysis (livestacks) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Virtual Register Map (virtregmap) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Live Register Matrix (liveregmatrix) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** GREEDY REGISTER ALLOCATION **********
********** Function: dijkstra
********** Compute Spill Weights **********
********** Function: dijkstra
********** INTERVALS **********
R0 [0B,48r:0)[128r,176r:3)[176r,176d:2)[416r,432r:1) 0@0B-phi 1@416r 2@176r 3@128r
R1 [0B,32r:0)[144r,176r:1) 0@0B-phi 1@144r
R2 [0B,16r:0)[160r,176r:1) 0@0B-phi 1@160r
%7 [48r,384r:0)[448B,720B:0) 0@48r  weight:3.673942e-03
%8 [32r,272r:0) 0@32r  weight:2.630208e-03
%9 [16r,272r:0) 0@16r  weight:2.566057e-03
%10 [80r,384r:0)[448B,720B:0) 0@80r  weight:1.897199e-03
%16 [288r,368B:0)[448B,720B:0) 0@288r  weight:1.461111e-02
%17 [528r,576r:0)[576r,608r:1) 0@528r 1@576r  weight:2.213542e-01
%19 [384r,400r:0) 0@384r  weight:INF
%20 [400r,416r:0) 0@400r  weight:INF
%21 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi  weight:1.673194e-01
%22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:1.802902e-01
%23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:1.843993e-01
RegMasks: 176r
********** MACHINEINSTRS **********
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

Enqueuing %7
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r12 $lr $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 ]
Enqueuing %8
Enqueuing %9
Enqueuing %10
Enqueuing %16
Enqueuing %17
Enqueuing %19
Enqueuing %20
Enqueuing %21
Enqueuing %22
Enqueuing %23

selectOrSplit GPR:%7 [48r,384r:0)[448B,720B:0) 0@48r  weight:3.673942e-03 w=3.673942e-03
AllocationOrder(GPR) = [ $r0 $r1 $r2 $r3 $r12 $lr $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 ]
hints: $r0
missed hint $r0
assigning %7 to $r4: R4 [48r,384r:0)[448B,720B:0) 0@48r

selectOrSplit GPR:%10 [80r,384r:0)[448B,720B:0) 0@80r  weight:1.897199e-03 w=1.897199e-03
hints: $r0
missed hint $r0
assigning %10 to $r5: R5 [80r,384r:0)[448B,720B:0) 0@80r

selectOrSplit GPR:%9 [16r,272r:0) 0@16r  weight:2.566057e-03 w=2.566057e-03
hints: $r2
missed hint $r2
assigning %9 to $r6: R6 [16r,272r:0) 0@16r

selectOrSplit GPR:%8 [32r,272r:0) 0@32r  weight:2.630208e-03 w=2.630208e-03
hints: $r1
missed hint $r1
assigning %8 to $r7: R7 [32r,272r:0) 0@32r

selectOrSplit GPR:%20 [400r,416r:0) 0@400r  weight:INF w=INF
hints: $r0
assigning %20 to $r0: R0 [400r,416r:0) 0@400r

selectOrSplit GPR:%21 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi  weight:1.673194e-01 w=1.673194e-01
assigning %21 to $r0: R0 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi

selectOrSplit GPR:%16 [288r,368B:0)[448B,720B:0) 0@288r  weight:1.461111e-02 w=1.461111e-02
assigning %16 to $r1: R1 [288r,368B:0)[448B,720B:0) 0@288r

selectOrSplit GPR:%22 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi  weight:1.802902e-01 w=1.802902e-01
hints: $r5
assigning %22 to $r2: R2 [320r,368B:0)[448B,608e:2)[608e,720B:1) 0@320r 1@608e 2@448B-phi

selectOrSplit GPR:%23 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r  weight:1.843993e-01 w=1.843993e-01
hints: $r4
assigning %23 to $r3: R3 [336r,368B:0)[448B,624r:1)[624r,720B:2) 0@336r 1@448B-phi 2@624r

selectOrSplit GPR:%19 [384r,400r:0) 0@384r  weight:INF w=INF
assigning %19 to $r0: R0 [384r,400r:0) 0@384r

selectOrSplit GPR:%17 [528r,576r:0)[576r,608r:1) 0@528r 1@576r  weight:2.213542e-01 w=2.213542e-01
$r12 is available at cost 1
Only trying the first 10 regs.
should evict: %21 [272r,368B:0)[448B,528r:2)[528r,720B:1) 0@272r 1@528r 2@448B-phi  weight:1.673194e-01 w= 1.673194e-01
should evict: %16 [288r,368B:0)[448B,720B:0) 0@288r  weight:1.461111e-02 w= 1.461111e-02
should evict: %7 [48r,384r:0)[448B,720B:0) 0@48r  weight:3.673942e-03 w= 3.673942e-03
should evict: %10 [80r,384r:0)[448B,720B:0) 0@80r  weight:1.897199e-03 w= 1.897199e-03
evicting $r7 interference: Cascade 1
assigning %17 to $r7: R7 [528r,576r:0)[576r,608r:1) 0@528r 1@576r
Trying to reconcile hints for: %7($r4)
%7($r4) is recolorable.
Trying to reconcile hints for: %10($r5)
%10($r5) is recolorable.
Trying to reconcile hints for: %9($r6)
%9($r6) is recolorable.
Trying to reconcile hints for: %8($r7)
%8($r7) is recolorable.
# *** IR Dump After Greedy Register Allocator (greedy) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0 in %7, $r1 in %8, $r2 in %9

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)

272B	  %21:gpr = ADDrsi %9:gpr, %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3

384B	  %19:gpr = ADDrsi %10:gpr, %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)

528B	  %17:gpr, %21:gpr = LDR_POST_IMM %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM %17:gpr, %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** REWRITE VIRTUAL REGISTERS **********
********** Function: dijkstra
********** REGISTER MAP **********
[%7 -> $r4] GPR
[%8 -> $r7] GPR
[%9 -> $r6] GPR
[%10 -> $r5] GPR
[%16 -> $r1] GPR
[%17 -> $r7] GPR
[%19 -> $r0] GPR
[%20 -> $r0] GPR
[%21 -> $r0] GPR
[%22 -> $r2] GPR
[%23 -> $r3] GPR

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
16B	  %9:gpr = COPY $r2
32B	  %8:gpr = COPY $r1
48B	  %7:gpr = COPY $r0
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  %10:gpr = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY %10:gpr, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
208B	  CMPri %7:gpr, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5
> renamable $r6 = COPY $r2
> renamable $r7 = COPY $r1
> renamable $r4 = COPY $r0
> ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
> renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
> $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
> $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
> $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
> BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
> ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
> CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
> Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
> B %bb.1, debug-location !36; loop.c:27:5
256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)
	  liveins: $r4, $r5, $r6, $r7
272B	  %21:gpr = ADDrsi killed %9:gpr, killed %8:gpr, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  %16:gpr = MOVi32imm 1000000
320B	  %22:gpr = COPY %10:gpr
336B	  %23:gpr = COPY %7:gpr
352B	  B %bb.3, debug-location !36; loop.c:27:5
> renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
> renamable $r1 = MOVi32imm 1000000
> renamable $r2 = COPY renamable $r5
> renamable $r3 = COPY renamable $r4
> B %bb.3, debug-location !36; loop.c:27:5
368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3
	  liveins: $r4, $r5
384B	  %19:gpr = ADDrsi killed %10:gpr, killed %7:gpr, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  %20:gpr = LDRi12 killed %19:gpr, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
416B	  $r0 = COPY killed %20:gpr, debug-location !44; loop.c:34:5
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5
> renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
> renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
> $r0 = COPY killed renamable $r0, debug-location !44; loop.c:34:5
Identity copy: $r0 = COPY killed renamable $r0, debug-location !44; loop.c:34:5
  deleted.
> BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5
448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
	  liveins: $r0, $r1, $r2, $r3, $r4, $r5
528B	  %17:gpr, %21:gpr = LDR_POST_IMM killed %21:gpr(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri %17:gpr, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  %17:gpr = MOVCCr killed %17:gpr(tied-def 0), %16:gpr, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber %22:gpr = STR_POST_IMM killed %17:gpr, killed %22:gpr(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
624B	  %23:gpr = SUBri killed %23:gpr, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5
> renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
> CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
> renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
> early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
> renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
> Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
> B %bb.3, debug-location !36; loop.c:27:5
********** EMITTING LIVE DEBUG VARIABLES **********
!"n,22"	 [0B;0e): 0 [48r;256B): 1 Loc0=$r0 Loc1=%7
	[0B;0e): 0 %bb.0-256B
	[48r;256B): 1 %bb.0-256B
!"s,22"	 [0B;0e): 0 [32r;256B): 1 Loc0=$r1 Loc1=%8
	[0B;0e): 0 %bb.0-256B
	[32r;256B): 1 %bb.0-256B
!"e,22"	 [0B;0e): 0 [16r;256B): 1 Loc0=$r2 Loc1=%9
	[0B;0e): 0 %bb.0-256B
	[16r;256B): 1 %bb.0-256B
!"max,25"	 [192r;256B): 0 Loc0=1000000
	[192r;256B): 0 %bb.0-256B
!"vis,23"	 [192r;192d): undef
	[192r;192d): 4294967295 %bb.0-256B
!"i,27"	 [192r;256B): 0 [448B;608r): 1, 2 list [608r;624r): 1, 2 list Loc0=0 Loc1=%23 Loc2=%7
	[192r;256B): 0 %bb.0-256B
	[448B;608r): 1, 2 %bb.3-720B
	[608r;624r): 1, 2 %bb.3-720B
********** EMITTING LIVE DEBUG LABELS **********
********** EMITTING DEBUG PHIS **********
********** EMITTING INSTR REFERENCES **********
# *** IR Dump After Virtual Register Rewriter (virtregrewriter) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  renamable $r6 = COPY $r2
	  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  renamable $r7 = COPY $r1
	  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  renamable $r4 = COPY $r0
	  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
208B	  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)
	  liveins: $r4, $r5, $r6, $r7
272B	  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  renamable $r1 = MOVi32imm 1000000
320B	  renamable $r2 = COPY renamable $r5
336B	  renamable $r3 = COPY renamable $r4
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3
	  liveins: $r4, $r5
384B	  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
	  liveins: $r0, $r1, $r2, $r3, $r4, $r5
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
528B	  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
624B	  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Register Allocation Pass Scoring (regallocscoringpass) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  renamable $r6 = COPY $r2
	  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  renamable $r7 = COPY $r1
	  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  renamable $r4 = COPY $r0
	  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
208B	  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)
	  liveins: $r4, $r5, $r6, $r7
272B	  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  renamable $r1 = MOVi32imm 1000000
320B	  renamable $r2 = COPY renamable $r5
336B	  renamable $r3 = COPY renamable $r4
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3
	  liveins: $r4, $r5
384B	  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
	  liveins: $r0, $r1, $r2, $r3, $r4, $r5
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
528B	  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
624B	  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

********** Stack Slot Coloring **********
********** Function: dijkstra
# *** IR Dump After Stack Slot Coloring (stack-slot-coloring) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

0B	bb.0.entry:
	  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
	  liveins: $r0, $r1, $r2
	  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
	  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
16B	  renamable $r6 = COPY $r2
	  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
32B	  renamable $r7 = COPY $r1
	  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
48B	  renamable $r4 = COPY $r0
	  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
64B	  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
80B	  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
128B	  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
144B	  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
160B	  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
176B	  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
192B	  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
	  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
	  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
	  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
208B	  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
224B	  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
240B	  B %bb.1, debug-location !36; loop.c:27:5

256B	bb.1.for.body.preheader:
	; predecessors: %bb.0
	  successors: %bb.3(0x80000000); %bb.3(100.00%)
	  liveins: $r4, $r5, $r6, $r7
272B	  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
288B	  renamable $r1 = MOVi32imm 1000000
320B	  renamable $r2 = COPY renamable $r5
336B	  renamable $r3 = COPY renamable $r4
352B	  B %bb.3, debug-location !36; loop.c:27:5

368B	bb.2.for.cond.cleanup:
	; predecessors: %bb.0, %bb.3
	  liveins: $r4, $r5
384B	  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
400B	  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
432B	  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

448B	bb.3.for.body:
	; predecessors: %bb.1, %bb.3
	  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
	  liveins: $r0, $r1, $r2, $r3, $r4, $r5
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
528B	  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
544B	  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
576B	  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
608B	  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
	  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
624B	  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
688B	  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
704B	  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $r6 = COPY $r2
MCP: Copy is a deletion candidate:   renamable $r7 = COPY $r1
MCP: Copy is a deletion candidate:   renamable $r4 = COPY $r0
MCP: Copy is a deletion candidate:   $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
MCP: Copy is used - not dead:   $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
MCP: Copy is used - not dead:   renamable $r4 = COPY $r0
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: Copy is a deletion candidate:   renamable $r2 = COPY renamable $r5
MCP: Copy is a deletion candidate:   renamable $r3 = COPY renamable $r4
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

******** Post-regalloc Machine LICM: dijkstra ********
# *** IR Dump After Machine Loop Invariant Code Motion (machinelicm) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


Debug Value Reduction

 == Backward Scan == 

 == Forward Scan == 

 == Backward Scan == 

 == Forward Scan == 

 == Backward Scan == 

 == Forward Scan == 

 == Backward Scan == 

 == Forward Scan == 
# *** IR Dump After Remove Redundant DEBUG_VALUE analysis (removeredundantdebugvalues) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After Fixup Statepoint Caller Saved (fixup-statepoint-caller-saved) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

# *** IR Dump After PostRA Machine Sink (postra-machine-sink) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB3[for.body]
 - 3: BB2[for.cond.cleanup]
loop-detection
 - loop = BB3[for.body]
compute-mass-in-loop: BB3[for.body]*
 - node: BB3[for.body]
  => [  exit  ] weight = 67108864, succ = BB2[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB3[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB2[for.cond.cleanup]
compute-loop-scale: BB3[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB3[for.body]*
 - node: BB3[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB3[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.body]
 - node: BB3[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB2[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.cond.cleanup]
 - node: BB2[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB3[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB3[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB3[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB2[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.cond.cleanup]: float = 1.0, int = 12
 - BB3[for.body]: float = 20.0, int = 255

		Looking for trivial roots
Found a new trivial root: %bb.2
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.2
3: %bb.3
4: %bb.1
5: %bb.0
Found roots: %bb.2 
**** Analysing dijkstra
Look into: 0 entry
Use or define CSR(1) or FI(0): renamable $r6 = COPY $r2

No Shrink wrap candidate found
# *** IR Dump After Shrink Wrapping analysis (shrink-wrap) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  ADJCALLSTACKDOWN 0, 0, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  renamable $r5 = ADDri %stack.0.dis, 0, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  ADJCALLSTACKUP 0, -1, 14, $noreg, implicit-def dead $sp, implicit $sp, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  BX_RET 14, $noreg, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.

EstimatedLimit: 255; EstimatedStack: 2084; EstimatedFPStack: 32; BigFrameOffsets: 1
NumGPRSpills = 5
Spilling $r11 to make up alignment
alloc FI(1) at SP[-4]
alloc FI(2) at SP[-8]
alloc FI(3) at SP[-12]
alloc FI(4) at SP[-16]
alloc FI(5) at SP[-20]
alloc FI(6) at SP[-24]
alloc FI(0) at SP[-2072]
# *** IR Dump After Prologue/Epilogue Insertion & Frame Finalization (prologepilog) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.2(0x30000000); %bb.1(62.50%), %bb.2(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.2, 11, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.1, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.3(0x80000000); %bb.3(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4
  B %bb.3, debug-location !36; loop.c:27:5

bb.2.for.cond.cleanup:
; predecessors: %bb.0, %bb.3
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

bb.3.for.body:
; predecessors: %bb.1, %bb.3
  successors: %bb.2(0x04000000), %bb.3(0x7c000000); %bb.2(3.12%), %bb.3(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 0, killed $cpsr, debug-location !36; loop.c:27:5
  B %bb.3, debug-location !36; loop.c:27:5

# End machine code for function dijkstra.


TryTailMergeBlocks: %bb.0, %bb.3
  with successor %bb.2
  which has fall-through from %bb.1
Looking for common tails of at least 3 instructions

TryTailMergeBlocks: %bb.0, %bb.3
  with successor %bb.2
  which has fall-through from %bb.3
Looking for common tails of at least 3 instructions
# *** IR Dump After Control Flow Optimizer (branch-folder) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Tail Duplication (tailduplication) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
MCP: Copy is a deletion candidate:   renamable $r6 = COPY $r2
MCP: Copy is a deletion candidate:   renamable $r7 = COPY $r1
MCP: Copy is a deletion candidate:   renamable $r4 = COPY $r0
MCP: Copy is a deletion candidate:   $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
MCP: Copy is used - not dead:   $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
MCP: Copy is used - not dead:   renamable $r4 = COPY $r0
MCP: BackwardCopyPropagateBlock for.body.preheader
MCP: ForwardCopyPropagateBlock for.body.preheader
MCP: Copy is a deletion candidate:   renamable $r2 = COPY renamable $r5
MCP: Copy is a deletion candidate:   renamable $r3 = COPY renamable $r4
MCP: BackwardCopyPropagateBlock for.body
MCP: ForwardCopyPropagateBlock for.body
MCP: BackwardCopyPropagateBlock for.cond.cleanup
MCP: ForwardCopyPropagateBlock for.cond.cleanup
# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r6 = COPY $r2
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r7 = COPY $r1
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r4 = COPY $r0
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  renamable $r2 = COPY renamable $r5
  renamable $r3 = COPY renamable $r4

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: dijkstra
real copy:   renamable $r6 = COPY $r2
replaced by: $r6 = MOVr $r2, 14, $noreg, $noreg
real copy:   renamable $r7 = COPY $r1
replaced by: $r7 = MOVr $r1, 14, $noreg, $noreg
real copy:   renamable $r4 = COPY $r0
replaced by: $r4 = MOVr $r0, 14, $noreg, $noreg
real copy:   $r0 = COPY renamable $r5, debug-location !32; loop.c:24:9
replaced by: $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
real copy:   renamable $r2 = COPY renamable $r5
replaced by: $r2 = MOVr $r5, 14, $noreg, $noreg
real copy:   renamable $r3 = COPY renamable $r4
replaced by: $r3 = MOVr $r4, 14, $noreg, $noreg
# *** IR Dump After Post-RA pseudo instruction expansion pass (postrapseudos) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

Attempting to merge update of: renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
# *** IR Dump After ARM load / store optimization pass (arm-ldst-opt) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
SP:	0	$sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
SP:	8	$sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
R6:	10	$r6 = MOVr $r2, 14, $noreg, $noreg
R7:	11	$r7 = MOVr $r1, 14, $noreg, $noreg
R4:	12	$r4 = MOVr $r0, 14, $noreg, $noreg
R5:	13	renamable $r5 = MOVr $sp, 14, $noreg, $noreg
R0:	14	$r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
R1:	15	$r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
R2:	16	$r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
LR:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
SP:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
R0:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
CPSR:	18	CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
%bb.1: all preds known
R0:	0	renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
R1:	1	renamable $r1 = MOVi32imm 1000000
R2:	2	$r2 = MOVr $r5, 14, $noreg, $noreg
R3:	3	$r3 = MOVr $r4, 14, $noreg, $noreg
%bb.2: incomplete
R7:	0	renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
R0:	0	renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
CPSR:	1	CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
R7:	2	renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
R2:	3	early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
R3:	4	renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
CPSR:	4	renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
%bb.2: all preds known
%bb.3: all preds known
R0:	0	renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
R0:	1	renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
SP:	2	$sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
SP:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
R4:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
R5:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
R6:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
R7:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
R11:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
PC:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
********** FIX EXECUTION DOMAIN: DPR **********
%bb.0: entry
%bb.1: all preds known
%bb.2: incomplete
%bb.2: all preds known
%bb.3: all preds known
# *** IR Dump After ARM Execution Domain Fix (arm-execution-domain-fix) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

********** BREAK FALSE DEPENDENCIES **********
# *** IR Dump After BreakFalseDeps (break-false-deps) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  renamable $r1 = MOVi32imm 1000000
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  renamable $r7 = MOVCCr killed renamable $r7(tied-def 0), renamable $r1, 0, killed $cpsr, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

********** ARM EXPAND PSEUDO INSTRUCTIONS **********
********** Function: dijkstra
Expanding:   renamable $r1 = MOVi32imm 1000000
***************************************************
# *** IR Dump After ARM pseudo instruction expansion pass (arm-pseudo) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = MOVi 576, 14, $noreg, $noreg
  $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Thumb2 instruction size reduce pass (thumb2-reduce-size) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = MOVi 576, 14, $noreg, $noreg
  $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB2[for.body]
 - 3: BB3[for.cond.cleanup]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [  exit  ] weight = 67108864, succ = BB3[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB3[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB3[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.cond.cleanup]
 - node: BB3[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB2[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB3[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.body]: float = 20.0, int = 255
 - BB3[for.cond.cleanup]: float = 1.0, int = 12


TryTailMergeBlocks: %bb.0, %bb.2
  with successor %bb.3
  which has fall-through from %bb.2
Looking for common tails of at least 3 instructions

Ifcvt: function (0) 'dijkstra'
# *** IR Dump After If Converter (if-converter) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = MOVi 576, 14, $noreg, $noreg
  $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

Subtarget disables post-MI-sched.
# *** IR Dump After PostRA Machine Instruction Scheduler (postmisched) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  $r6 = MOVr $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = MOVi 576, 14, $noreg, $noreg
  $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

PostRAScheduler
Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling **********
*** Final schedule ***

********** List Scheduling **********
SU(0):   CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    ExitSU: Ord  Latency=1 Artificial
ExitSU:   Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=1 Artificial

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(0):   CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
*** Scheduling [0]: SU(0):   CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0
*** Final schedule ***
SU(0):   CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5

********** List Scheduling **********
SU(0):   $r6 = MOVr $r2, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(6): Anti Latency=0
SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(5): Anti Latency=0
SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    SU(4): Anti Latency=0
SU(3):   renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(4): Data Latency=1 Reg=$r5
SU(4):   $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(3): Data Latency=1 Reg=$r5
    SU(2): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(1): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Predecessors:
    SU(0): Anti Latency=0
  Successors:
    ExitSU: Ord  Latency=2 Artificial
ExitSU:   BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit $r0, implicit $r1, implicit $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(6): Ord  Latency=2 Artificial
    SU(5): Ord  Latency=2 Artificial
    SU(4): Ord  Latency=2 Artificial

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 4
    SU(0):   $r6 = MOVr $r2, 14, $noreg, $noreg
    SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
    SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
    SU(3):   renamable $r5 = MOVr $sp, 14, $noreg, $noreg
*** Scheduling [0]: SU(3):   renamable $r5 = MOVr $sp, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(0):   $r6 = MOVr $r2, 14, $noreg, $noreg
    SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
    SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
*** Scheduling [1]: SU(0):   $r6 = MOVr $r2, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 1

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
    SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
    SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
*** Scheduling [2]: SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 2

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
    SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
    SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
*** Scheduling [3]: SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 3

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
    SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
    SU(4):   $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
*** Scheduling [4]: SU(4):   $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 4

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 2
    SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
    SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
*** Scheduling [5]: SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 5

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
*** Scheduling [6]: SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 6
*** Final schedule ***
SU(3):   renamable $r5 = MOVr $sp, 14, $noreg, $noreg
SU(0):   $r6 = MOVr $r2, 14, $noreg, $noreg
SU(1):   $r7 = MOVr $r1, 14, $noreg, $noreg
SU(2):   $r4 = MOVr $r0, 14, $noreg, $noreg
SU(4):   $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
SU(5):   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
SU(6):   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   $sp = frame-setup SUBri killed $sp, 2048, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $r4, -24
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $r5, -20
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $r6, -16
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $r7, -12
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $r11, -8
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION offset $lr, -4
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   frame-setup CFI_INSTRUCTION def_cfa_offset 24
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
ExitSU:   $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

Fixup kills for %bb.0
********** List Scheduling **********
SU(0):   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 2
  Depth              : 0
  Height             : 3
  Successors:
    ExitSU: Ord  Latency=3 Artificial
SU(1):   $r1 = MOVi 576, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 3
  Successors:
    SU(2): Out  Latency=1
    SU(2): Data Latency=1 Reg=$r1
SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 2
  Predecessors:
    SU(1): Out  Latency=1
    SU(1): Data Latency=1 Reg=$r1
  Successors:
    ExitSU: Ord  Latency=2 Artificial
SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    ExitSU: Ord  Latency=2 Artificial
SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    ExitSU: Ord  Latency=2 Artificial

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 4
    SU(0):   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
    SU(1):   $r1 = MOVi 576, 14, $noreg, $noreg
    SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
*** Scheduling [0]: SU(1):   $r1 = MOVi 576, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 4
    SU(0):   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
    SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
    SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
*** Scheduling [1]: SU(0):   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 1

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
    SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
*** Hazard in cycle +0, SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
*** Hazard in cycle +0, SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
*** Hazard in cycle +0, SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
*** Stall in cycle 2

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 3
    SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
    SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
*** Scheduling [3]: SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 3

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 2
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
    SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
*** Scheduling [4]: SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 4

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
*** Scheduling [5]: SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 5
*** Final schedule ***
SU(1):   $r1 = MOVi 576, 14, $noreg, $noreg
SU(0):   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
SU(2):   $r1 = ORRri $r1, 999424, 14, $noreg, $noreg
SU(3):   $r2 = MOVr $r5, 14, $noreg, $noreg
SU(4):   $r3 = MOVr $r4, 14, $noreg, $noreg

Fixup kills for %bb.1
********** List Scheduling **********
*** Final schedule ***

********** List Scheduling **********
SU(0):   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  # preds left       : 0
  # succs left       : 4
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 7
  Successors:
    SU(2): Out  Latency=1
    SU(2): Data Latency=0 Reg=$r7
    SU(1): Data Latency=3 Reg=$r7
    ExitSU: Ord  Latency=2 Artificial
SU(1):   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  # preds left       : 1
  # succs left       : 3
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 4
  Predecessors:
    SU(0): Data Latency=3 Reg=$r7
  Successors:
    SU(4): Out  Latency=1
    SU(2): Data Latency=1 Reg=$cpsr
    SU(2): Anti Latency=0
SU(2):   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  # preds left       : 4
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 3
  Predecessors:
    SU(1): Data Latency=1 Reg=$cpsr
    SU(1): Anti Latency=0
    SU(0): Out  Latency=1
    SU(0): Data Latency=0 Reg=$r7
  Successors:
    SU(3): Data Latency=1 Reg=$r7
    SU(4): Anti Latency=0
SU(3):   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  # preds left       : 1
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 5
  Height             : 2
  Predecessors:
    SU(2): Data Latency=1 Reg=$r7
  Successors:
    ExitSU: Ord  Latency=2 Artificial
SU(4):   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  # preds left       : 2
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 4
  Height             : 2
  Predecessors:
    SU(2): Anti Latency=0
    SU(1): Out  Latency=1
  Successors:
    ExitSU: Ord  Latency=2 Artificial
ExitSU:   Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5
  # preds left       : 3
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 7
  Height             : 0
  Predecessors:
    SU(4): Ord  Latency=2 Artificial
    SU(3): Ord  Latency=2 Artificial
    SU(0): Ord  Latency=2 Artificial

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(0):   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
*** Scheduling [0]: SU(0):   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 0
*** Stall in cycle 1

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 0
*** Stall in cycle 2

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(1):   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
*** Scheduling [3]: SU(1):   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 3

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(2):   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
*** Scheduling [4]: SU(2):   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 4

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 2
    SU(3):   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
    SU(4):   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
*** Scheduling [5]: SU(3):   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 5

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(4):   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
*** Scheduling [6]: SU(4):   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 6
*** Final schedule ***
SU(0):   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
SU(1):   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
SU(2):   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
SU(3):   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
SU(4):   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23

Fixup kills for %bb.2
********** List Scheduling **********
*** Final schedule ***

********** List Scheduling **********
ExitSU:   $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit $r0, debug-location !44; loop.c:34:5
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0
*** Final schedule ***

********** List Scheduling **********
SU(0):   renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  # preds left       : 0
  # succs left       : 2
  # rdefs left       : 0
  Latency            : 2
  Depth              : 0
  Height             : 3
  Successors:
    SU(1): Out  Latency=1
    SU(1): Data Latency=3 Reg=$r0
SU(1):   renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  # preds left       : 2
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 3
  Height             : 0
  Predecessors:
    SU(0): Out  Latency=1
    SU(0): Data Latency=3 Reg=$r0
ExitSU:   $sp = frame-destroy ADDri killed $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  # preds left       : 0
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 0
  Height             : 0

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(0):   renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
*** Scheduling [0]: SU(0):   renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 0
*** Stall in cycle 1

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 0
*** Stall in cycle 2

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(1):   renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
*** Scheduling [3]: SU(1):   renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 3
*** Final schedule ***
SU(0):   renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
SU(1):   renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12

Fixup kills for %bb.3
# *** IR Dump After Post RA top-down list latency scheduler (post-RA-sched) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After MVE VPT block insertion pass (arm-mve-vpt) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

ARM Indirect Thunks
# *** IR Dump After ARM sls hardening pass (arm-sls-hardening) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Analyze Machine Code For Garbage Collection (gc-analysis) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.


block-frequency: dijkstra
=========================
reverse-post-order-traversal
 - 0: BB0[entry]
 - 1: BB1[for.body.preheader]
 - 2: BB2[for.body]
 - 3: BB3[for.cond.cleanup]
loop-detection
 - loop = BB2[for.body]
compute-mass-in-loop: BB2[for.body]*
 - node: BB2[for.body]
  => [  exit  ] weight = 67108864, succ = BB3[for.cond.cleanup]
  => [backedge] weight = 2080374784
  => mass:  ffffffffffffffff
  => assign f7ffffffffffffff (0800000000000000) [back] to BB2[for.body]
  => assign 0800000000000000 (0000000000000000) [exit] to BB3[for.cond.cleanup]
compute-loop-scale: BB2[for.body]*
 - exit-mass = 0800000000000000 (ffffffffffffffff - f7ffffffffffffff)
 - scale = 32.0
packaging-loop: BB2[for.body]*
 - node: BB2[for.body]
compute-mass-in-function
 - node: BB0[entry]
  => [ local  ] weight = 1342177280, succ = BB1[for.body.preheader]
  => [ local  ] weight = 805306368, succ = BB3[for.cond.cleanup]
  => mass:  ffffffffffffffff
  => assign 9fffffffffffffff (6000000000000000) to BB1[for.body.preheader]
  => assign 6000000000000000 (0000000000000000) to BB3[for.cond.cleanup]
 - node: BB1[for.body.preheader]
  => [ local  ] weight = 2147483648, succ = BB2[for.body]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB2[for.body]
 - node: BB2[for.body]
  => [ local  ] weight = 576460752303423488, succ = BB3[for.cond.cleanup]
  => mass:  9fffffffffffffff
  => assign 9fffffffffffffff (0000000000000000) to BB3[for.cond.cleanup]
 - node: BB3[for.cond.cleanup]
  => mass:  ffffffffffffffff
unwrap-loop-package: BB2[for.body]*: mass = 9fffffffffffffff, scale = 32.0
  => combined-scale = 20.0
 - BB2[for.body]: 1.0 => 20.0
float-to-int: min = 0.625, max = 20.0, factor = 12.8
 - BB0[entry]: float = 1.0, scaled = 12.8, int = 12
 - BB1[for.body.preheader]: float = 0.625, scaled = 8.0, int = 8
 - BB2[for.body]: float = 20.0, scaled = 256.0, int = 255
 - BB3[for.cond.cleanup]: float = 1.0, scaled = 12.8, int = 12
block-frequency-info: dijkstra
 - BB0[entry]: float = 1.0, int = 12
 - BB1[for.body.preheader]: float = 0.625, int = 8
 - BB2[for.body]: float = 20.0, int = 255
 - BB3[for.cond.cleanup]: float = 1.0, int = 12

		Looking for trivial roots
Found a new trivial root: %bb.3
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 4, Num: 5
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.3
3: %bb.2
4: %bb.1
5: %bb.0
Found roots: %bb.3 
Pre-computing triangle chains.
Finding best loop top for: %bb.2 ('for.body')
    final top unchanged
Finding best loop exit for: %bb.2 ('for.body')
    exiting: %bb.2 ('for.body') -> %bb.3 ('for.cond.cleanup') [L:0] (0.5833333333)
    No other candidate exit blocks, using loop header
Selecting best successor for: %bb.2 ('for.body')
Finished forming chain for header block %bb.2 ('for.body')
          ... %bb.2 ('for.body')
Selecting best successor for: %bb.0 ('entry')
    Candidate: %bb.1 ('for.body.preheader'), probability: 0x50000000 / 0x80000000 = 62.50%
    Setting it as best candidate
    Not a candidate: %bb.3 ('for.cond.cleanup') -> 0x30000000 / 0x80000000 = 37.50% (prob) (non-cold CFG conflict)
    Selected: %bb.1 ('for.body.preheader')
Merging from %bb.0 ('entry') to %bb.1 ('for.body.preheader')
Selecting best successor for: %bb.1 ('for.body.preheader')
    Candidate: %bb.2 ('for.body'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.2 ('for.body')
Merging from %bb.1 ('for.body.preheader') to %bb.2 ('for.body')
Selecting best successor for: %bb.2 ('for.body')
    Candidate: %bb.3 ('for.cond.cleanup'), probability: 0x80000000 / 0x80000000 = 100.00%
    Setting it as best candidate
    Selected: %bb.3 ('for.cond.cleanup')
Merging from %bb.2 ('for.body') to %bb.3 ('for.cond.cleanup')
Selecting best successor for: %bb.3 ('for.cond.cleanup')
Finished forming chain for header block %bb.0 ('entry')
[MBP] Function: dijkstra
Placing chain %bb.0 ('entry')
          ... %bb.1 ('for.body.preheader')
Updating terminators on %bb.0
          ... %bb.2 ('for.body')
Updating terminators on %bb.1
          ... %bb.3 ('for.cond.cleanup')
Updating terminators on %bb.2
# *** IR Dump After Branch Probability Basic Block Placement (block-placement) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Insert fentry calls (fentry-insert) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Insert XRay ops (xray-instrumentation) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Implement the 'patchable-function' attribute (patchable-function) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Thumb2 instruction size reduce pass (thumb2-reduce-size) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Unpack machine instruction bundles (unpack-mi-bundles) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After ARM block placement (arm-block-placement) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

# *** IR Dump After Contiguously Lay Out Funclets (funclet-layout) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

********** COMPUTING STACKMAP LIVENESS: dijkstra **********
# *** IR Dump After StackMap Liveness Analysis (stackmap-liveness) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.


Debug Range Extension
Creating the backup entry location:   DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Creating the backup entry location:   DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
Creating the backup entry location:   DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

OutLocs after initialization

Processing Worklist
join MBB: 0
Examining instruction:   DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Examining instruction:   DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
Examining instruction:   DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
Examining instruction:   $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
Examining instruction:   frame-setup CFI_INSTRUCTION def_cfa_offset 24
Examining instruction:   frame-setup CFI_INSTRUCTION offset $lr, -4
Examining instruction:   frame-setup CFI_INSTRUCTION offset $r11, -8
Examining instruction:   frame-setup CFI_INSTRUCTION offset $r7, -12
Examining instruction:   frame-setup CFI_INSTRUCTION offset $r6, -16
Examining instruction:   frame-setup CFI_INSTRUCTION offset $r5, -20
Examining instruction:   frame-setup CFI_INSTRUCTION offset $r4, -24
Examining instruction:   $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
Examining instruction:   frame-setup CFI_INSTRUCTION def_cfa_offset 2072
Examining instruction:   renamable $r5 = MOVr $sp, 14, $noreg, $noreg
Copy of the entry value:   $r6 = MOVr killed $r2, 14, $noreg, $noreg
Creating VarLoc for register copy:VarLoc($r6, "e", !DIExpression(), (null))
Examining instruction:   $r6 = MOVr killed $r2, 14, $noreg, $noreg
Examining instruction:   DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
Copy of the entry value:   $r7 = MOVr killed $r1, 14, $noreg, $noreg
Creating VarLoc for register copy:VarLoc($r7, "s", !DIExpression(), (null))
Examining instruction:   $r7 = MOVr killed $r1, 14, $noreg, $noreg
Examining instruction:   DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
Copy of the entry value:   $r4 = MOVr killed $r0, 14, $noreg, $noreg
Creating VarLoc for register copy:VarLoc($r4, "n", !DIExpression(), (null))
Examining instruction:   $r4 = MOVr killed $r0, 14, $noreg, $noreg
Examining instruction:   DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Examining instruction:   $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Examining instruction:   $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Examining instruction:   $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
Examining instruction:   BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
Examining instruction:   DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
Examining instruction:   DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
Examining instruction:   DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
Examining instruction:   CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
Examining instruction:   Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5
Add to OutLocs in MBB #0:  VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #0:  VarLoc($r6, "e", !DIExpression(), (null))
Add to OutLocs in MBB #0:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #0:  VarLoc($r7, "s", !DIExpression(), (null))
Add to OutLocs in MBB #0:  VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #0:  VarLoc($r4, "n", !DIExpression(), (null))
Add to OutLocs in MBB #0:  VarLoc(0, "i", !DIExpression(), (null))
Add to OutLocs in MBB #0:  VarLoc(1000000, "max", !DIExpression(), (null))

OutLocs after propagating
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))


InLocs after propagating

join MBB: 1
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
Examining instruction:   $r1 = MOVi 576, 14, $noreg, $noreg
Examining instruction:   renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
Examining instruction:   $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
Examining instruction:   $r2 = MOVr $r5, 14, $noreg, $noreg
Examining instruction:   $r3 = MOVr $r4, 14, $noreg, $noreg
Add to OutLocs in MBB #1:  VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #1:  VarLoc($r6, "e", !DIExpression(), (null))
Add to OutLocs in MBB #1:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #1:  VarLoc($r7, "s", !DIExpression(), (null))
Add to OutLocs in MBB #1:  VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #1:  VarLoc($r4, "n", !DIExpression(), (null))
Add to OutLocs in MBB #1:  VarLoc(0, "i", !DIExpression(), (null))
Add to OutLocs in MBB #1:  VarLoc(1000000, "max", !DIExpression(), (null))

OutLocs after propagating
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))


InLocs after propagating
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))

join MBB: 2
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  ignoring unvisited pred MBB: 2
Examining instruction:   DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
Examining instruction:   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
Examining instruction:   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
Examining instruction:   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
Examining instruction:   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
Examining instruction:   DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
Examining instruction:   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
Examining instruction:   Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5
Add to OutLocs in MBB #2:  VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r6, "e", !DIExpression(), (null))
Add to OutLocs in MBB #2:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r4, "n", !DIExpression(), (null))
Add to OutLocs in MBB #2:  VarLoc(1000000, "max", !DIExpression(), (null))
Add to OutLocs in MBB #2:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null))

OutLocs after propagating
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null))


InLocs after propagating
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))

join MBB: 3
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: max
Examining instruction:   renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
Examining instruction:   renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
Examining instruction:   $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
Examining instruction:   $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
Add to OutLocs in MBB #3:  VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #3:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #3:  VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #3:  VarLoc(1000000, "max", !DIExpression(), (null))

OutLocs after propagating
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))


InLocs after propagating
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))

Processing Worklist
join MBB: 1
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
join MBB: 2
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: max
Examining instruction:   DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
Examining instruction:   renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
Examining instruction:   CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
Examining instruction:   $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
Examining instruction:   early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
Examining instruction:   DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
Examining instruction:   renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
Examining instruction:   Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5
Add to OutLocs in MBB #2:  VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r6, "e", !DIExpression(), (null))
Add to OutLocs in MBB #2:  VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
Add to OutLocs in MBB #2:  VarLoc($r4, "n", !DIExpression(), (null))
Add to OutLocs in MBB #2:  VarLoc(1000000, "max", !DIExpression(), (null))

OutLocs after propagating
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))


InLocs after propagating
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))

join MBB: 3
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: max
Processing Worklist
join MBB: 2
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: max
join MBB: 3
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: i
  gathered candidate incoming var: max
  gathered candidate incoming var: e
  gathered candidate incoming var: e
  gathered candidate incoming var: s
  gathered candidate incoming var: n
  gathered candidate incoming var: n
  gathered candidate incoming var: max
Inserted:   DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
Inserted:   DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
Inserted:   DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
Inserted:   DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
Inserted:   DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25

Final OutLocs
MBB: 0:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))


Final InLocs
MBB: 1:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: s MI: VarLoc($r7, "s", !DIExpression(), (null))
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: i MI: VarLoc(0, "i", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 2:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))
MBB: 3:
 Var: e MI: VarLoc($r6, "e", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: e MI: VarLoc($r6, "e", !DIExpression(), (null))
 Var: s MI: VarLoc($r7, "s", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(DW_OP_LLVM_entry_value, 1), (null)) (backup loc)
 Var: n MI: VarLoc($r4, "n", !DIExpression(), (null))
 Var: max MI: VarLoc(1000000, "max", !DIExpression(), (null))

# *** IR Dump After Live DEBUG_VALUE analysis (livedebugvalues) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

[SafeStack] Function: main
[SafeStack]     safestack is not requested for this function
*** IR Dump After Safe Stack instrumentation pass (safe-stack) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
*** IR Dump After Module Verifier (verify) ***
; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}
		Looking for trivial roots
Found a new trivial root: %entry
Last visited node: %entry
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %entry
Found roots: %entry 
---- Branch Probability Info : main ----

Computing probabilities for entry



=== main
Creating constant: t1: i32 = Constant<0>
isHA: 0 i32
Creating new node: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Creating new node: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
Initial selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
  t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1



Combining: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1

Combining: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1

Combining: t2: i32 = Register $r0

Combining: t1: i32 = Constant<0>

Combining: t0: ch = EntryToken
Optimized lowered selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
  t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1


Legalizing node: t2: i32 = Register $r0
Ignoring node results
Legally typed node: t2: i32 = Register $r0

Legalizing node: t1: i32 = Constant<0>
Analyzing result type: i32
Legal result type
Legally typed node: t1: i32 = Constant<0>

Legalizing node: t0: ch = EntryToken
Analyzing result type: ch
Legal result type
Legally typed node: t0: ch = EntryToken

Legalizing node: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Analyzing result type: ch
Legal result type
Analyzing result type: glue
Legal result type
Analyzing operand: t0: ch = EntryToken
Legal operand
Analyzing operand: t1: i32 = Constant<0>
Legal operand
Legally typed node: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1

Legalizing node: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
Analyzing result type: ch
Legal result type
Analyzing operand: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Legal operand
Analyzing operand: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Legal operand
Legally typed node: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1

Legalizing node: t65535: ch = handlenode t4
Analyzing result type: ch
Legal result type
Analyzing operand: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
Legal operand
Legally typed node: t65535: ch = handlenode t4

Type-legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
  t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1



Legalizing: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
Legal node: nothing to do

Legalizing: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Legal node: nothing to do

Legalizing: t2: i32 = Register $r0

Legalizing: t1: i32 = Constant<0>
Legal node: nothing to do

Legalizing: t0: ch = EntryToken
Legal node: nothing to do
Legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
  t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1



Legalizing: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
Legal node: nothing to do

Combining: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1

Legalizing: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
Legal node: nothing to do

Combining: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1

Legalizing: t2: i32 = Register $r0

Combining: t2: i32 = Register $r0

Legalizing: t1: i32 = Constant<0>
Legal node: nothing to do

Combining: t1: i32 = Constant<0>

Legalizing: t0: ch = EntryToken
Legal node: nothing to do

Combining: t0: ch = EntryToken
Optimized legalized selection DAG: %bb.0 'main:entry'
SelectionDAG has 5 nodes:
    t0: ch = EntryToken
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1
  t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1


===== Instruction selection begins: %bb.0 'entry'

ISEL: Starting selection on root node: t4: ch = ARMISD::RET_FLAG t3, Register:i32 $r0, t3:1, loop.c:43:1
ISEL: Starting pattern match
  Initial Opcode index to 141200
Creating constant: t5: i32 = TargetConstant<14>
  Morphed node: t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1
ISEL: Match complete!

ISEL: Starting selection on root node: t3: ch,glue = CopyToReg t0, Register:i32 $r0, Constant:i32<0>, loop.c:43:1

ISEL: Starting selection on root node: t2: i32 = Register $r0

ISEL: Starting selection on root node: t1: i32 = Constant<0>
ISEL: Starting pattern match
  Initial Opcode index to 140738
  Match failed at index 140745
  Continuing at 140768
Creating constant: t7: i32 = TargetConstant<0>
  Morphed node: t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
ISEL: Match complete!

ISEL: Starting selection on root node: t0: ch = EntryToken

===== Instruction selection ends:
Selected selection DAG: %bb.0 'main:entry'
SelectionDAG has 8 nodes:
    t0: ch = EntryToken
    t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg
  t3: ch,glue = CopyToReg t0, Register:i32 $r0, t1, loop.c:43:1
  t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1


Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling %bb.0 'entry' **********
SU(0): t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1

    t3: ch,glue = CopyToReg t0, Register:i32 $r0, t1, loop.c:43:1

  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 1
  Depth              : 1
  Height             : 0
  Predecessors:
    SU(1): Data Latency=1
SU(1): t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 1
  Latency            : 1
  Depth              : 0
  Height             : 1
  Successors:
    SU(0): Data Latency=1

Examining Available:
Height 0: SU(0): t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1

    t3: ch,glue = CopyToReg t0, Register:i32 $r0, t1, loop.c:43:1


*** Scheduling [0]: SU(0): t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1

    t3: ch,glue = CopyToReg t0, Register:i32 $r0, t1, loop.c:43:1

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
GPR: 1 / 9

Examining Available:
Height 1: SU(1): t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg


*** Scheduling [1]: SU(1): t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
	0000000000000000000000000000000000000000000000000000000000000001
*** Final schedule ***
SU(1): t1: i32 = MOVi TargetConstant:i32<0>, TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $noreg

SU(0): t4: ch = BX_RET TargetConstant:i32<14>, Register:i32 $noreg, Register:i32 $r0, t3, t3:1, loop.c:43:1

    t3: ch,glue = CopyToReg t0, Register:i32 $r0, t1, loop.c:43:1


Total amount of phi nodes to update: 0
*** MachineFunction at end of ISel ***
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Finalize ISel and expand pseudo-instructions (finalize-isel) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Early Tail Duplication (early-tailduplication) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Optimize machine instruction PHIs (opt-phis) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# Machine code for function main: IsSSA, TracksLiveness

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function main: IsSSA, TracksLiveness

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** Stack Coloring **********
********** Function: main
# *** IR Dump After Merge disjoint stack slots (stack-coloring) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Local Stack Slot Allocation (localstackalloc) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

******** Pre-regalloc Machine LICM: main ********
# *** IR Dump After Early Machine Loop Invariant Code Motion (early-machinelicm) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

Entering: entry
Exiting: entry
# *** IR Dump After Machine Common Subexpression Elimination (machine-cse) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
******** Machine Sinking ********
# *** IR Dump After Machine code sinking (machine-sink) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** PEEPHOLE OPTIMIZER **********
********** Function: main
# *** IR Dump After Peephole Optimizations (peephole-opt) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Remove dead machine instructions (dead-mi-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After ARM MVE TailPred and VPT Optimisation Pass (arm-mve-vpt-opts) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After ARM pre- register allocation load / store optimization pass (arm-prera-ldst-opt) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

Skipping Detect dead lanes pass
# *** IR Dump After Detect Dead Lanes (detect-dead-lanes) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** PROCESS IMPLICIT DEFS **********
********** Function: main
# *** IR Dump After Process Implicit Definitions (processimpdefs) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Remove unreachable machine basic blocks (unreachable-mbb-elimination) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Live Variable Analysis (livevars) ***:
# Machine code for function main: IsSSA, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY killed %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Eliminate PHI nodes for register allocation (phi-node-elimination) ***:
# Machine code for function main: NoPHIs, TracksLiveness

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY killed %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** REWRITING TWO-ADDR INSTRS **********
********** Function: main
# *** IR Dump After Two-Address instruction pass (twoaddressinstruction) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

bb.0.entry:
  %0:gpr = MOVi 0, 14, $noreg, $noreg
  $r0 = COPY killed %0:gpr, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY killed %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Slot index numbering (slotindexes) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY killed %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%0 [16r,32r:0) 0@16r  weight:0.000000e+00
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Live Interval Analysis (liveintervals) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
16B	  %0:gpr = MOVi 0, 14, $noreg, $noreg
32B	  $r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
entry:
32B	$r0 = COPY %0:gpr, debug-location !60; loop.c:43:1
	Considering merging %0 with $r0
	Can only merge into reserved registers.
Remat: $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
Shrink: %0 [16r,32r:0) 0@16r  weight:0.000000e+00
All defs dead: 16r	dead %0:gpr = MOVi 0, 14, $noreg, $noreg
Shrunk: %0 [16r,16d:0) 0@16r  weight:0.000000e+00
Deleting dead def 16r	dead %0:gpr = MOVi 0, 14, $noreg, $noreg
Trying to inflate 0 regs.
********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Simple Register Coalescing (simple-register-coalescing) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Rename Disconnected Subregister Components (rename-independent-subregs) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Machine Instruction Scheduler (machine-scheduler) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

********** COMPUTING LIVE DEBUG VARIABLES: main **********
********** DEBUG VARIABLES **********
********** DEBUG LABELS **********
# *** IR Dump After Debug Variable Analysis (livedebugvars) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Live Stack Slot Analysis (livestacks) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Virtual Register Map (virtregmap) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Live Register Matrix (liveregmatrix) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** GREEDY REGISTER ALLOCATION **********
********** Function: main
********** Compute Spill Weights **********
********** Function: main
********** INTERVALS **********
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Greedy Register Allocator (greedy) ***:
# Machine code for function main: NoPHIs, TracksLiveness, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1
> $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
> BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1
********** EMITTING LIVE DEBUG VARIABLES **********
********** EMITTING LIVE DEBUG LABELS **********
********** EMITTING DEBUG PHIS **********
********** EMITTING INSTR REFERENCES **********
# *** IR Dump After Virtual Register Rewriter (virtregrewriter) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Register Allocation Pass Scoring (regallocscoringpass) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** Stack Slot Coloring **********
********** Function: main
# *** IR Dump After Stack Slot Coloring (stack-slot-coloring) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

0B	bb.0.entry:
32B	  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
48B	  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

******** Post-regalloc Machine LICM: main ********
# *** IR Dump After Machine Loop Invariant Code Motion (machinelicm) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


Debug Value Reduction

 == Backward Scan == 

 == Forward Scan == 
# *** IR Dump After Remove Redundant DEBUG_VALUE analysis (removeredundantdebugvalues) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Fixup Statepoint Caller Saved (fixup-statepoint-caller-saved) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After PostRA Machine Sink (postra-machine-sink) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
**** Analysing main
Look into: 0 entry
Nothing to shrink-wrap
# *** IR Dump After Shrink Wrapping analysis (shrink-wrap) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

EstimatedLimit: 4095; EstimatedStack: 16; EstimatedFPStack: 32; BigFrameOffsets: 0
# *** IR Dump After Prologue/Epilogue Insertion & Frame Finalization (prologepilog) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Control Flow Optimizer (branch-folder) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Tail Duplication (tailduplication) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

MCP: BackwardCopyPropagateBlock entry
MCP: ForwardCopyPropagateBlock entry
# *** IR Dump After Machine Copy Propagation Pass (machine-cp) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

Machine Function
********** EXPANDING POST-RA PSEUDO INSTRS **********
********** Function: main
# *** IR Dump After Post-RA pseudo instruction expansion pass (postrapseudos) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After ARM load / store optimization pass (arm-ldst-opt) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
R0:	0	$r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
********** FIX EXECUTION DOMAIN: DPR **********
# *** IR Dump After ARM Execution Domain Fix (arm-execution-domain-fix) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** BREAK FALSE DEPENDENCIES **********
# *** IR Dump After BreakFalseDeps (break-false-deps) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** ARM EXPAND PSEUDO INSTRUCTIONS **********
********** Function: main
***************************************************
# *** IR Dump After ARM pseudo instruction expansion pass (arm-pseudo) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Thumb2 instruction size reduce pass (thumb2-reduce-size) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8


Ifcvt: function (1) 'main'
# *** IR Dump After If Converter (if-converter) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

Subtarget disables post-MI-sched.
# *** IR Dump After PostRA Machine Instruction Scheduler (postmisched) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

PostRAScheduler
Using scoreboard hazard recognizer: Depth = 32
********** List Scheduling **********
*** Final schedule ***

********** List Scheduling **********
SU(0):   $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  # preds left       : 0
  # succs left       : 1
  # rdefs left       : 0
  Latency            : 1
  Depth              : 0
  Height             : 2
  Successors:
    ExitSU: Ord  Latency=2 Artificial
ExitSU:   BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1
  # preds left       : 1
  # succs left       : 0
  # rdefs left       : 0
  Latency            : 0
  Depth              : 2
  Height             : 0
  Predecessors:
    SU(0): Ord  Latency=2 Artificial

*** Examining Available
Latency Priority Queue
  Number of Queue Entries: 1
    SU(0):   $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
*** Scheduling [0]: SU(0):   $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000000
Scoreboard:
	0000000000000000000000000000000000000000000000000000000000000001
*** Max instructions per cycle 0
*** Final schedule ***
SU(0):   $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1

Fixup kills for %bb.0
# *** IR Dump After Post RA top-down list latency scheduler (post-RA-sched) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After MVE VPT block insertion pass (arm-mve-vpt) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

ARM Indirect Thunks
# *** IR Dump After ARM sls hardening pass (arm-sls-hardening) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Analyze Machine Code For Garbage Collection (gc-analysis) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


block-frequency: main
=====================
reverse-post-order-traversal
 - 0: BB0[entry]
loop-detection
compute-mass-in-function
 - node: BB0[entry]
  => mass:  ffffffffffffffff
float-to-int: min = 1.0, max = 1.0, factor = 8.0
 - BB0[entry]: float = 1.0, scaled = 8.0, int = 8
block-frequency-info: main
 - BB0[entry]: float = 1.0, int = 8

		Looking for trivial roots
Found a new trivial root: %bb.0
Last visited node: %bb.0
		Looking for non-trivial roots
Total: 1, Num: 2
Discovered CFG nodes:
0: nullptr
1: nullptr
2: %bb.0
Found roots: %bb.0 
# *** IR Dump After Branch Probability Basic Block Placement (block-placement) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Insert fentry calls (fentry-insert) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Insert XRay ops (xray-instrumentation) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Implement the 'patchable-function' attribute (patchable-function) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Thumb2 instruction size reduce pass (thumb2-reduce-size) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Unpack machine instruction bundles (unpack-mi-bundles) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After ARM block placement (arm-block-placement) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

# *** IR Dump After Contiguously Lay Out Funclets (funclet-layout) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** COMPUTING STACKMAP LIVENESS: main **********
# *** IR Dump After StackMap Liveness Analysis (stackmap-liveness) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.


Debug Range Extension

OutLocs after initialization

Processing Worklist
join MBB: 0
Examining instruction:   $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
Examining instruction:   BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

OutLocs after propagating


InLocs after propagating


Final OutLocs


Final InLocs

# *** IR Dump After Live DEBUG_VALUE analysis (livedebugvalues) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

Machine Outliner: Running on target-default functions
OutlinedSomething = 0
Stopped outlining at iteration 0 because no changes were found.
*** IR Dump After Machine Outliner (machine-outliner) ***
; ModuleID = 'loop.ll'
source_filename = "loop.c"
target datalayout = "e-m:e-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64"
target triple = "armv6kz-unknown-linux-gnueabihf"

; Function Attrs: argmemonly nofree nosync nounwind readonly
define dso_local i32 @dijkstra(i32 noundef %n, i32 noundef %s, ptr nocapture noundef readonly %e) local_unnamed_addr #0 !dbg !13 {
entry:
  %dis = alloca [512 x i32], align 8
  call void @llvm.dbg.value(metadata i32 %n, metadata !22, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 %s, metadata !23, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata ptr %e, metadata !24, metadata !DIExpression()), !dbg !30
  call void @llvm.lifetime.start.p0(i64 2048, ptr nonnull %dis) #5, !dbg !31
  call void @llvm.dbg.declare(metadata ptr %dis, metadata !26, metadata !DIExpression()), !dbg !32
  call void @llvm.memset.p0.i32(ptr noundef nonnull align 8 dereferenceable(2048) %dis, i8 0, i32 2048, i1 false), !dbg !32
  call void @llvm.dbg.value(metadata i32 1000000, metadata !27, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 undef, metadata !25, metadata !DIExpression()), !dbg !30
  call void @llvm.dbg.value(metadata i32 0, metadata !28, metadata !DIExpression()), !dbg !33
  %cmp18 = icmp sgt i32 %n, 0, !dbg !34
  br i1 %cmp18, label %for.body.preheader, label %for.cond.cleanup, !dbg !36

for.body.preheader:                               ; preds = %entry
  %0 = shl nsw i32 %s, 11, !dbg !36
  %uglygep2 = getelementptr i8, ptr %e, i32 %0, !dbg !36
  br label %for.body, !dbg !36

for.cond.cleanup:                                 ; preds = %for.body, %entry
  %sub = add nsw i32 %n, -1, !dbg !37
  %arrayidx8 = getelementptr inbounds [512 x i32], ptr %dis, i32 0, i32 %sub, !dbg !38
  %1 = load i32, ptr %arrayidx8, align 4, !dbg !38, !tbaa !39
  call void @llvm.lifetime.end.p0(i64 2048, ptr nonnull %dis) #5, !dbg !43
  ret i32 %1, !dbg !44

for.body:                                         ; preds = %for.body.preheader, %for.body
  %lsr.iv3 = phi ptr [ %uglygep2, %for.body.preheader ], [ %uglygep4, %for.body ]
  %lsr.iv1 = phi ptr [ %dis, %for.body.preheader ], [ %uglygep, %for.body ]
  %lsr.iv = phi i32 [ %n, %for.body.preheader ], [ %lsr.iv.next, %for.body ]
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)), !dbg !33
  %2 = load i32, ptr %lsr.iv3, align 4, !dbg !45, !tbaa !39
  %cmp3 = icmp eq i32 %2, 0, !dbg !48
  %spec.select = select i1 %cmp3, i32 1000000, i32 %2, !dbg !49
  store i32 %spec.select, ptr %lsr.iv1, align 4, !dbg !50
  call void @llvm.dbg.value(metadata !DIArgList(i32 %lsr.iv, i32 %n), metadata !28, metadata !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)), !dbg !33
  %lsr.iv.next = add i32 %lsr.iv, -1, !dbg !34
  %uglygep = getelementptr i8, ptr %lsr.iv1, i32 4, !dbg !34
  %uglygep4 = getelementptr i8, ptr %lsr.iv3, i32 4, !dbg !34
  %exitcond.not = icmp eq i32 %lsr.iv.next, 0, !dbg !34
  br i1 %exitcond.not, label %for.cond.cleanup, label %for.body, !dbg !36, !llvm.loop !52
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.declare(metadata, metadata, metadata) #1

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.start.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: argmemonly nofree nounwind willreturn writeonly
declare void @llvm.memset.p0.i32(ptr nocapture writeonly, i8, i32, i1 immarg) #3

; Function Attrs: argmemonly nocallback nofree nosync nounwind willreturn
declare void @llvm.lifetime.end.p0(i64 immarg, ptr nocapture) #2

; Function Attrs: mustprogress nofree norecurse nosync nounwind readnone willreturn
define dso_local i32 @main() local_unnamed_addr #4 !dbg !56 {
entry:
  ret i32 0, !dbg !60
}

; Function Attrs: nocallback nofree nosync nounwind readnone speculatable willreturn
declare void @llvm.dbg.value(metadata, metadata, metadata) #1

attributes #0 = { argmemonly nofree nosync nounwind readonly "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #1 = { nocallback nofree nosync nounwind readnone speculatable willreturn }
attributes #2 = { argmemonly nocallback nofree nosync nounwind willreturn }
attributes #3 = { argmemonly nofree nounwind willreturn writeonly }
attributes #4 = { mustprogress nofree norecurse nosync nounwind readnone willreturn "frame-pointer"="none" "min-legal-vector-width"="0" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="arm1176jzf-s" "target-features"="+armv6kz,+dsp,+fp64,+strict-align,+vfp2,+vfp2sp,-aes,-d32,-fp-armv8,-fp-armv8d16,-fp-armv8d16sp,-fp-armv8sp,-fp16,-fp16fml,-fullfp16,-neon,-sha2,-thumb-mode,-vfp3,-vfp3d16,-vfp3d16sp,-vfp3sp,-vfp4,-vfp4d16,-vfp4d16sp,-vfp4sp" }
attributes #5 = { nounwind }

!llvm.dbg.cu = !{!0}
!llvm.module.flags = !{!2, !3, !4, !5, !6, !7, !8, !9, !10, !11}
!llvm.ident = !{!12}

!0 = distinct !DICompileUnit(language: DW_LANG_C99, file: !1, producer: "clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)", isOptimized: true, runtimeVersion: 0, emissionKind: FullDebug, splitDebugInlining: false, nameTableKind: None)
!1 = !DIFile(filename: "loop.c", directory: "/home/rouzbeh/Graduate/LLVM/Active-Lane-Conslidation/test", checksumkind: CSK_MD5, checksum: "2dc758b34530a7da2189a085b7920e62")
!2 = !{i32 7, !"Dwarf Version", i32 5}
!3 = !{i32 2, !"Debug Info Version", i32 3}
!4 = !{i32 1, !"wchar_size", i32 4}
!5 = !{i32 1, !"min_enum_size", i32 4}
!6 = !{i32 8, !"branch-target-enforcement", i32 0}
!7 = !{i32 8, !"sign-return-address", i32 0}
!8 = !{i32 8, !"sign-return-address-all", i32 0}
!9 = !{i32 8, !"sign-return-address-with-bkey", i32 0}
!10 = !{i32 7, !"PIC Level", i32 2}
!11 = !{i32 7, !"PIE Level", i32 2}
!12 = !{!"clang version 15.0.0 (https://www.github.com/llvm/llvm-project.git 61baf2ffa7071944c00a0642fdb9ff77d9cff0da)"}
!13 = distinct !DISubprogram(name: "dijkstra", scope: !1, file: !1, line: 22, type: !14, scopeLine: 22, flags: DIFlagPrototyped | DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !21)
!14 = !DISubroutineType(types: !15)
!15 = !{!16, !16, !16, !17}
!16 = !DIBasicType(name: "int", size: 32, encoding: DW_ATE_signed)
!17 = !DIDerivedType(tag: DW_TAG_pointer_type, baseType: !18, size: 32)
!18 = !DICompositeType(tag: DW_TAG_array_type, baseType: !16, size: 16384, elements: !19)
!19 = !{!20}
!20 = !DISubrange(count: 512)
!21 = !{!22, !23, !24, !25, !26, !27, !28}
!22 = !DILocalVariable(name: "n", arg: 1, scope: !13, file: !1, line: 22, type: !16)
!23 = !DILocalVariable(name: "s", arg: 2, scope: !13, file: !1, line: 22, type: !16)
!24 = !DILocalVariable(name: "e", arg: 3, scope: !13, file: !1, line: 22, type: !17)
!25 = !DILocalVariable(name: "vis", scope: !13, file: !1, line: 23, type: !18)
!26 = !DILocalVariable(name: "dis", scope: !13, file: !1, line: 24, type: !18)
!27 = !DILocalVariable(name: "max", scope: !13, file: !1, line: 25, type: !16)
!28 = !DILocalVariable(name: "i", scope: !29, file: !1, line: 27, type: !16)
!29 = distinct !DILexicalBlock(scope: !13, file: !1, line: 27, column: 5)
!30 = !DILocation(line: 0, scope: !13)
!31 = !DILocation(line: 24, column: 5, scope: !13)
!32 = !DILocation(line: 24, column: 9, scope: !13)
!33 = !DILocation(line: 0, scope: !29)
!34 = !DILocation(line: 27, column: 23, scope: !35)
!35 = distinct !DILexicalBlock(scope: !29, file: !1, line: 27, column: 5)
!36 = !DILocation(line: 27, column: 5, scope: !29)
!37 = !DILocation(line: 34, column: 17, scope: !13)
!38 = !DILocation(line: 34, column: 12, scope: !13)
!39 = !{!40, !40, i64 0}
!40 = !{!"int", !41, i64 0}
!41 = !{!"omnipotent char", !42, i64 0}
!42 = !{!"Simple C/C++ TBAA"}
!43 = !DILocation(line: 35, column: 1, scope: !13)
!44 = !DILocation(line: 34, column: 5, scope: !13)
!45 = !DILocation(line: 28, column: 13, scope: !46)
!46 = distinct !DILexicalBlock(scope: !47, file: !1, line: 28, column: 13)
!47 = distinct !DILexicalBlock(scope: !35, file: !1, line: 27, column: 33)
!48 = !DILocation(line: 28, column: 21, scope: !46)
!49 = !DILocation(line: 28, column: 13, scope: !47)
!50 = !DILocation(line: 29, column: 20, scope: !51)
!51 = distinct !DILexicalBlock(scope: !46, file: !1, line: 28, column: 27)
!52 = distinct !{!52, !36, !53, !54, !55}
!53 = !DILocation(line: 33, column: 5, scope: !29)
!54 = !{!"llvm.loop.mustprogress"}
!55 = !{!"llvm.loop.unroll.disable"}
!56 = distinct !DISubprogram(name: "main", scope: !1, file: !1, line: 37, type: !57, scopeLine: 37, flags: DIFlagAllCallsDescribed, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !0, retainedNodes: !59)
!57 = !DISubroutineType(types: !58)
!58 = !{!16}
!59 = !{}
!60 = !DILocation(line: 43, column: 1, scope: !56)
# *** IR Dump After ARM Branch Targets (arm-branch-targets) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

***** ARMConstantIslands: 0 CP entries, aligned to 1 bytes *****
computeBlockSize: entry
computeBlockSize: for.body.preheader
computeBlockSize: for.body
computeBlockSize: for.cond.cleanup
Adjust block:
 - name: entry
 - number: 0
 - function: dijkstra
   - blocks: 4
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x30
00000030 %bb.1	 kb=2 ua=0 pa=0 size=0x14
00000044 %bb.2	 kb=2 ua=0 pa=0 size=0x18
0000005c %bb.3	 kb=2 ua=0 pa=0 size=0x10
Beginning CP iteration #0
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x30
00000030 %bb.1	 kb=2 ua=0 pa=0 size=0x14
00000044 %bb.2	 kb=2 ua=0 pa=0 size=0x18
0000005c %bb.3	 kb=2 ua=0 pa=0 size=0x10
Beginning BR iteration #0
Branch of destination %bb.3 from %bb.0 max delta=33554428 from 44 to 92 offset 40	Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5
Branch of destination %bb.2 from %bb.2 max delta=33554428 from 88 to 68 offset -28	Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x30
00000030 %bb.1	 kb=2 ua=0 pa=0 size=0x14
00000044 %bb.2	 kb=2 ua=0 pa=0 size=0x18
0000005c %bb.3	 kb=2 ua=0 pa=0 size=0x10
Verifying 0 CP users.

00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x30
00000030 %bb.1	 kb=2 ua=0 pa=0 size=0x14
00000044 %bb.2	 kb=2 ua=0 pa=0 size=0x18
0000005c %bb.3	 kb=2 ua=0 pa=0 size=0x10
# *** IR Dump After ARM constant island placement and branch shortening pass (arm-cp-islands) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
SP:	0	$sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
SP:	8	$sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
R5:	10	renamable $r5 = MOVr $sp, 14, $noreg, $noreg
R6:	11	$r6 = MOVr killed $r2, 14, $noreg, $noreg
R7:	12	$r7 = MOVr killed $r1, 14, $noreg, $noreg
R4:	13	$r4 = MOVr killed $r0, 14, $noreg, $noreg
R0:	14	$r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
R1:	15	$r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
R2:	16	$r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
LR:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
SP:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
R0:	17	BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
CPSR:	18	CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
%bb.1: all preds known
R1:	0	$r1 = MOVi 576, 14, $noreg, $noreg
R0:	1	renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
R1:	2	$r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
R2:	3	$r2 = MOVr $r5, 14, $noreg, $noreg
R3:	4	$r3 = MOVr $r4, 14, $noreg, $noreg
%bb.2: incomplete
R7:	0	renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
R0:	0	renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
CPSR:	1	CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
R7:	2	$r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
R2:	3	early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
R3:	4	renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
CPSR:	4	renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
%bb.2: all preds known
%bb.3: all preds known
R0:	0	renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
R0:	1	renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
SP:	2	$sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
SP:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
R4:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
R5:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
R6:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
R7:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
R11:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
PC:	3	$sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5
# *** IR Dump After ARM Low Overhead Loops pass (arm-low-overhead-loops) ***:
# Machine code for function dijkstra: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues
Frame Objects:
  fi#0: size=2048, align=8, at location [SP-2072]
  fi#1: size=4, align=4, at location [SP-4]
  fi#2: size=4, align=4, at location [SP-8]
  fi#3: size=4, align=4, at location [SP-12]
  fi#4: size=4, align=4, at location [SP-16]
  fi#5: size=4, align=4, at location [SP-20]
  fi#6: size=4, align=4, at location [SP-24]
Function Live Ins: $r0, $r1, $r2

bb.0.entry:
  successors: %bb.1(0x50000000), %bb.3(0x30000000); %bb.1(62.50%), %bb.3(37.50%)
  liveins: $r0, $r1, $r2, $r4, $r5, $r6, $r7, $r11, $lr
  DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $sp = frame-setup STMDB_UPD $sp(tied-def 0), 14, $noreg, killed $r4, killed $r5, killed $r6, killed $r7, killed $r11, killed $lr
  frame-setup CFI_INSTRUCTION def_cfa_offset 24
  frame-setup CFI_INSTRUCTION offset $lr, -4
  frame-setup CFI_INSTRUCTION offset $r11, -8
  frame-setup CFI_INSTRUCTION offset $r7, -12
  frame-setup CFI_INSTRUCTION offset $r6, -16
  frame-setup CFI_INSTRUCTION offset $r5, -20
  frame-setup CFI_INSTRUCTION offset $r4, -24
  $sp = frame-setup SUBri $sp, 2048, 14, $noreg, $noreg
  frame-setup CFI_INSTRUCTION def_cfa_offset 2072
  renamable $r5 = MOVr $sp, 14, $noreg, $noreg
  $r6 = MOVr killed $r2, 14, $noreg, $noreg
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r7 = MOVr killed $r1, 14, $noreg, $noreg
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r4 = MOVr killed $r0, 14, $noreg, $noreg
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r0 = MOVr $r5, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r1 = MOVi 0, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  $r2 = MOVi 2048, 14, $noreg, $noreg, debug-location !32; loop.c:24:9
  BL &memset, <regmask $lr $d8 $d9 $d10 $d11 $d12 $d13 $d14 $d15 $q4 $q5 $q6 $q7 $r4 $r5 $r6 $r7 $r8 $r9 $r10 $r11 $s16 $s17 $s18 $s19 $s20 $s21 $s22 $s23 $s24 $s25 $s26 $s27 and 35 more...>, implicit-def dead $lr, implicit $sp, implicit killed $r0, implicit killed $r1, implicit killed $r2, implicit-def $sp, implicit-def dead $r0, debug-location !32; loop.c:24:9
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  CMPri renamable $r4, 1, 14, $noreg, implicit-def $cpsr, debug-location !36; loop.c:27:5
  Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

bb.1.for.body.preheader:
; predecessors: %bb.0
  successors: %bb.2(0x80000000); %bb.2(100.00%)
  liveins: $r4, $r5, $r6, $r7
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  $r1 = MOVi 576, 14, $noreg, $noreg
  renamable $r0 = ADDrsi killed renamable $r6, killed renamable $r7, 90, 14, $noreg, $noreg, debug-location !36; loop.c:27:5
  $r1 = ORRri killed $r1, 999424, 14, $noreg, $noreg
  $r2 = MOVr $r5, 14, $noreg, $noreg
  $r3 = MOVr $r4, 14, $noreg, $noreg

bb.2.for.body:
; predecessors: %bb.1, %bb.2
  successors: %bb.3(0x04000000), %bb.2(0x7c000000); %bb.3(3.12%), %bb.2(96.88%)
  liveins: $r0, $r1, $r2, $r3, $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r7, renamable $r0 = LDR_POST_IMM killed renamable $r0(tied-def 1), $noreg, 4, 14, $noreg, debug-location !45 :: (load (s32) from %ir.lsr.iv3); loop.c:28:13
  DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22
  CMPri renamable $r7, 0, 14, $noreg, implicit-def $cpsr, debug-location !49; loop.c:28:13
  $r7 = MOVr renamable $r1, 0, killed $cpsr, $noreg, implicit killed renamable $r7, debug-location !49; loop.c:28:13
  early-clobber renamable $r2 = STR_POST_IMM killed renamable $r7, killed renamable $r2(tied-def 0), $noreg, 4, 14, $noreg, debug-location !50 :: (store (s32) into %ir.lsr.iv1); loop.c:29:20
  DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
  renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23
  Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

bb.3.for.cond.cleanup:
; predecessors: %bb.0, %bb.2
  liveins: $r4, $r5
  DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
  DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
  DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
  renamable $r0 = ADDrsi killed renamable $r5, killed renamable $r4, 18, 14, $noreg, $noreg, debug-location !38; loop.c:34:12
  renamable $r0 = LDRi12 killed renamable $r0, -4, 14, $noreg, debug-location !38 :: (load (s32) from %ir.arrayidx8, !tbaa !39); loop.c:34:12
  $sp = frame-destroy ADDri $sp, 2048, 14, $noreg, $noreg, debug-location !44; loop.c:34:5
  $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

# End machine code for function dijkstra.

Coalescing identical DBG_VALUE entries:
	0x558603adbcd8	DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

Coalescing identical DBG_VALUE entries:
	0x558603add900	DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22

Coalescing identical DBG_VALUE entries:
	0x558603addd68	DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

DbgValueHistoryMap:
 - n at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[1]

  Entry[1]: Debug value
   Instr: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[2]

  Entry[2]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[3]: Debug value
   Instr: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[4]

  Entry[4]: Clobber
   Instr: $r3 = MOVr $r4, 14, $noreg, $noreg

  Entry[5]: Debug value
   Instr: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[6]

  Entry[6]: Clobber
   Instr: Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[7]: Debug value
   Instr: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[8]

  Entry[8]: Clobber
   Instr: $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

 - s at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[1]

  Entry[1]: Debug value
   Instr: DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[2]

  Entry[2]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[3]: Debug value
   Instr: DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[4]

  Entry[4]: Clobber
   Instr: $r3 = MOVr $r4, 14, $noreg, $noreg

  Entry[5]: Debug value
   Instr: DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[6]

  Entry[6]: Clobber
   Instr: Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

 - e at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[1]

  Entry[1]: Debug value
   Instr: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[2]

  Entry[2]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[3]: Debug value
   Instr: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[4]

  Entry[4]: Clobber
   Instr: $r3 = MOVr $r4, 14, $noreg, $noreg

  Entry[5]: Debug value
   Instr: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[6]

  Entry[6]: Clobber
   Instr: Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[7]: Debug value
   Instr: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22
   - Closed by Entry[8]

  Entry[8]: Clobber
   Instr: $sp = frame-destroy LDMIA_RET $sp(tied-def 0), 14, $noreg, def $r4, def $r5, def $r6, def $r7, def $r11, def $pc, implicit killed $r0, debug-location !44; loop.c:34:5

 - i at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
   - Closed by Entry[1]

  Entry[1]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[2]: Debug value
   Instr: DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27
   - Closed by Entry[3]

  Entry[3]: Clobber
   Instr: $r3 = MOVr $r4, 14, $noreg, $noreg

  Entry[4]: Debug value
   Instr: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
   - Closed by Entry[5]

  Entry[5]: Debug value
   Instr: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27
   - Closed by Entry[6]

  Entry[6]: Clobber
   Instr: renamable $r3 = SUBri killed renamable $r3, 1, 14, $noreg, def $cpsr, debug-location !34; loop.c:27:23

 - vis at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE $noreg, $noreg, !"vis", !DIExpression(), debug-location !30; loop.c:0 line no:23
   - Closed by Entry[1]

  Entry[1]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

 - max at <unknown location> --
  Entry[0]: Debug value
   Instr: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
   - Closed by Entry[1]

  Entry[1]: Clobber
   Instr: Bcc %bb.3, 11, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[2]: Debug value
   Instr: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
   - Closed by Entry[3]

  Entry[3]: Clobber
   Instr: $r3 = MOVr $r4, 14, $noreg, $noreg

  Entry[4]: Debug value
   Instr: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
   - Closed by Entry[5]

  Entry[5]: Clobber
   Instr: Bcc %bb.2, 1, killed $cpsr, debug-location !36; loop.c:27:5

  Entry[6]: Debug value
   Instr: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25
   - Valid until end of function

DwarfDebug: collecting variables from MF side table
Created DbgVariable for dis
DotDebugLoc: DBG_VALUE $r0, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=73 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=77 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=77 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=77 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r4, $noreg, !"n", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=77 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r1, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=74 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=80 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r7, $noreg, !"s", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=80 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r1, $noreg, !"s", !DIExpression(DW_OP_LLVM_entry_value, 1), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=74 } !DIExpression(DW_OP_LLVM_entry_value, 1)
-----
DotDebugLoc: DBG_VALUE $r2, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=75 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=79 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=79 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=79 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE $r6, $noreg, !"e", !DIExpression(), debug-location !30; loop.c:0 line no:22

1 Values:
Loc = { reg=79 } !DIExpression()
-----
DotDebugLoc: DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27

1 Values:
!DIExpression()
-----
DotDebugLoc: DBG_VALUE 0, $noreg, !"i", !DIExpression(), debug-location !33; loop.c:0 line no:27

1 Values:
!DIExpression()
-----
DotDebugLoc: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27

1 Values:
Loc = { reg=76 } Loc = { reg=77 } !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_stack_value)
-----
DotDebugLoc: DBG_VALUE_LIST !"i", !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value), $r3, $r4, debug-location !33; loop.c:0 line no:27

1 Values:
Loc = { reg=76 } Loc = { reg=77 } !DIExpression(DW_OP_LLVM_arg, 0, DW_OP_LLVM_arg, 1, DW_OP_minus, DW_OP_consts, 18446744073709551615, DW_OP_div, DW_OP_consts, 1, DW_OP_plus, DW_OP_stack_value)
-----
DotDebugLoc: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25

1 Values:
!DIExpression()
-----
DotDebugLoc: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25

1 Values:
!DIExpression()
-----
DotDebugLoc: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25

1 Values:
!DIExpression()
-----
DotDebugLoc: DBG_VALUE 1000000, $noreg, !"max", !DIExpression(), debug-location !30; loop.c:0 line no:25

1 Values:
!DIExpression()
-----
# *** IR Dump After ARM Branch Targets (arm-branch-targets) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

***** ARMConstantIslands: 0 CP entries, aligned to 1 bytes *****
computeBlockSize: entry
Adjust block:
 - name: entry
 - number: 0
 - function: main
   - blocks: 1
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x8
Beginning CP iteration #0
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x8
Beginning BR iteration #0
00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x8
Verifying 0 CP users.

00000000 %bb.0	 kb=2 ua=0 pa=0 size=0x8
# *** IR Dump After ARM constant island placement and branch shortening pass (arm-cp-islands) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

********** REACHING DEFINITION ANALYSIS **********
%bb.0: all preds known
%bb.0: entry
R0:	0	$r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
# *** IR Dump After ARM Low Overhead Loops pass (arm-low-overhead-loops) ***:
# Machine code for function main: NoPHIs, TracksLiveness, NoVRegs, TiedOpsRewritten, TracksDebugUserValues

bb.0.entry:
  $r0 = MOVi 0, 14, $noreg, $noreg, debug-location !60; loop.c:43:1
  BX_RET 14, $noreg, implicit killed $r0, debug-location !60; loop.c:43:1

# End machine code for function main.

DbgValueHistoryMap:
DwarfDebug: collecting variables from MF side table
