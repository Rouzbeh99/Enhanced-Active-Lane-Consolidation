@book{Knuth68:art_of_programming,
  author    = {Donald E. Knuth},
  title     = {{The Art of Computer Programming, Volume {I:} Fundamental Algorithms}},
  year      = {1968},
  publisher = {Addison-Wesley}
}

@article{praharenka_vectorizing_2022,
	title = {Vectorizing divergent control flow with active-lane consolidation on long-vector architectures},
	volume = {78},
	issn = {1573-0484},
	url = {https://doi.org/10.1007/s11227-022-04359-w},
	doi = {10.1007/s11227-022-04359-w},
	abstract = {Control-flow divergence limits the applicability of loop vectorization, an important code-transformation that accelerates data-parallel loops. Control-flow divergence is commonly handled using an IF-conversion transformation combined with vector predication. However, the resulting vector instructions execute inefficiently with many inactive lanes. Branch-on-superword-condition-code (BOSCC) instructions are used to skip over some vector instructions, but their effectiveness decreases as vector length increases. This paper presents a novel vector permutation, Active-lane consolidation (ALC), that enables efficient execution of control-divergent loops by consolidating the active lanes of two vectors. This paper demonstrates the use of ALC with two loop transformations and applies them to kernels extracted from the SPEC CPU 2017 benchmark suite leading to up to a 30.9\% reduction in dynamic instruction count compared to optimization using only BOSCCs. Motivated by ALC, this paper also proposes design changes to the ARM scalable vector extension (SVE) to improve vectorization of control-divergent loops.},
	language = {en},
	number = {10},
	urldate = {2023-04-17},
	journal = {The Journal of Supercomputing},
	author = {Praharenka, Wyatt and Pankratz, David and De Carvalho, João P. L. and Amiri, Ehsan and Amaral, José Nelson},
	month = jul,
	year = {2022},
	keywords = {Code generation, Control-flow divergence, Instruction-set architecture design, Scalable vector extension, Vectorization},
	pages = {12553--12588},
	file = {Full Text PDF:/home/jaopaulolc/Zotero/storage/AG4WIILE/Praharenka et al. - 2022 - Vectorizing divergent control flow with active-lan.pdf:application/pdf},
}

@book{park1991ifconversion,
  title={On predicated execution},
  author={Park, Joseph CH and Schlansker, Mike},
  year={1991},
  publisher={Hewlett-Packard Laboratories Palo Alto, California}
}

@inproceedings{sun_wccv_2019,
	address = {Phoenix Arizona},
	title = {{WCCV}: improving the vectorization of {IF}-statements with warp-coherent conditions},
	isbn = {978-1-4503-6079-1},
	shorttitle = {{WCCV}},
	url = {https://dl.acm.org/doi/10.1145/3330345.3331059},
	doi = {10.1145/3330345.3331059},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {Proceedings of the {ACM} {International} {Conference} on {Supercomputing}},
	publisher = {ACM},
	author = {Sun, Huihui and Fey, Florian and Zhao, Jie and Gorlatch, Sergei},
	month = jun,
	year = {2019},
	pages = {319--329},
	file = {Sun et al. - 2019 - WCCV improving the vectorization of IF-statements.pdf:/home/jaopaulolc/Zotero/storage/HR28TY29/Sun et al. - 2019 - WCCV improving the vectorization of IF-statements.pdf:application/pdf},
}

@inproceedings{sun_speculative_2021,
	address = {Valencia, Spain},
	title = {Speculative {Vectorisation} with {Selective} {Replay}},
	isbn = {978-1-66543-333-4},
	url = {https://ieeexplore.ieee.org/document/9499938/},
	doi = {10.1109/ISCA52012.2021.00026},
	abstract = {While industry continues to develop SIMD vector ISAs by providing new instructions and wider data-paths, modern SIMD architectures still rely on the programmer or compiler to transform code to vector form only when it is safe. Limitations in the power of a compiler’s memory alias analysis and the presence of infrequent memory data dependences mean that whole regions of code cannot be safely vectorised without risking changing the semantics of the application, restricting the available performance.},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {2021 {ACM}/{IEEE} 48th {Annual} {International} {Symposium} on {Computer} {Architecture} ({ISCA})},
	publisher = {IEEE},
	author = {Sun, Peng and Gabrielli, Giacomo and Jones, Timothy M.},
	month = jun,
	year = {2021},
	pages = {223--236},
	file = {Sun et al. - 2021 - Speculative Vectorisation with Selective Replay.pdf:/home/jaopaulolc/Zotero/storage/DP3CVNNS/Sun et al. - 2021 - Speculative Vectorisation with Selective Replay.pdf:application/pdf},
}

@inproceedings{pohl_control_2018,
	address = {Sankt Goar Germany},
	title = {Control {Flow} {Vectorization} for {ARM} {NEON}},
	isbn = {978-1-4503-5780-7},
	url = {https://dl.acm.org/doi/10.1145/3207719.3207721},
	doi = {10.1145/3207719.3207721},
	abstract = {Single Instruction Multiple Data (SIMD) extensions in processors enable in-core parallelism for operations on vectors of data. From the compiler perspective, SIMD instructions require automatic techniques to determine how and when it is possible to express computations in terms of vector operations. When this is not possible automatically, a user may still write code in a manner that allows the compiler to deduce that vectorization is possible, or by explicitly de ne how to vectorize by using intrinsics.},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {Proceedings of the 21st {International} {Workshop} on {Software} and {Compilers} for {Embedded} {Systems}},
	publisher = {ACM},
	author = {Pohl, Angela and Cosenza, Biagio and Juurlink, Ben},
	month = may,
	year = {2018},
	pages = {66--75},
	file = {Pohl et al. - 2018 - Control Flow Vectorization for ARM NEON.pdf:/home/jaopaulolc/Zotero/storage/3VQVBSMI/Pohl et al. - 2018 - Control Flow Vectorization for ARM NEON.pdf:application/pdf},
}

@inproceedings{moll_partial_2018,
	address = {Philadelphia PA USA},
	title = {Partial control-flow linearization},
	isbn = {978-1-4503-5698-5},
	url = {https://dl.acm.org/doi/10.1145/3192366.3192413},
	doi = {10.1145/3192366.3192413},
	abstract = {If-conversion is a fundamental technique for vectorization. It accounts for the fact that in a SIMD program, several targets of a branch might be executed because of divergence. Especially for irregular data-parallel workloads, it is crucial to avoid if-converting non-divergent branches to increase SIMD utilization. In this paper, we present partial linearization, a simple and efficient if-conversion algorithm that overcomes several limitations of existing if-conversion techniques. In contrast to prior work, it has provable guarantees on which non-divergent branches are retained and will never duplicate code or insert additional branches. We show how our algorithm can be used in a classic loop vectorizer as well as to implement data-parallel languages such as ISPC or OpenCL. Furthermore, we implement prior vectorizer optimizations on top of partial linearization in a more general way. We evaluate the implementation of our algorithm in LLVM on a range of irregular data analytics kernels, a neutronics simulation benchmark and NAB, a molecular dynamics benchmark from SPEC2017 on AVX2, AVX512, and ARM Advanced SIMD machines and report speedups of up to 146\% over ICC, GCC and Clang O3.},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {Proceedings of the 39th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Moll, Simon and Hack, Sebastian},
	month = jun,
	year = {2018},
	pages = {543--556},
	file = {Moll and Hack - 2018 - Partial control-flow linearization.pdf:/home/jaopaulolc/Zotero/storage/VQ9GLCRT/Moll and Hack - 2018 - Partial control-flow linearization.pdf:application/pdf},
}

@inproceedings{jaewook_shin_superword-level_2005,
	address = {San Jose, CA, USA},
	title = {Superword-{Level} {Parallelism} in the {Presence} of {Control} {Flow}},
	isbn = {978-0-7695-2298-2},
	url = {http://ieeexplore.ieee.org/document/1402086/},
	doi = {10.1109/CGO.2005.33},
	abstract = {In this paper, we describe how to extend the concept of superword-level parallelization (SLP), used for multimedia extension architectures, so that it can be applied in the presence of control ﬂow constructs. Superword-level parallelization involves identifying scalar instructions in a large basic block that perform the same operation, and, if dependences do not prevent it, combining them into a superword operation on a multi-word object. A key insight is that we can use techniques related to optimizations for architectures supporting predicated execution, even for multimedia ISAs that do not provide hardware predication. We derive large basic blocks with predicated instructions to which SLP can be applied. We describe how to minimize overheads for superword predicates and re-introduce control ﬂow for scalar operations. We discuss other extensions to SLP to address common features of real multimedia codes. We present automatically-generated performance results on 8 multimedia codes to demonstrate the power of this approach. We observe speedups ranging from 1.97X to 15.07X as compared to both sequential execution and SLP alone.},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {International {Symposium} on {Code} {Generation} and {Optimization}},
	publisher = {IEEE},
	author = {{Jaewook Shin} and Hall, M. and Chame, J.},
	year = {2005},
	pages = {165--175},
}

@inproceedings{liu_combining_2022,
	address = {Chicago Illinois},
	title = {Combining {Run}-{Time} {Checks} and {Compile}-{Time} {Analysis} to {Improve} {Control} {Flow} {Auto}-{Vectorization}},
	isbn = {978-1-4503-9868-8},
	url = {https://dl.acm.org/doi/10.1145/3559009.3569663},
	doi = {10.1145/3559009.3569663},
	abstract = {SIMD (Single Instruction Multiple Data) instructions apply the same operation to multiple elements simultaneously. Compilers transform codes to exploit SIMD instructions through auto-vectorization. Control flow can lead to challenges for auto-vectorization tools because compilers conservatively assume branches are divergent. However, it is common that all SIMD lanes follow the same controlpath at run-time, a property we call dynamic uniformity. In this paper, we present VecRC (an auto-vectorizer with run-time checks), a novel compile-time technique that uses run-time checks to test for dynamically uniform control flows. Under the assumption of dynamic uniformity, we perform several compile-time analyses that improve control flow auto-vectorization vs state-of-the-art approaches. VecRC leverages dynamic uniformity to vectorize loops with control-dependent loop-carried dependences. Existing strategies use speculation to optimistically execute vector code, and must correct any incorrect computation due to violated run-time assumptions. VecRC performs compile-time analysis based on uniformity to support such dependences without the overhead of speculation. We propose a probability-based cost model to predict the profitability of run-time checks to avoid the specialized profiling or expensive auto-tuning required in existing methods. VecRC is evaluated in LLVM on a diverse range of benchmarks including SPEC2017, NPB, Parboil, TSVC, and Rodinia on Intel Skylake and IBM Power 9 architectures. On the Skylake architecture, geometric mean speedups of 1.31x, 1.20x, 1.19x, and 1.06x over Region Vectorizer, GCC, Clang, and ICC are obtained with VecRC on real benchmark code.},
	language = {en},
	urldate = {2023-04-14},
	booktitle = {Proceedings of the {International} {Conference} on {Parallel} {Architectures} and {Compilation} {Techniques}},
	publisher = {ACM},
	author = {Liu, Bangtian and Laird, Avery and Tsang, Wai Hung and Mahjour, Bardia and Dehnavi, Maryam Mehri},
	month = oct,
	year = {2022},
	pages = {439--450},
	file = {Liu et al. - 2022 - Combining Run-Time Checks and Compile-Time Analysi.pdf:/home/jaopaulolc/Zotero/storage/S9DX3JY8/Liu et al. - 2022 - Combining Run-Time Checks and Compile-Time Analysi.pdf:application/pdf},
}

@inproceedings{sujon_task_2013,
	address = {Edinburgh},
	title = {Task sampling: computer architecture simulation in the many-core era},
	isbn = {978-1-4799-1018-2 978-1-4799-1021-2},
	shorttitle = {Task sampling},
	url = {http://ieeexplore.ieee.org/document/6618831/},
	doi = {10.1109/PACT.2013.6618831},
	abstract = {Modern architectures increasingly rely on SIMD vectorization to improve performance for ﬂoating point intensive scientiﬁc applications. However, existing compiler optimization techniques for automatic vectorization are inhibited by the presence of unknown control ﬂow surrounding partially vectorizable computations. In this paper, we present a new approach, speculative vectorization, which speculates past dependent branches to aggressively vectorize computational paths that are expected to be taken frequently at runtime, while simply restarting the calculation using scalar instructions when the speculation fails. We have integrated our technique in an iterative optimizing compiler and have employed empirical tuning to select the proﬁtable paths for speculation. When applied to optimize 9 ﬂoating-point benchmarks, our optimizing compiler has achieved up to 6.8X speedup for single precision and 3.4X for double precision kernels using AVX, while vectorizing some operations considered not vectorizable by prior techniques.},
	language = {en},
	urldate = {2023-04-17},
	booktitle = {Proceedings of the 22nd {International} {Conference} on {Parallel} {Architectures} and {Compilation} {Techniques}},
	publisher = {IEEE},
	author = {Sujon, Majedul Haque and Whaley, R. Clint and {Qing Yi}},
	month = oct,
	year = {2013},
	pages = {405--406},
	file = {Sujon et al. - 2013 - Task sampling computer architecture simulation in.pdf:/home/jaopaulolc/Zotero/storage/PJTT278Y/Sujon et al. - 2013 - Task sampling computer architecture simulation in.pdf:application/pdf},
}

@inproceedings{shin_introducing_2007,
	title = {Introducing {Control} {Flow} into {Vectorized} {Code}},
	doi = {10.1109/PACT.2007.4336219},
	abstract = {Single instruction multiple data (SIMD) functional units are ubiquitous in modern microprocessors. Effective use of these SIMD functional units is essential in achieving the highest possible performance. Automatic generation of SIMD instructions in the presence of control flow is challenging, however, not only because SIMD code is hard to generate in the presence of arbitrarily complex control flow, but also because the SIMD code executing the instructions in all control paths may slow compared to the scalar original, which may bypass a large portion of the code. One promising technique introduced recently involves inserting branches-on-superword-condition-codes (BOSCCs) to bypass vector instructions. In this paper, we describe two techniques that improve on the previous approach. First, BOSCCs are generated in a nested fashion so that even BOSCCs themselves can be bypassed by other BOSCCs. Second, we generate all vec\_any\_* instructions to bypass even some predicate-defining instructions. We implemented these techniques in a vectorizing compiler. On 14 kernels, the compiler achieves distinct speedups, including 1.99X over the previous technique that generates single- level BOSCCs and vec\_any\_ne only.},
	booktitle = {16th {International} {Conference} on {Parallel} {Architecture} and {Compilation} {Techniques} ({PACT} 2007)},
	author = {Shin, Jaewook},
	month = sep,
	year = {2007},
	note = {ISSN: 1089-795X},
	keywords = {Automatic control, Automatic generation control, Clocks, Computer science, Kernel, Laboratories, Mathematics, Microprocessors, Parallel architectures, Parallel processing},
	pages = {280--291},
	file = {IEEE Xplore Abstract Record:/home/jaopaulolc/Zotero/storage/EIHQITGV/4336219.html:text/html;IEEE Xplore Full Text PDF:/home/jaopaulolc/Zotero/storage/E5IU6XHI/Shin - 2007 - Introducing Control Flow into Vectorized Code.pdf:application/pdf},
}

@article{shin_evaluating_2009,
	title = {Evaluating compiler technology for control-flow optimizations for multimedia extension architectures},
	volume = {33},
	issn = {0141-9331},
	url = {https://www.sciencedirect.com/science/article/pii/S0141933109000180},
	doi = {https://doi.org/10.1016/j.micpro.2009.02.002},
	abstract = {This paper addresses how to automatically generate code for multimedia extension architectures in the presence of conditionals. We evaluate the costs and benefits of exploiting branches on the aggregate condition codes associated with the fields of a superword (an aggregate object larger than a machine word) such as the branch-on-any instruction of the AltiVec. Branch-on-superword-condition-codes (BOSCC) instructions allow fast detection of aggregate conditions, an optimization opportunity often found in multimedia applications. This paper presents compiler analyses and techniques for generating efficient parallel code using BOSCC instructions. We evaluate our approach, which has been implemented in the SUIF compiler, through a set of experiments with multimedia benchmarks, and compare it with the default approach previously implemented in our compiler. Our experimental results show that using BOSCC instructions can result in better performance for applications where the aggregate condition codes of a superword often evaluate to the same value.},
	number = {4},
	journal = {Microprocessors and Microsystems},
	author = {Shin, Jaewook and Hall, Mary W. and Chame, Jacqueline},
	year = {2009},
	keywords = {Automatic vectorization, Branch-on-superword-condition-code (BOSCC), Control flow, Multimedia extension, SIMD compiler},
	pages = {235--243},
	annote = {Media and Stream Processing},
}

@inproceedings{kennedy_loop_1990,
	title = {Loop distribution with arbitrary control flow},
	doi = {10.1109/SUPERC.1990.130048},
	abstract = {A general and optimal algorithm for loop distribution when control flow is present is proposed. The algorithm can be used to enhance the effectiveness of vectorizers, parallelizers, and programming environments. The method performs loop distribution in the presence of control flow based on control dependencies. This algorithm is optimal in that it generates the minimum number of new arrays and tests possible. A code generation algorithm that produces code for the resulting program without replicating statements or conditions is also presented.{\textless}{\textgreater}},
	booktitle = {Supercomputing '90:{Proceedings} of the 1990 {ACM}/{IEEE} {Conference} on {Supercomputing}},
	author = {Kennedy, K. and McKinley, K.S.},
	month = nov,
	year = {1990},
	keywords = {Automatic control, Computer science, Control systems, Logic arrays, Logic testing, Memory management, Parallel machines, Parallel programming},
	pages = {407--416},
}

@inproceedings{allen_conversion_1983,
	address = {New York, NY, USA},
	series = {{POPL} '83},
	title = {Conversion of control dependence to data dependence},
	isbn = {978-0-89791-090-3},
	url = {https://dl.acm.org/doi/10.1145/567067.567085},
	doi = {10.1145/567067.567085},
	abstract = {Program analysis methods, especially those which support automatic vectorization, are based on the concept of interstatement dependence where a dependence holds between two statements when one of the statements computes values needed by the other. Powerful program transformation systems that convert sequential programs to a form more suitable for vector or parallel machines have been developed using this concept [AllK 82, KKLW 80].The dependence analysis in these systems is based on data dependence. In the presence of complex control flow, data dependence is not sufficient to transform programs because of the introduction of control dependences. A control dependence exists between two statements when the execution of one statement can prevent the execution of the other. Control dependences do not fit conveniently into dependence-based program translators.One solution is to convert all control dependences to data dependences by eliminating goto statements and introducing logical variables to control the execution of statements in the program. In this scheme, action statements are converted to IF statements. The variables in the conditional expression of an IF statement can be viewed as inputs to the statement being controlled. The result is that control dependences between statements become explicit data dependences expressed through the definitions and uses of the controlling logical variables.This paper presents a method for systematically converting control dependences to data dependences in this fashion. The algorithms presented here have been implemented in PFC, an experimental vectorizer written at Rice University.},
	urldate = {2023-04-17},
	booktitle = {Proceedings of the 10th {ACM} {SIGACT}-{SIGPLAN} symposium on {Principles} of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Allen, J. R. and Kennedy, Ken and Porterfield, Carrie and Warren, Joe},
	month = jan,
	year = {1983},
	pages = {177--189},
}

@manual{A64FXmanual,
author = {Fujitsu},
title = {{A64FX}: {M}icroarchitecture {M}anual},
year = {2020},
month = {10},
language = {English},
version = {Version 1.3},
organization = {Fujitsu Limited},
pagetotal = {136},
}

@article{Horwitz1997MayAliasNPHard,
author = {Horwitz, Susan},
title = {Precise Flow-Insensitive May-Alias Analysis is NP-Hard},
year = {1997},
issue_date = {Jan. 1997},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {19},
number = {1},
issn = {0164-0925},
url = {https://doi.org/10.1145/239912.239913},
doi = {10.1145/239912.239913},
journal = {ACM Trans. Program. Lang. Syst.},
month = {1},
pages = {1–6},
numpages = {6},
keywords = {pointer analysis, static analysis, dataflow analysis, alias analysis}
}

@inproceedings{Landi1991PointerAliasing,
author = {Landi, William and Ryder, Barbara G.},
title = {Pointer-Induced Aliasing: A Problem Classification},
year = {1991},
isbn = {0897914198},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/99583.99599},
doi = {10.1145/99583.99599},
booktitle = {Proceedings of the 18th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {93–103},
numpages = {11},
location = {Orlando, Florida, USA},
series = {POPL '91}
}

@article{scarborough1986vectorizing,
  title={A vectorizing Fortran compiler},
  author={Scarborough, Randolph G and Kolsky, Harwood G},
  journal={IBM Journal of Research and Development},
  volume={30},
  number={2},
  pages={163--171},
  year={1986},
  publisher={IBM}
}

@article{levine1991comparative,
  title={A comparative study of automatic vectorizing compilers},
  author={Levine, David and Callahan, David and Dongarra, Jack},
  journal={Parallel Computing},
  volume={17},
  number={10-11},
  pages={1223--1244},
  year={1991},
  publisher={Elsevier}
}

@article{sreraman2000vectorizing,
  title={A vectorizing compiler for multimedia extensions},
  author={Sreraman, Narasimhan and Govindarajan, Ramaswamy},
  journal={International Journal of Parallel Programming},
  volume={28},
  pages={363--400},
  year={2000},
  publisher={Springer}
}

@inproceedings{maleki2011evaluation,
  title={An evaluation of vectorizing compilers},
  author={Maleki, Saeed and Gao, Yaoqing and Garzar, Maria J and Wong, Tommy and Padua, David A and others},
  booktitle={2011 International Conference on Parallel Architectures and Compilation Techniques},
  pages={372--382},
  year={2011},
  organization={IEEE}
}

@software{spec,
author={The Standard Performance Evaluation Corporation (SPEC)},
title={{The SPEC2017 Benchmark Suite}},
url={https://www.spec.org/cpu2017/},
version = {1.1.0},
date={2019-09-21}
}

@software{papi,
  author = {{Innovative Computing Laboratory (ICL)}},
  title = {{PAPI: The Performance Application Programming Interface}},
  url = {https://icl.utk.edu/papi/},
  version = {7.0.0},
  date = {2022-11-14},
}

@INPROCEEDINGS{MiBench,
  author={Guthaus, M.R. and Ringenberg, J.S. and Ernst, D. and Austin, T.M. and Mudge, T. and Brown, R.B.},
  booktitle={Proceedings of the Fourth Annual IEEE International Workshop on Workload Characterization. WWC-4 (Cat. No.01EX538)}, 
  title={MiBench: A free, commercially representative embedded benchmark suite}, 
  year={2001},
  volume={},
  number={},
  pages={3-14},
  doi={10.1109/WWC.2001.990739}}

@ARTICLE{9730815,
  author={Hwu, Wen-mei},
  journal={Computer}, 
  title={Introduction to predicated execution}, 
  year={1998},
  volume={31},
  number={1},
  pages={49-50},
  doi={10.1109/MC.1998.9730815}
}
