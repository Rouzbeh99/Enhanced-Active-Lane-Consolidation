\section{Related Work}
\label{sec:related-works}

% If-conversion paragraph
% - Idea of convertion control-flow dependencies into data dependencies.
% - Increases the oportunities for vectorization
% - Leads to waste of resources as it keep units busy with computations on vectors with inactive lanes.
The seminal work by Allen \etal introduced the idea of converting control-flow dependencies into data dependencies \cite{allen_conversion_1983}.
Allen \etal's technique, commonly know as control-flow linearization or \ifconversion \cite{park1991ifconversion}, was introduced in the context of parallelizing FORTRAN compilers.
Such compilers excelled in exploiting data-parallel loops by identifying data dependencies.
Although \ifconversion can increase the opportunities for vectorization \cite{jaewook_shin_superword-level_2005}, it can significantly waste computational resources.
\ifconverted code keeps units busy with computations on vectors with inactive lanes, which correspond to non-taken paths in the original program's CFG.
As the results in this work show, ALC outperforms \ifconverted code because it maximizes SIMD utilization by constructing uniform vector and avoiding the execution of linearized code.

% BOSCC paragraph
% - Idea is based on guard conditions to execute uniform blocks when predicates are uniform
% - On longer vectors probability of uniform vectors decrease.
% - ALC is more effective because it constructions uniform vectors.
% - In the experiments, because sparcity is random, it would defeat BOSCCs which would degenerate into if-converted code.
Branch-on-superword-condition-codes (BOSCCs) is a common approach that avoids executing vector instructions with inactive lanes \cite{shin_introducing_2007}.
Originally introduced for multimedia extensions, BOSCCs are instructions, or sequences of instructions, that guard the execution of uniform paths.
Such paths only contain instructions that would be executed when all lanes are active (or inactive) with respect to the guard condition.
BOSCCs can improve on \ifconverted code \cite{shin_evaluating_2009}, however, BOSCCs degenerate into \ifconverted code when uniform vectors are infrequent \cite{praharenka_vectorizing_2022}.
ALC overcomes this by actively merging non-uniform vector until a unform vector is formed, thus effectively avoiding \ifconverted code. 
Moreover, BOSCCs can lead to code explosion on loops with many \cpaths.
Moll \etal's work addresses code explosion by selectively using BOSCCs and \ifconversion \cite{moll_partial_2018}.
Nevertheless, Moll \etal's solution still degenerate into \ifconverted code when uniformity is infrequent or not contiguous (w.r.t. loop iterations).

% ALC paragraph
% - Discuss the novelty of Wyatt's approach
% - Mentions the limitations:
%   - Results from Simulation
%   - Measured only dynamic instruction
% - This work evaluates ALC in real HW
% - Shows that decreasing the number of dynamic instructions does not necessary lead to better performance
% - Re-designs ALC as a compiler-enabled transformation with heuristics to decice on cost/benefit of applying ALC.
Wyatt \etal made a step forward by actively constructing uniform vectors instead of expecting dynamic uniformity \cite{praharenka_vectorizing_2022}.
ALC makes use of SVE instructions to merge active lanes and execute uniform paths.
However, in Wyatt \etal's seminal work, there was no in-silicon implementation of SVE, thus all the evaluation was conducted on Arm's instruction emulator (ArmIE).
As a result, only decrease in number of dynamic instructions was reported on Wyatt \etal's paper.
In contrast, this work evaluates ALC on real hardware with SVE.
Besides identifying a major problem in its original design (\rsec{gathers-scatters-are-bad}), this work re-designs ALC as a compiler-enabled transformation.
Moreover, experimental results show that avoiding gather instructions via data permutation improves on ALC prior design up to $4\times$ (\rsec{data-permutation-evaluation}).
Results also indicate that factors used in the proposed cost/benefit analysis (\rsec{alc-analysis}) directly impact ALC's performance.
Finally, the new ALC design outperforms \ifconverted code produced by state-of-the-art compilers.
Despite these significant advancements, there are still challenges that can limit ALC effectiveness as a compiler pass (\rsec{eval-limitations}).